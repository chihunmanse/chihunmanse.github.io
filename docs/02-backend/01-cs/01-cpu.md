---
title: CPU
tags: [BackEnd, CS, CPU]
sidebar_position: 1
---

# CPU

## 작동 원리

CPU는 메모리에 저장된 명령어를 읽어 들이고, 해석하고, 실행하는 장치이다. CPU 내부에는 계산을 담당하는 ALU, 명령어를 읽어 들이고 해석하는 제어장치, 작은 임시 저장 장치인 레지스터라는 구성 요소가 있다.

### ALU

ALU는 레지스터를 통해 피연산자를 받아들이고, 제어장치로부터 수행할 연산을 알려주는 제어 신호를 받아들인다. ALU는 레지스터와 제어장치로부터 받아들인 피연산자와 제어 신호로 산술 연산, 논리 연산 등 다양한 연산을 수행한다.

연산을 수행한 결과는 특정 숫자나 문자가 될 수도 있고, 메모리 주소가 될 수도 있다. 그리고 이 결괏값은 바로 메모리에 저장되지 않고 일시적으로 레지스터에 저장된다.

ALU는 계산 결과와 더불어 플래그를 내보낸다. 플래그는 연산 결과에 대한 추가적인 상태 정보로 플래그 레지스터라는 레지스터에 저장된다.

### 제어장치

제어장치는 제어 신호를 내보내고, 명령어를 해석하는 부품이다. 제어 신호란 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호이다.

#### ALU가 받아들이는 정보

**클럭 신호**

클럭의 주기에 맞춰 한 레지스터에서 다른 레지스터로 데이터가 이동되거나, ALU에서 연산이 수행되거나, CPU가 메모리에 저장된 명령어를 읽어 들인다.

**해석해야할 명령어**

CPU가 해석해야 할 명령어는 명령어 레지스터에 저장된다. 제어장치는 이 명령어 레지스터로부터 해석할 명령어를 받아들이고 해석한 뒤, 제어 신호를 발생시켜 컴퓨터 부품들에 수행해야 할 내용을 알려준다.

**플래그**

제어장치는 플래그 값을 받아들이고 이를 참고하여 제어 신호를 발생시킨다.

**제어 버스로 전달된 제어 신호**

제어 신호는 CPU뿐만 아니라 입출력장치를 비롯한 CPU 외부 장치도 발생시킬 수 있다. 제어장치는 제어 버스를 통해 외부로부터 전달된 제어 신호를 받아들인다.

### 레지스터

레지스터는 CPU 내부에서 데이터를 임시로 저장하는 고속 메모리이다. 레지스터는 매우 적은 용량을 가지지만, CPU가 명령어를 실행할 때 필요한 데이터나 주소를 매우 빠르게 접근할 수 있도록 도와준다.

#### 주요 레지스터

**프로그램 카운터**

프로그램 카운터는 메모리에서 가져올 명령어의 주소, 즉 메모리에서 읽어 들일 명령어의 주소를 저장한다.

**명령어 레지스터**

명령어 레지스터는 해석할 명령어, 즉 방금 메모리에서 읽어 들인 명령어를 저장하는 레지스터이다. 제어장치는 명령어 레지스터 속 명령어를 받아들이고 이를 해석한 뒤 제어 신호를 내보낸다.

**메모리 주소 레지스터**

메모리 주소 레지스터는 메모리의 주소를 저장하는 레지스터이다. CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거치게 된다.

**메모리 버퍼 레지스터**

메모리 버퍼 레지스터는 메모리와 주고받을 값(데이터와 명령어)을 저장하는 레지스터이다. 즉, 메모리에 쓰고 싶은 값이나 메모리로부터 전달받은 값은 메모리 버퍼 레지스터를 거친다. CPU가 주소 버스로 내보낼 값이 메모리 주소 레지스터를 거친다면, 데이터 버스로 주고받을 값은 메모리 버퍼 레지스터를 거친다.

**범용 레지스터**

범용 레지스터는 다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터이다. 데이터와 주소를 모두 저장할 수 있다.

**플래그 레지스터**

플래그 레지스터는 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장하는 레지스터이다.

#### 레지스터를 이용한 주소 지정 방식

**스택 주소 지정 방식**

스택 주소 지정 방식은 데이터를 LIFO(Last In, First Out) 방식으로 처리하는 메모리 관리 방법이다. 스택 포인터라는 레지스터가 스택의 최상위 주소를 가리키며, 데이터는 스택에 푸시(push)되거나 팝(pop)되면서 관리된다.

**변위 주소 지정 방식**

변위 주소 지정 방식은 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식이다. 변위 주소 지정 방식을 사용하는 명령어는 연산 코드 필드, 어떤 레지스터의 값과 더할지를 나타내는 레지스터 필드, 그리고 주소를 담고 있는 오퍼랜드 필드가 있다. 이 때, 어떤 레지스터를 더하는지에 따라 상대 주소 지정 방식, 베이스 레지스터 주소 지정 방식 등으로 나뉜다.

- 상대 주소 지정 방식

  오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식이다.

- 베이스 레지스터 주소 지정 방식

  오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식이다. 여기서 베이스 레지스터는 기준 주소, 오퍼랜드는 기준 주소로부터 떨어진 거리로서의 역할을 한다.

### 명령어 사이클과 인터럽트

#### 명령어 사이클

프로그램 속 각각의 명령어들은 일정한 주기가 반복되며 실행되는데, 이 주기를 명령어 사이클이라고 한다.

![](https://csnote.net/assets/img/arch/instructioncycle.png)

**인출 사이클**

명령어를 메모리에서 CPU로 가지고 오는 단계

**실행 사이클**

제어장치가 명령어 레지스터에 담긴 값을 해석하고, 제어 신호를 발생시키는 단계

**간접 사이클**

피연산자의 실제 주소를 찾기 위해 메모리 내의 데이터를 한 번 더 인출하는 과정

**인터럽트 사이클**

CPU가 수행 중인 작업을 일시 중단하고, 긴급하게 처리해야 할 작업을 먼저 수행하도록 하는 메커니즘

#### 인터럽트

**동기 인터럽트**

CPU에 의해 발생하는 인터럽트, CPU가 실행하는 프로그래밍상의 오류와 같은 예외적인 상황에 마주쳤을 때 발생하는 인터럽트. 이런 점에서 동기 인터럽트는 예외라고 부른다.

**비동기 인터럽트 (하드웨어 인터럽트)**

주로 입출력장치에 의해 발생하는 인터럽트. CPU가 프린터 출력을 명령한 상황에서 하드웨어 인터럽트를 사용하지 않는다면 CPU는 프린터가 언제 프린트를 끝낼지 모르기 때문에 주기적으로 프린터의 완료 여부를 확인해야 한다.

1. 입출력장치는 CPU에 인터럽트 요청 신호를 보낸다.
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다.
3. CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인한다.
   - 모든 하드웨어 인터럽트를 인터럽트 플래그로 막을 수 있는 것은 아니다.
4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업한다.
5. CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행한다.
   - 인터럽트 서비스 루틴은 인터럽트를 처리하기 위한 프로그램이다. CPU가 인터럽트를 처리한다는 말은 인터럽트 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 되돌아온다라는 말과 같다.
   - 인터럽트 벡터는 인터럽트 서비스 루틴을 식별하기 위한 정보이다. CPU는 하드웨어 인터럽트 요청을 보낸 대상으로부터 데이터 버스를 통해 인터럽트 벡터를 전달받는다.
6. 인터럽트 서비스 루틴 실행이 끝나면 4에서 백업해 둔 작업을 복구하여 실행을 재개한다.
   - CPU는 인터럽트 서비스 루틴을 실행하기 전에 프로그램 카운터 값 등 현재 프로그램을 재개하기 위해 필요한 모든 내용을 스택에 백업한다.

![](https://csnote.net/assets/img/arch/interrupt.png)

## CPU 성능 향상 기법

### 설계 기법

#### 클럭

클럭 속도가 높은 CPU는 일반적으로 성능이 좋다. 클럭 속도는 헤르츠(Hz) 단위로 측정된다. 이는 1초에 클럭이 몇 번 반복되는지를 나타낸다.

#### 코어와 멀티코어

코어는 CPU 내에서 명령어를 실행할 수 있는 하드웨어 부품이다. 코어를 여러 개 포함하고 있는 CPU를 멀티코어 CPU 또는 멀티코어 프로세서라고 부른다.

CPU의 연산 속도가 꼭 코어 수에 비례하여 증가하지는 않는다. 코어마다 처리할 연산이 적절히 분배되지 않거나 처리하고자 하는 작업량보다 코어 수가 지나치게 많을 때 성능에 큰 영향을 주지 못할 수 있다.

#### 스레드와 멀티스레드

스레드에는 CPU에서 사용되는 하드웨어적 스레드가 있고, 프로그램에서 사용되는 소프트웨어적 스레드가 있다.

**하드웨어적 스레드**

하나의 코어가 동시에 처리하는 명령어 단위를 의미한다. 하나의 코어로 여러 명령어를 동시에 처리하는 CPU를 멀티스레드 프로세서 또는 멀티스레드 CPU라고 한다.

하나의 코어로 여러 명령어를 동시에 처리하도록 만들려면 프로그램 카운터, 스택 포인터, 메모리 버퍼 레지스터, 메모리 주소 레지스터와 같이 하나의 명령어를 처리하기 위해 꼭 필요한 레지스터를 여러 개 가지고 있어야 한다. 프로그램 입장에서 봤을 땐 하드웨어 스레드는 명령어를 처리하는 CPU나 다름없기 때문에 논리 프로세서라고 부르기도 한다.

**소프트웨어적 스레드**

하나의 프로그램에서 독립적으로 실행되는 단위를 의미한다. 하나의 프로그램은 실행되는 과정에서 한 부분만 실행될 수도 있지만, 프로그램의 여러 부분이 동시에 실행될 수도 있다.

한 번에 하나씩 명령어를 처리하는 1코어 1스레드 CPU도 소프트웨어적 스레드를 수십 개 실행할 수 있다.

### 명령어 병렬 처리 기법

#### 명령어 파이프라인

명령어 처리 과정을 클럭 단위로 나누어 보면 일반적으로 아래와 같이 나눌 수 있다.

1. 명령어 인출
2. 명령어 해석
3. 명령어 실행
4. 명령어 저장

명령어 파이프라이닝이란 명령어 처리의 각 단계를 겹쳐서 실행함으로써 CPU의 효율성을 높이는 기법이다. 예를 들어 CPU는 한 명령어를 인출하는 동안에 다른 명령어를 실행할 수 있고, 한 명령어가 실행되는 동안에 연산 결과를 저장할 수 있다.

![](https://csnote.net/assets/img/arch/pipeline.png)

**파이프라인 위험**

파이프라이닝이 높은 성능을 가져오기는 하지만, 특정 상황에서는 성능 향상에 실패하는 경우도 있다. 이러한 상황을 파이프라인 위험이라고 한다.

- 데이터 위험

  데이터 위험은 명령어 간 데이터 의존성에 의해 발생한다. 데이터 의존적인 두 명령어를 무작정 동시에 실행하려고 하면 파이프라인이 제대로 작동하지 않는 것을 말한다.

- 제어 위험

  제어 위험은 주로 분기 등으로 인한 프로그램 카운터의 갑작스러운 변화에 의해 발생한다. 기본적으로 프로그램 카운터는 현재 실행 중인 명령어의 다음 주소로 갱신된다. 하지만 프로그램 실행 흐름이 바뀌어 명령어가 실행되면서 프로그램 카운터 값에 갑작스러운 변화가 생긴다면 명령어 파이프라인에 미리 가지고 와서 처리 중이었던 명령어들은 쓸모가 없어지게 된다.

- 구조적 위험

  구조적 위험은 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려고 할 때 발생한다.

#### 슈퍼스칼라

CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조를 슈퍼스칼라라고 한다.

슈퍼스칼라 프로세서는 매 클럭 주기마다 동시에 여러 명령어를 인출할 수도, 실행할 수도 있어야 한다. 가령 멀티스레드 프로세서는 한 번에 여러 명령어를 인출하고, 해석하고, 실행할 수 있기 때문에 슈퍼스칼라 구조를 사용할 수 있다.

#### 비순차적 명령어 처리

비순차적 명령어 처리(Out-of-Order Execution)는 명령어를 순차적으로만 실행하지 않고 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 명령어 파이프라인이 멈추는 것을 방지하는 기법이다. 데이터 의존성 때문에 발생하는 병목 현상을 줄여 CPU의 자원을 최대한 활용할 수 있게 해준다.

### CISC와 RISC

#### 명령어 집합

CPU가 이해할 수 있는 명령어들의 모음을 명령어 집합(Instruction Set) 또는 명령어 집합 구조(ISA, Instruction Set Architecture) 라고 한다. ISA가 다르면 CPU가 이해할 수 있는 명령어도 어셈블리어도 달라진다. ISA의 설계 방식에 따라 CPU의 성능과 효율성이 크게 달라진다.

#### CISC

CISC(Complex Instruction Set Computer)는 다양하고 강력한 기능의 명령어 집합을 활용하기 때문에 명령어의 형태와 크기가 다양한 가변 길이 명령어를 활용한다. 다양하고 강력한 명령어를 활용하기 때문에 상대적으로 적은 수의 명령어로도 프로그램을 실행할 수 있다. 즉 메모리 공간을 절약할 수 있다.

활용하는 명령어가 복잡하고 다양한 기능을 제공하는 탓에 명령어의 크기와 실행되기까지의 시간이 일정하지 않고, 명령어 하나를 실행하는 데에 여러 클럭 주기를 필요로 하기 때문에 파이프라인이 효율적으로 명령어를 처리할 수 없다는 단점이 있다. 또 대다수의 복잡한 명령어는 사용 빈도가 낮다.

#### RISC

RISC(Reduced Instruction Set Computer)는 CISC와 달리 짧고 규격화된 명령어, 되도록 1클럭 내외로 실행되는 명령어를 지향한다. 즉 RISC는 고정 길이 명령어를 활용한다.

명령어가 규격화되어 있고, 하나의 명령어가 1클럭 내외로 실행되기 때문에 RISC 명령어 집합은 명령어 파이프라이닝에 최적화되어 있다. RISC는 메모리에 직접 접근하는 명령어를 load, store 두 개로 제한할 만큼 메모리 접근을 단순화하고 최소화를 추구한다. 대신 레지스터를 적극적으로 활용한다. 그렇기에 CISC보다 레지스터를 이용하는 연산이 많고, 일반적인 경우보다 범용 레지스터 개수도 더 많다. 다만 사용 가능한 명령어 개수가 CISC보다 적기 때문에 많은 명령으로 프로그램을 작동시킨다.

|                 CISC                 |                 RISC                 |
| :----------------------------------: | :----------------------------------: |
|        복잡하고 다양한 명령어        |         단순하고 적은 명령어         |
|           가변 길이 명령어           |           고정 길이 명령어           |
|        다양한 주소 지정 방식         |         적은 주소 지정 방식          |
| 프로그램을 이루는 명령어의 수가 적음 | 프로그램을 이루는 명령어의 수가 많음 |
|     여러 클럭에 거쳐 명령어 수행     |       1클럭 내외로 명령어 수행       |
|       파이프라이닝하기 어려움        |        파이프라이닝하기 쉬움         |

---

**참조**

https://www.hanbit.co.kr/store/books/look.php?p_code=B9177037040&utm_source=hongong

https://csnote.net
