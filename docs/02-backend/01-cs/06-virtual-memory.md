---
title: 가상 메모리
tags: [BackEnd, CS, OS, Memory, VirtualMemory]
sidebar_position: 6
---

# 가상 메모리

## 연속 메모리 할당

프로세스에 연속적인 메모리 공간을 할당하는 방식을 연속 메모리 할당 방식이라고 한다.

### 스와핑

스와핑은 프로세스들을 임시로 보조기억장치 일부 영역으로 쫓아내고, 그렇게 해서 생긴 메모리상의 빈 공간에 또 다른 프로세스를 적재하여 실행하는 방식이다. 스와핑을 이용하면 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시에 실행할 수 있다.

- 스왑 영역 : 사용되지 않아 스왑 아웃되는 프로세스들이 저장되는 보조기억장치의 일부 영역
- 스왑 아웃 : 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것
- 스왑 인 : 스왑 영역에 있던 프로세스가 다시 메모리로 옮겨오는 것

![](https://csnote.net/assets/img/os/swapping.png)

### 연속 메모리 할당 방식

#### 최초 적합 (First Fit)

운영체제가 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식이다. 검색을 최소화하여 빠른 할당이 가능하지만 메모리 단편화가 발생할 가능성이 높다.

#### 최적 적합 (Best Fit)

운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치하는 방식이다. 메모리 공간의 낭비를 줄일 수 있지만, 빈 공간을 찾기 위한 탐색 시간이 오래 걸릴 수 있다.

#### 최악 적합 (Worst Fit)

운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치하는 방식이다.

### 외부 단편화 (External Fragmentation)

프로세스들이 메모리에 연속적으로 할당되는 환경에서는 프로세스들이 실행되고 종료되기를 반복하며 메모리 사이에 빈 공간들이 생긴다. 프로세스 외부에 생긴 프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상을 외부 단편화라고 한다.

![](https://csnote.net/assets/img/os/external_fragmentation.png)

## 페이징을 통한 가상 메모리 관리

### 가상 메모리 (Virtual Memory)

프로세스를 메모리에 연속적으로 할당하는 방식은 외부 단편화 문제와 물리 메모리보다 큰 프로세스를 실행할 수 없다는 문제를 내포하고 있다. 가상 메모리는 실행하고자 하는 프로그램을 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술이다.

![](https://csnote.net/assets/img/os/virtual_memory.png)

### 페이징 (Paging)

연속 메모리 할당 방식에서 외부 단편화가 생긴 근본적인 이유는 각기 다른 크기의 프로세스가 메모리에 연속적으로 할당되었기 때문이다. 페이징은 프로세스의 논리 주소 공간을 페이지라는 일정한 단위로 자르고, 메모리 물리 주소 공간을 프레임이라는 페이지와 동일한 크기의 일정한 단위로 자른 뒤 페이지를 프레임에 할당하는 가상 메모리 관리 기법이다.

![](https://csnote.net/assets/img/os/paging.png)

페이징을 사용하는 시스템에서는 프로세스 전체가 스왑 아웃 / 스왑 인되는 것이 아닌 페이지 단위로 스왑 아웃/ 스왑인을 실행한다. 즉, 프로세스를 실행하기 위해 프로세스 전체가 메모리에 적재될 필요없이 프로세스를 이루는 페이지 중 실행에 필요한 일부 페이지만을 메모리에 적재하고, 당장 실행에 필요하지 않은 페이지들은 보조기억장치에 남겨둘 수 있다. 이와 같은 방식을 통해 물리 메모리보다 더 큰 프로세스를 실행할 수 있다.

#### 쓰기 시 복사 (Copy On Write)

쓰기 시 복사에서는 부모 프로세스와 동일한 자식 프로세스가 생성되면 자식 프로세스로 하여금 부모 프로세스와 동일한 프레임을 가리키게 함으로써 부모 프로세스의 메모리 공간을 복사하지 않고도 동일한 코드 및 데이터 영역을 가리킬 수 있다. 만일 부모 프로세스와 자식 프로세스가 메모리에 어떠한 데이터도 쓰지 않고 읽기 작업만 이어 나가면 이 상태가 지속된다. 부모 프로세스 혹은 자식 프로세스 둘 중 하나가 페이지에 쓰기 작업을 하면 그 순간 해당 페이지가 별도의 공간으로 복제되고 각 프로세스는 자신의 고유한 페이지가 할당된 프레임을 가리키게 된다. 이러한 방식을 쓰기 시 복사라고 한다. 쓰기 시 복사를 통해 프로세스 생성 시간을 줄이고 메모리 공간을 절약할 수 있다.

### 페이지 테이블 (Page Table)

프로세스가 메모리에 불연속적으로 배치되어 있다면 CPU 입장에서 이를 순차적으로 실행할 수 없기 때문에 이를 해결하기 위해 페이징 시스템은 프로세스가 비록 (실제 메모리 내의 주소인) 물리 주소에 불연속적으로 배치되더라도 (CPU가 바라보는 주소인) 논리 주소에는 연속적으로 배치되도록 페이지 테이블을 이용한다. 즉, 페이지 테이블이란 현재 어떤 페이지가 어떤 프레임에 할당되었는지 알기 위해 페이지 번호와 프레임 번호를 짝지어 주는 표 형태의 정보이다.

![](https://csnote.net/assets/img/os/page_table.png)

#### 내부 단편화 (Internal Fragmentation)

페이징은 외부 단편화 문제를 해결할 수 있지만 내부 단편화 문제를 야기할 수 있다. 내부 단편화는 모든 프로세스가 페이지 크기에 딱 맞게 잘리지 않아 발생하는 메모리의 낭비 현상이다. 내부 단편화는 하나의 페이지 크기보다 작은 크기로 발생한다. 하지만 하나의 페이지 크기를 너무 작게 설정하면 그만큼 페이지 테이블의 크기도 커지기 때문에 페이지 테이블이 차지하는 공간이 낭비된다. 그렇기에 내부 단편화를 적당히 방지하면서 너무 크지 않은 페이지 테이블이 만들어지도록 페이지의 크기를 조정하는 것이 중요하다.

#### 페이지 테이블 베이스 레지스터 (PTBR, Page Table Base Register)

프로세스마다 각자의 프로세스 테이블을 가지고 있고 각 프로세스의 페이지 테이블들은 메모리에 적재되어 있다. 그리고 CPU 내의 PTBR은 각 프로세스의 페이지 테이블이 적재된 주소를 가지고 있다. 예를 들어 프로세스 A가 실행될 때 PTBR은 프로세스 A의 페이지 테이블을 가리키고, CPU는 프로세스 A의 페이지 테이블을 통해 프로세스 A의 페이지가 적재된 프레임을 알 수 있다. 각 프로세스들의 페이지 테이블 정보는 PCB에 기록되고, 프로세스의 컨텍스트 스위칭이 일어날 때 다른 레지스터와 함께 변경된다.

#### TLB (Translation Lookaside Buffer)

페이지 테이블을 메모리에 두게 되면 메모리 접근 시간이 두 배로 늘어난다. 메모리에 있는 페이지 테이블을 보기 위해 한 번, 프레임에 접근하기 위해 한 번, 총 두 번의 메모리 접근이 필요하기 때문이다. 이와 같은 문제를 해결하기 위해 CPU 곁에 (일반적으로 MMU 내에) TLB라는 페이지 테이블의 캐시 메모리를 둔다. TLB는 페이지 테이블의 일부 내용을 참조 지역성에 근거해 저장한다.

![](https://csnote.net/assets/img/os/tlb.png)

#### 페이징 주소 변환

하나의 페이지 혹은 프레임은 여러 주소를 포괄하고 있다. 때문에 특정 주소에 접근하려면 두 가지 정보가 필요하다.

1. 접근하려는 페이지 혹은 프레임
2. 접근하려는 주소가 해당 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지

페이징 시스템에서는 모든 논리 주소가 기본적으로 페이지 번호와 변위(offset)로 이루어져 있다. 변위는 접근하려는 주소가 프레임의 시작 번지로부터 얼만큼 떨어져 있는지를 알기 위한 정보이다. 즉, 논리 주소 <페이지 번호, 변위>는 페이지 테이블을 통해 물리 주소 <프레임 번호, 변위>로 변환된다.

### 페이지 테이블 엔트리 (PTE, Page Table Entry)

페이지 테이블의 각각의 행들을 페이지 테이블 엔트리라고 한다. 페이지 테이블 엔트리에는 페이지 번호와 프레임 번호 뿐만 아니라 유효 비트, 보호 비트, 참조 비트, 수정 비트와 같은 정보들이 담겨있다.

#### 유효 비트

현재 해당 페이지에 접근 가능한지 여부를 나타내는 비트이다. 현재 페이지가 메모리에 적재되어 있는지 아니면 보조기억장치에 있는지를 알려준다.

**페이지 폴트 (Page Fault)**

만일 CPU가 유효비트가 0인 메모리에 적재되어 있지 않은 페이지로 접근하려고 할 때 페이지 폴트라는 예외가 발생한다. CPU가 페이지 폴트를 처리하는 과정은 하드웨어 인터럽트를 처리하는 과정과 유사하다.

1. CPU는 기존의 작업을 백업한다.
2. 페이지 폴트 처리 루틴을 실행한다.
3. 페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트를 1로 변경해 준다.
4. 페이지 폴트를 처리했다면 CPU는 해당 페이지에 접근할 수 있게 된다.

#### 보호 비트

페이지 보호 기능을 위해 존재하는 비트로, 해당 페이지가 읽고 쓰기가 모두 가능한 페이지인지, 혹은 읽기만 가능한 페이지인지를 나타내는 비트이다. 프로세스의 코드 영역과 같이 읽기 전용 영역을 보호해준다.

#### 참조 비트

CPU가 이 페이지에 접근한 적이 있는지 여부를 나타내는 비트이다.

#### 수정 비트

해당 페이지에 데이터를 쓴 적이 있는지 없는지 수정 여부를 나타내는 비트로 더티 비트(dirty bit)라고도 부른다. 수정 비트는 페이지가 메모리에서 사라질 때 보조기억장치에 쓰기 작업을 해야 하는지, 할 필요가 없는지를 판단하기 위해 존재한다.

## 페이지 교체와 프레임 할당

### 요구 페이징 (Demand Paging)

프로세스를 메모리에 적재할 때 처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법이다.

1. CPU가 특정 페이지에 접근하는 명령어를 실행한다.
2. 해당 페이지가 현재 메모리에 있을 경우 (유효 비트가 1인 경우) CPU는 페이지가 적재된 프레임에 접근한다.
3. 해당 페이지가 현재 메모리에 없을 경우 (유효 비트가 0인 경우) 페이지 폴트가 발생한다.
4. 페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효 비트를 1로 설정한다.
5. 다시 1번을 실행한다.

#### 순수 요구 페이징 (Pure Demand Paging)

아무런 페이지도 메모리에 적재하지 않은 상태에서 프로세스를 실행하는 방식이다. 프로세스의 첫 명령어를 실행하는 순간부터 페이지 폴트가 계속 발생하게 되고, 실행에 필요한 페이지가 어느 정도 적재된 이후부터는 페이지 폴트 발생 빈도가 떨어진다.

### 페이지 교체 알고리즘

요구 페이징 기법으로 페이지들을 적재하다 보면 언젠가 메모리가 가득 차게 된다. 당장 실행에 필요한 페이지를 적재하기 위해 메모리에 적재된 페이지를 보조기억장치로 내보내야 할 때, 어떤 페이지를 내보낼지 결정하는 알고리즘이다. 페이지 폴트를 가장 적게 일으키는 알고리즘을 좋은 알고리즘으로 평가한다.

#### FIFO 페이지 교체 알고리즘 (First-In First-Out Page Replacement Algorithm)

메모리에 가장 먼저 올라온 페이지부터 내쫓는, 적재된 페이지 순서대로 교체하는 페이지 교체 알고리즘이다.

#### 최적 페이지 교체 알고리즘 (Optimal Page Replacement Algorithm)

앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 페이지 교체 알고리즘이다. 프로세스가 앞으로 메모리 어느 부분을 어떻게 참조할지 가늠하기 어렵기 때문에 그 자체를 운영체제에서 사용하기보다는, 주로 다른 페이지 교체 알고리즘의 이론상 성능을 평가하기 위한 목적으로 사용된다. 즉, 최적 페이지 교체 알고리즘을 실행했을 때 발생하는 페이지 폴트 횟수를 페이지 폴트의 하한선으로 간주하고, 최적 페이지 교체 알고리즘에 비해 얼만큼 페이지 폴트 횟수가 발생하느냐를 통해 페이지 교체 알고리즘을 평가하기 위해 사용한다.

#### LRU 페이지 교체 알고리즘 (LRU, Least Recently Used Page Algorithm)

가장 오랫동안 사용되지 않은 페이지를 교체하는 페이지 교체 알고리즘이다.

### 프레임 할당

#### 스레싱 (Thrashing)

프레임이 부족하면 CPU는 페이지 폴트가 자주 발생할 수밖에 없다. 프로세스가 실제 실행되는 시간보다 페이징에 더 많은 시간을 소요하여 성능이 저해되는 문제를 스래싱이라고 한다.

동시에 실행되는 프로세스 수가 어느 정도 증가하면 CPU 이용률이 높아지지만, 필요 이상으로 늘리면 각 프로세스들이 사용할 수 있는 프레임 수가 적어지기 때문에 페이지 폴트가 지나치게 빈번히 발생하고, 이에 따라 CPU 이용율이 떨어져 전체적인 성능이 저해된다.

#### 프레임 할당 방식

**정적 할당 방식**

프로세스의 실행 과정을 고려하지 않고 단순히 프로세스의 크기와 물리 메모리의 크기만을 고려하여 프레임을 할당하는 방식이다.

- 균등 할당 : 모든 프로세스에 균등하게 프레임을 할당하는 방식
- 비례 할당 : 프로세스의 크기에 따라 프레임을 배분하는 방식

**동적 할당 방식**

프로세스의 실행 과정을 고려하여 프레임 수를 결정하는 방식이다.

- 작업 집합 모델 기반 할당 : 작업 집합(프로세스가 실행 중에 일정 시간 동안 참조한 페이지의 집합)의 크기만큼만 프레임을 할당하는 방식
- 페이지 폴트 빈도 기반 할당 : 페이지 폴트율에 상한선과 하한선을 정하고, 그 내부 범위 안에서만 프레임을 할당하는 방식

---

**참조**

https://www.hanbit.co.kr/store/books/look.php?p_code=B9177037040&utm_source=hongong

https://csnote.net
