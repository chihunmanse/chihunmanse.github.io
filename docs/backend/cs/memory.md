---
title: 메모리, 보조기억장치, 입출력장치
tags: [BackEnd, CS, Memory]
sidebar_position: 2
---

# 메모리, 보조기억장치, 입출력장치

## RAM

RAM(Random Access Memory)은 휘발성 메모리로, 전원이 꺼지면 저장된 데이터가 모두 사라진다. RAM에는 실행할 프로그램의 명령어와 데이터가 저장된다.

RAM 용량이 적다면 보조기억장치에서 실행할 프로그램을 가져오는 일이 잦아 실행 시간이 길어진다. RAM 용량이 크면 많은 프로그램들을 동시에 빠르게 실행하는데 유리하다.

### RAM의 종류

RAM에는 여러 종류가 있으며, 서버 환경에서는 주로 다음과 같은 종류가 사용된다.

| 종류          | 특징                                                                                                                                                                                                              | 용도                        |
| ------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------- |
| **DRAM**      | 동적(Dynamic) RAM<br />시간이 지나면 저장된 데이터가 사라지기 때문에 일정 주기로 재활성화 필요<br />집적도가 높기 때문에 대용량으로 설계하기 용이함                                                               | 메모리                      |
| **SRAM**      | 정적(Static) RAM<br />저장된 데이터가 변하지 않기 때문에 재활성화 불필요<br />빠르지만 비쌈                                                                                                                       | 캐시 메모리                 |
| **SDRAM**     | Synchronous DRAM<br />클럭 신호와 동기화된 형태의 DRAM                                                                                                                                                            |                             |
| **DDR SDRAM** | Double Data Rate SDRAM<br />대역폭을 넓혀 속도를 빠르게 만든 SDRAM<br />한 클럭에 한 번씩 CPU와 데이터를 주고받을 수 있는 SDRAM에 비해 DDR SDRAM은 두 배의 대역폭으로 한 클럭당 두 번씩 데이터를 주고받을 수 있음 | 최근 가장 흔히 사용되는 RAM |

## 메모리의 주소 공간

### 물리 주소와 논리 주소

메모리 주소는 프로세스가 메모리 공간에 접근하는 방식을 결정한다. **물리 주소**는 메모리 하드웨어가 사용하는 주소이고, **논리 주소**는 CPU와 실행 중인 프로그램에서 사용되는 가상의 주소를 의미한다. 운영 체제는 논리 주소를 물리 주소로 변환하여 메모리 보호와 효율성을 높인다.

![](https://csnote.net/assets/img/os/logical_address.png)

논리 주소와 물리 주소 간의 변환은 CPU와 주소 버스 사이에 위치한 메모리 관리 장치(MMU, Memory Management Unit)라는 하드웨어에 의해 수행된다.

![](https://csnote.net/assets/img/os/mmu.png)

**MMU**는 CPU가 발생시킨 논리 주소에 베이스 레지스터 값을 더하여 논리 주소를 물리 주소로 변환한다. 예를 들어 현재 베이스 레지스터에 15000이 저장되어 있고 CPU가 발생시킨 논리 주소가 100번지라면 이 논리 주소는 물리 주소 15100번지(100+15000)로 변환된다.

즉, **베이스 레지스터**는 프로그램의 가장 작은 물리 주소(프로그램의 첫 물리 주소)를 저장하고 논리 주소는 프로그램의 시작점으로부터 떨어진 거리이다.

### 메모리 보호 기법

다른 프로그램의 영역을 침범할 수 있는 명령어는 위험하기 때문에 논리 주소 범위를 벗어나는 명령어 실행을 방지하고 실행 중인 프로그램이 다른 프로그램에 영향을 받지 않도록 보호할 방법이 필요하다.

베이스 레지스터가 실행 중인 프로그램의 가장 작은 물리 주소를 저장한다면, **한계 레지스터**는 논리 주소의 최대 크기를 저장한다. 즉 프로그램의 물리 주소 범위는 베이스 레지스터 값 이상, 베이스 레지스터 값 + 한계 레지스터 값 미만이 된다.

CPU는 메모리에 접근하기 전에 접근하고자 하는 논리 주소가 한계 레지스터보다 작은지를 항상 검사한다. 만약 CPU가 한계 레지스터보다 높은 논리 주소에 접근하려고 하면 인터럽트(트랩)를 발생시켜 실행을 중단한다.

## 캐시 메모리

### 저장 장치 계층 구조

컴퓨터가 사용하는 저장 장치들은 CPU에 얼마나 가까운가를 기준으로 계층적으로 나타낼 수 있다. 속도가 빠른 장치일수록 용량은 작고, 가격은 비싸다.

| 장치           | 예시                | 속도      | 용량      |
| -------------- | ------------------- | --------- | --------- |
| CPU 레지스터   | CPU 내부의 레지스터 | 매우 빠름 | 매우 작음 |
| 캐시 메모리    | L1, L2, L3 캐시     | 매우 빠름 | 작음      |
| 메모리 (RAM)   | DRAM, SDRAM         | 빠름      | 중간      |
| 보조 기억 장치 | SSD, HDD            | 느림      | 큼        |

![](https://csnote.net/assets/img/arch/memoryhierarchy.png)

### 캐시 메모리

캐시 메모리는 CPU와 메모리 사이에 위치하고, 레지스터보다 용량이 크고 메모리보다 빠른 SRAM 기반의 저장 장치이다. CPU의 연산 속도와 메모리 접근 속도의 차이를 줄이기 위해 탄생했다. 자주 사용되는 데이터를 일시적으로 저장해 CPU가 더 빠르게 데이터에 접근할 수 있게 한다.

CPU(코어)와 가까운 순서대로 계층 (L1 -> L2 -> L3)을 구성한다. 일반적으로 L1 캐시와 L2 캐시는 코어 내부에, L3 캐시는 코어 외부에 위치한다. 멀티 코어 프로세서에서 L1 캐시와 L2 캐시는 코어마다 고유한 캐시 메모리가 할당되고, L3 캐시는 여러 코어가 공유하는 형태로 사용된다.

### 참조 지역성 원리

참조 지역성(Locality of Reference)은 프로그램이 메모리에 접근할 때, 특정 메모리 영역을 집중적으로 사용한다는 이론이다. 이는 시간적 지역성(Temporal Locality)과 공간적 지역성(Spatial Locality)으로 나뉜다. 캐시 메모리는 CPU가 사용할 법한 대상을 참조 지역성 원리에 따라 예측하여 저장한다.

- 시간적 지역성 : 최근에 접근한 데이터는 다시 접근할 가능성이 높다.
- 공간적 지역성 : 접근한 데이터 근처의 데이터는 접근할 가능성이 높다.

---

## 보조기억장치

### 하드 디스크

하드 디스크는 자기적인 방식으로 데이터를 저장하는 보조기억장치이다.

- 플래터

  플래터는 하드디스크 내부에 있는 원형의 디스크로, 데이터를 실제로 저장하는 물리적인 매체이다. 일반적으로 한 하드디스크에는 여러 개의 플래터가 쌓여 있으며, 각 플래터의 양 면이 데이터 저장에 사용된다.

- 스핀들

  스핀들은 플래터들을 중앙에서 고정시키고 고속으로 회전시키는 축이다. 스핀들 모터는 플래터를 분당 수천에서 수만 회 회전시켜, 데이터 읽기와 쓰기 작업을 빠르게 수행할 수 있 게 한다. 하드디스크의 성능은 스핀들의 회전 속도(RPM)와 밀접한 관련이 있다.

- 헤드

  헤드는 플래터의 표면에 데이터를 읽고 쓰는 장치이다. 각각의 플래터 면마다 하나의 헤드가 있으며, 이 헤드는 공중에 떠 있는 상태로 플래터의 자성 표면에서 데이터를 읽거나 데이 터를 기록한다.

- 디스크암

  디스크암은 헤드를 원하는 위치로 이동시키는 역할을 한다.

- 트랙

  트랙은 플래터의 표면에 데이터를 저장하는 원형의 경로로, 플래터를 동심원 모양으로 나누어 놓은 것이다. 각 플래터 면에는 수천 개의 트랙이 존재하며, 트랙은 다시 여러 개의 섹 터로 나뉜다. 트랙의 위치에 따라 데이터를 읽고 쓰는 시간이 달라질 수 있는데, 일반적으로 플래터의 바깥쪽 트랙이 안쪽 트랙보다 더 많은 데이터를 저장할 수 있으며 접근 속도도 빠르다.

- 섹터

  섹터는 트랙을 더 작은 데이터 저장 단위로 나눈 것으로, 하드디스크의 기본적인 데이터 저장 블록이다. 일반적으로 하나의 섹터는 512바이트 또는 4KB의 데이터를 저장한다.

### 플래시 메모리

플래시 메모리는 전기적으로 데이터를 읽고 쓸 수 있는 반도체 기반의 저장 장치이다.

#### 플래시 메모리 단위

- 셀

  셀은 데이터를 저장하는 가장 작은 단위로, 하나의 셀은 전하의 축적 여부에 따라 논리적 '0'과 '1'을 표현한다. 셀 내부의 전하량에 따라 비트 정보를 저장하는 방식이 달라지며, 셀은 여러 비트를 저장할 수 있다.

- 페이지

  페이지는 여러 개의 셀로 구성된 데이터 저장 단위로, 플래시 메모리에서 데이터를 읽고 쓰는 기본 단위이다. 페이지 크기는 일반적으로 4KB에서 16KB 사이이다. 데이터를 쓸 때는 페이지 단위로 쓰고, 읽을 때도 페이지 단위로 읽어오게 된다.

- 블록

  블록은 여러 페이지가 모여 구성된 더 큰 단위이다. 플래시 메모리에서 데이터를 지울 때는 블록 단위로만 지울 수 있다. 블록의 크기는 수십에서 수백 페이지까지 다양하다. 즉, 데이터를 지우는 동작은 블록 단위로 수행되며, 이 때문에 가비지 컬렉션과 같은 관리 기법이 필요하다.

#### 플래시 메모리 타입

- SLC (Single-Level Cell)

  SLC는 각 셀에 1비트를 저장하는 방식이다. 셀이 가질 수 있는 상태는 두 가지(0 또는 1)뿐이기 때문에 데이터 읽기와 쓰기가 빠르고 신뢰성이 높다. SLC는 내구성이 뛰어나며, 전자 기기에서 중요한 데이터 저장 용도로 사용된다. 하지만 저장 밀도가 낮아 가격이 비싸다.

- MLC (Multi-Level Cell)

  MLC는 각 셀에 2비트를 저장하는 방식으로, 셀이 4가지 상태(00, 01, 10, 11)를 가질 수 있다. MLC는 SLC보다 저장 밀도가 높아 가격이 저렴하지만, 데이터의 정확한 판독을 위해 더 많은 시간이 필요하며, 신뢰성과 수명은 SLC보다 낮다.

- TLC (Triple-Level Cell)

  TLC는 각 셀에 3비트를 저장하는 방식으로, 셀이 8가지 상태를 가질 수 있다. 이는 저장 밀도가 더욱 높아져 가격이 더욱 저렴해지지만, 성능과 내구성은 SLC와 MLC에 비해 더 낮아진다.

#### 페이지 상태와 가비지 컬렉션

- Free

  아직 데이터가 기록되지 않은 페이지 상태.

- Valid

  데이터가 기록된 상태로, 유효한 데이터를 포함하는 페이지.

- Invalid

  데이터가 기록되었으나, 해당 데이터가 더 이상 유효하지 않은 상태(갱신된 데이터가 다른 페이지에 기록된 경우). 플래시 메모리에서 덮어쓰기는 불가능하기 때문에 데이터 갱신시, 기존에 저장된 데이터는 Invalid 상태가 되고 갱신된 새로운 데이터를 다른 페이지에 기록한다.

플래시 메모리에서 **가비지 컬렉션(Garbage Collection)**은 유효하지 않은 데이터를 포함한 블록을 정리하고, 재사용 가능한 공간을 확보하는 기능이다.

1. 유효한 데이터 복사 : 유효하지 않은 데이터가 포함된 블록에서 유효한 데이터를 다른 블록으로 복사한다.
2. 블록 지우기 : 유효하지 않은 데이터가 포함된 블록을 삭제하여 다시 쓸 수 있는 상태로 만든다.

## RAID

RAID(Redundant Array of Independent Disks)는 주로 하드 디스크와 SSD를 사용하는 기술로, 데이터의 안전성 혹은 높은 성능을 위해 여러 개의 물리적 보조기억장치를 마치 하나의 논리적 보조기억장치처럼 사용하는 기술이다.

### RAID의 종류

#### RAID 0

여러 개의 보조기억장치에 데이터를 단순히 나누어 저장하는 RAID 구성 방식이다.

![](https://csnote.net/assets/img/arch/raid0.png)

#### RAID 1

복사본을 만드는 RAID 구성 방식이다.

![](https://csnote.net/assets/img/arch/raid1.png)

#### RAID 4

RAID 1처럼 완전한 복사본을 만드는 대신 오류를 검출하고 복구하기 위한 정보(패리티)를 저장한 장치를 두는 RAID 구성 방식이다.

![](https://csnote.net/assets/img/arch/raid4.png)

#### RAID 5

패리티 정보를 분산하여 저장해 RAID 4의 병목현상 문제를 해소한 RAID 구성 방식이다.

![](https://csnote.net/assets/img/arch/raid5.png)

#### RAID 6

서로 다른 두 개의 패리티를 두는 RAID 구성 방식이다.

![](https://csnote.net/assets/img/arch/raid6.png)

| RAID 레벨  | 설명                                                                                              | 장점                   | 단점                      |
| ---------- | ------------------------------------------------------------------------------------------------- | ---------------------- | ------------------------- |
| **RAID 0** | 여러 개의 보조기억장치에 데이터를 단순히 나누어 저장하는 방식 (스트라이핑)                        | 높은 성능              | 데이터 보호 없음          |
| **RAID 1** | 복사본을 만드는 방식 (미러링)                                                                     | 높은 데이터 안전성     | 저장 공간의 비효율성      |
| **RAID 4** | 완전한 복사본을 만드는 대신 오류를 검출하고 복구하기 위한 정보를 저장한 장치를 두는 방식 (패리티) | 성능과 안정성의 균형   | 패리티 디스크의 병목 현상 |
| **RAID 5** | 패리티를 저장한 장치를 따로 두는 RAID4와 다르게 분산하여 저장하는 방식 (분산 패리티)              | RAID4의 병목 현상 해소 | 단일 장애 복구만 가능     |
| **RAID 6** | 구성은 RAID5와 같으나, 두 개의 패리티를 두는 방식                                                 | 높은 데이터 안전성     | 느린 쓰기 성능            |

---

## 장치 컨트롤러와 장치 드라이버

### 장치 컨트롤러

입출력장치는 컴퓨터에 직접 연결되지 않고 장치 컨트롤러라는 하드웨어를 통해 연결된다.

#### 장치 컨트롤러의 역할

- CPU와 입출력장치 간의 통신 중개

- 오류 검출

- 데이터 버퍼링 : 버퍼링이란 전송률이 높은 장치와 낮은 장치 사이에 주고받는 데이터를 버퍼라는 임시 저장 공간에 저장하여 전송률을 비슷하게 맞추는 방법이다.

#### 장치 컨트롤러 구조

- 데이터 레지스터

  CPU와 입출력장치 사이에 주고받을 데이터가 담기는 레지스터. 버퍼 역할을 한다.

- 상태 레지스터

  입출력장치가 입출력 작업을 할 준비가 되었는지, 입출력 작업이 완료되었는지, 오류는 없는지 등의 상태 정보가 저장된다.

- 제어 레지스터

  입출력장치가 수행할 내용에 대한 제어 정보와 명령을 저장한다.

### 장치 드라이버

장치 드라이버란 장치 컨트롤러의 동작을 감지하고 제어함으로써 장치 컨트롤러가 컴퓨터 내부와 정보를 주고받을 수 있게 하는 프로그램이다.

장치 컨트롤러가 입출력장치를 연결하기 위한 하드웨어적인 통로라면, 장치 드라이버는 입출력장치를 연결하기 위한 소프트웨어적인 통로이다.

## 입출력 방법

### 프로그램 입출력

프로그램 입출력은 기본적으로 프로그램 속 명령어로 입출력장치를 제어하는 방법이다. CPU가 장치 컨트롤러의 레지스터 값을 읽고 씀으로써 이루어진다.

#### 메모리맵 입출력

메모리맵 입출력은 입출력 장치들이 일반 메모리처럼 다루어지는 방식이다. 이 방식에서는 입출력 장치들이 특정 메모리 주소 공간에 매핑되어, CPU가 메모리에 접근하듯이 입출력 장치에 접근할 수 있다. 메모리 주소 공간의 일부가 입출력 장치에 할당되므로, 실제로 사용할 수 있는 메모리 주소 공간이 줄어든다.

#### 고립형 입출력

고립형 입출력은 메모리를 위한 주소 공간과 입출력장치를 위한 주소 공간을 분리하는 방법이다. CPU는 입출력장치에 접근하기 위해 메모리에 접근하는 명령어와는 다른 입출력 명령어를 사용한다.

### 인터럽트 기반 입출력

인터럽트 기반 입출력은 장치 컨트롤러가 입출력 작업을 끝낸 뒤 CPU에게 인터럽트 요청 신호를 보내면 CPU는 하던 일을 잠시 백업하고 인터럽트 서비스 루틴을 실행한다.

플래그 레지스터 속 인터럽트 비트가 활성화되어 있는 경우, 혹은 인터럽트 비트를 비활성화해도 무시할 수 없는 NMI(Non-Maskable Interrupt)가 발생한 경우 CPU는 우선순위가 높은 인터럽트부터 처리한다. 우선순위를 반영하여 다중 인터럽트를 처리하는 방법으로 **PIC(Programmable Interrupt Controller)**라는 하드웨어를 사용한다.

PIC는 여러 장치 컨트롤러에 연결되어 장치 컨트롤러에서 보낸 하드웨어 인터럽트 요청들의 우선순위를 판별한 뒤 CPU에 지금 처리해야 할 하드웨어 입터럽트는 무엇인지를 알려주는 장치이다. PIC가 우선순위를 조정해 주는 인터럽트는 인터럽트 비트를 통해 막을 수 있는 하드웨어 인터럽트이다.

1. PIC가 장치 컨트롤러에서 인터럽트 요청 신호(들)를 받아들인다.
2. PIC는 인터럽트 우선순위를 판단한 뒤 CPU에 처리해야 할 인터럽트 요청 신호를 보낸다.
3. CPU는 PIC에 인터럽트 확인 신호를 보낸다.
4. PIC는 데이터 버스를 통해 CPU에 인터럽트 벡터를 보낸다.
5. CPU는 인터럽트 벡터를 통해 인터럽트 요청의 주체를 알게 되고, 해당 장치의 인터럽트 서비스 루틴을 실행한다.

### DMA 입출력

DMA(Direct Memory Access)는 입출력장치와 메모리가 CPU를 거치지 않고도 상호작용할 수 있는 입출력 방식이다. DMA 입출력을 위해서는 시스템 버스에 연결된 DMA 컨트롤러라는 하드웨어가 필요하다.

1. CPU는 DMA 컨트롤러에 입출력장치의 주소, 수행할 연산(읽기/쓰기), 읽거나 쓸 메모리의 주소 등과 같은 정보로 입출력 장업을 명령한다.
2. DMA 컨트롤러는 CPU 대신 장치 컨트롤러와 상호작용하며 입출력 작업을 수행한다. 이때 DMA 컨트롤러는 필요한 경우 메모리에 직접 접근하여 정보를 읽거나 쓴다.
3. 입출력 작업이 끝나면 DMA 컨트롤러는 CPU에 인터럽트를 걸어 작업이 끝났음을 알린다.

입출력장치와 메모리 사이에 주고받을 데이터는 CPU를 거치지 않는다. CPU는 DMA 컨트롤러에게 입출력 작업 명령을 내리고, 인터럽트만 받으면 되기 때문에 작업 부담을 줄일 수 있다.

다만 DMA 컨트롤러는 시스템 버스로 메모리에 직접 접근이 가능하지만, 시스템 버스는 동시 사용이 불가능하므로 DMA 컨트롤러는 CPU가 시스템 버스를 이용하지 않을 때마다 시스템 버스를 이용하거나, CPU가 일시적으로 시스템 버스를 이용하지 않도록 허락을 구하고 집중적으로 이용한다.

#### 입출력 버스

CPU, 메모리, DMA 컨트롤러, 장치 컨트롤러가 모두 같은 버스를 공유하는 구성에서는 DMA를 위해 한 번 메모리에 접근할 때마다 시스템 버스를 두 번 사용하게 되는 (메모리 -> DMA 컨트롤러, DMA 컨트롤러 -> 장치 컨트롤러) 부작용이 있다.

DMA를 위해 시스템 버스를 자주 사용하면 그만큼 CPU가 시스템 버스를 이용하지 못하게 된다. 따라서 장치 컨트롤러들을 시스템 버스가 아닌 입출력 버스로 DMA 컨트롤러에 연결하여 DMA 컨트롤러와 장치 컨트롤러가 서로 데이터를 전송할 때는 시스템 버스를 이용하지 않게하여 사용 빈도를 줄일 수 있다.

---

**참조**

https://www.hanbit.co.kr/store/books/look.php?p_code=B9177037040&utm_source=hongong

https://csnote.net
