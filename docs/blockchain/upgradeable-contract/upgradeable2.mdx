---
sidebar_position: 2
---

# 2. ERC1967, TransparentProxy, UUPS

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

[이전 글](./upgradeable1.mdx)에 이어서 프록시 패턴에 대해 본격적으로 살펴보려고 한다.

프록시 패턴은 기본적으로 delegatecall 과 fallback 함수의 조합을 통해 구현된다.

### fallback 함수

fallback 함수란 컨트랙트에 존재하지 않는 함수가 호출되었을 경우 대신해서 호출되는 함수이다.

0.6 이전의 fallback 함수
```sol
function() external payable {}
```

0.6 이후의 fallback 함수
- fallback : 호출된 함수가 컨트랙트에 존재하지 않을때 작동하는 함수
- receive : calldata 없이 컨트랙트에 이더가 전송됐을 때 작동하는 함수

```sol
fallback() external payable {}
receive() external payable {}
```

<hr/>

오픈재플린의 ERC1967Proxy, TransparentProxy, UUPS 등 프록시 패턴을 구현한 여러 방식들은 모두 Proxy 추상 컨트랙트를 기반으로 구현되어있다.

```sol title="openzeppelin-contracts/contracts/proxy/Proxy.sol"
// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)

pragma solidity ^0.8.0;

/**
 * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM
 * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to
 * be specified by overriding the virtual {_implementation} function.
 *
 * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a
 * different contract through the {_delegate} function.
 *
 * The success and return data of the delegated call will be returned back to the caller of the proxy.
 */
abstract contract Proxy {
    /**
     * @dev Delegates the current call to `implementation`.
     *
     * This function does not return to its internal call site, it will return directly to the external caller.
     */
    function _delegate(address implementation) internal virtual {
        assembly {
            // Copy msg.data. We take full control of memory in this inline assembly
            // block because it will not return to Solidity code. We overwrite the
            // Solidity scratch pad at memory position 0.
            calldatacopy(0, 0, calldatasize())

            // Call the implementation.
            // out and outsize are 0 because we don't know the size yet.
            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)

            // Copy the returned data.
            returndatacopy(0, 0, returndatasize())

            switch result
            // delegatecall returns 0 on error.
            case 0 {
                revert(0, returndatasize())
            }
            default {
                return(0, returndatasize())
            }
        }
    }

    /**
     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function
     * and {_fallback} should delegate.
     */
    function _implementation() internal view virtual returns (address);

    /**
     * @dev Delegates the current call to the address returned by `_implementation()`.
     *
     * This function does not return to its internal call site, it will return directly to the external caller.
     */
    function _fallback() internal virtual {
        _beforeFallback();
        _delegate(_implementation());
    }

    /**
     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other
     * function in the contract matches the call data.
     */
    fallback() external payable virtual {
        _fallback();
    }

    /**
     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data
     * is empty.
     */
    receive() external payable virtual {
        _fallback();
    }

    /**
     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`
     * call, or as part of the Solidity `fallback` or `receive` functions.
     *
     * If overridden should call `super._beforeFallback()`.
     */
    function _beforeFallback() internal virtual {}
}
```

Proxy 컨트랙트의 코드를 살펴보면, `_delegate`라는 인라인 어셈블리로 적힌 내부 함수가 있고, 이 함수를 fallback 함수와 receive 함수에서 호출하고 있는 것을 볼 수 있다. 현재 이 컨트랙트에서는 외부에서 호출할 수 있는 함수를 따로 만들어두지 않았기 때문에, 외부에서 어떤 calldata를 갖고 호출하더라도 실행되는 것은 fallback 함수, 즉 `_beforeFallback`과 `_delegate` 두 함수가 실행될 것이다.

`_delegate` 함수에는 트랜잭션에 담긴 calldata를 통하여 `_implementation`(구현 컨트랙트 주소)에 delegatecall을 하고, 성공했다면 return 데이터를 반환하고 실패했다면 revert 시키는 로직이 담겨있다.

이와 같이 delegatecall과 fallback 함수의 조합을 통하여, 이전 글에서처럼 프록시 컨트랙트 쪽에 함수를 정의할 필요 없이, 구현 컨트랙트 쪽에 있는 함수들을 유동적으로 호출하는 방식이 가능해진다. 이 방식을 적용하면 구현 컨트랙트를 업그레이드하는 경우에 함수명과 인자, return 되는 데이터까지 프록시 컨트랙트에 얽매이지 않고 수정할 수 있게 된다.

## ERC1967
하지만 이전 글에서 살펴보았듯이, delegatecall을 사용할 때 스토리지충돌이 발생할 수 있다는 문제는 여전히 해결되지 않은 채로 남아있다.

특히 프록시 컨트랙트는 구현 컨트랙트에 담긴 로직을 호출하기 위해 구현 컨트랙트의 주소값이 꼭 필요한데, 이 주소값이 담긴 변수가 충돌하여 예상치 못한 값으로 변경된다면 프록시 컨트랙트가 제대로 동작하지 못하게 되는 심각한 문제로 이어진다.

이 문제를 해결하기 위해 오픈재플린에는 [ERC1967](https://eips.ethereum.org/EIPS/eip-1967)을 기반으로한 ERC1967이 구현되어있다.

문제를 해결하는 아이디어는 의외로 간단하다. 구현 컨트랙트의 주소가 저장되는 스토리지 슬롯의 위치를 임의로 배정해주는 것이다.

```sol title="openzeppelin-contracts-upgradeable/contracts/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol"
abstract contract ERC1967UpgradeUpgradeable {
    /**
     * @dev Storage slot with the address of the current implementation.
     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1, and is
     * validated in the constructor.
     */
    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;


    /**
     * @dev Returns the current implementation address.
     */
    function _getImplementation() internal view returns (address) {
        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;
    }

    /**
     * @dev Stores a new address in the EIP1967 implementation slot.
     */
    function _setImplementation(address newImplementation) private {
        require(AddressUpgradeable.isContract(newImplementation), "ERC1967: new implementation is not a contract");
        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;
    }

    /**
     * @dev Perform implementation upgrade
     *
     * Emits an {Upgraded} event.
     */
    function _upgradeTo(address newImplementation) internal {
        _setImplementation(newImplementation);
        emit Upgraded(newImplementation);
    }
}
```

`_IMPLEMENTATION_SLOT`의 값이 도출된 과정은 “eip1967.proxy.implementation” 를 해싱한 후에 1을 뺀 값이라고 주석에 설명 되어있다.

이후 `_setImplementation` 함수나 `_getImplementation` 함수에서는 해당 슬롯값을 활용하여 구현 컨트랙트의 주소를 저장하거나 조회하는 것을 볼 수 있다.

이전 글에서 솔리디티의 스토리지 레이아웃에 대해 살펴볼 때, 컨트랙트의 변수들이 스토리지에 할당되는 기본적인 방식은 선언되는 순서에 따라 슬롯넘버가 할당되는 방식이며, 매핑타입의 경우 value가 저장되는 방식은 매핑 타입 변수가 최초에 할당된 슬롯넘버와 매핑의 key값을 함께 해싱한 슬롯넘버에 할당된다는 것을 알 수 있었다.

ERC1967에서 구현 컨트랙트 주소의 스토리지 슬롯넘버를 임의로 지정하여 저장하는 방식은 매핑 타입의 value가 저장되는 방식을 차용한 방식이다. 일반적인 경우에 사용되지 않을 특정 슬롯넘버에 구현 컨트랙트 주소를 저장해놓았기 때문에 이후 구현 컨트랙트에서 선언되는 변수들에 의해 구현 컨트랙트 주소에 대한 스토리지 충돌이 발생하는 것을 막을 수 있는 것이다.

```mdx-code-block
<Tabs>
<TabItem value="contracts/ERC1967/ERC1967.sol">
```

```sol
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract ERC1967 is ERC1967Proxy, Ownable {
    constructor(address _logic, bytes memory _data)
        payable
        ERC1967Proxy(_logic, _data)
    {}

    function upgradeTo(address newImplementation) external onlyOwner {
        _upgradeToAndCall(newImplementation, bytes(""), false);
    }

    function upgradeToAndCall(address newImplementation, bytes calldata data)
        external
        payable
        onlyOwner
    {
        _upgradeToAndCall(newImplementation, data, true);
    }

    function implementation() external view returns (address) {
        return _implementation();
    }
}
```

```mdx-code-block
</TabItem>
<TabItem value="contracts/ERC1967/v1.sol">
```

```sol
//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

contract ERC1967ImplementationV1 {
    mapping(address => uint256) public counts;

    function count() external {
        counts[msg.sender] += 1;
    }
}
```

```mdx-code-block
</TabItem>
<TabItem value="contracts/ERC1967/v2.sol">
```

```solidity
//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

contract ERC1967ImplementationV2 {
    mapping(address => uint256) public counts;

    function count() external {
        counts[msg.sender] += 2;
    }
}
```

```mdx-code-block
</TabItem>
</Tabs>
```

위와 같이 ERC1967을 통해 업그레이드 가능한 컨트랙트를 구현하였을 때, 더 이상 구현 컨트랙트에 구현 컨트랙트 주소가 담긴 변수를 순서에 맞게 선언해줄 필요가 없어진 것을 볼 수 있다. 왜냐하면 구현 컨트랙트 주소는 [StorageSlot](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/StorageSlot.sol) 라이브러리를 활용하여 미리 정해진 슬롯넘버의 스토리지슬롯에 저장되기 때문이다.

```sol title="contracts/ERC1967/v4.sol"
//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/StorageSlot.sol";

contract ERC1967ImplementationV4 {
    bytes32 internal constant _IMPLEMENTATION_SLOT =
        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;

    mapping(address => uint256) public counts;

    function count() external {
        counts[msg.sender] += 3;
    }

    function storageTest(address _target) external {
        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = _target;
    }

    function getAddress() external view returns (address target_) {
        target_ = StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;
    }
}
```

```bash
console.log("V4 ------ storage test ------");  
const storageTest = await proxy.storageTest(users[0].address);  await storageTest.wait();  
console.log("users[0]:", users[0].address);  console.log("implementation:", await erc1967Proxy.implementation());
테스트 결과
V4 ------ storage test ------
users[0]: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
implementation: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
```

참고로 당연한 결과겠지만, 프록시 컨트랙트에서 사용하고 있는 슬롯넘버를 구현 컨트랙트에서 동일하게 사용하게 되면 스토리지 충돌이 발생한다.

<hr/>
물론 이와 같은 방식을 통해 해결한 것은 프록시 컨트랙트에 필수적으로 필요한 구현 컨트랙트 주소 변수에 한정된 스토리지 충돌이다. 업그레이드 되는 구현 컨트랙트에 선언된 변수가 이전 버전의 구현 컨트랙트에서 사용되던 변수와 충돌할 수 있는 위험은 여전히 그대로 존재한다.

그렇다면 스토리지 충돌 이외에는 프록시 패턴의 단점은 존재하지 않고 이제 ERC1967을 그대로 사용하기만 하면 되는 것일까?

### 생성자 함수
이 단점은 ERC1967의 단점이라기 보다는 delegatecall을 기반으로 하는 프록시 패턴 자체의 단점이라고 볼 수 있다.

프록시 패턴을 구현할 때 로직이 담긴 구현 컨트랙트에서는 constructor를 사용할 수 없다. 정확히 말해 사용할 수 없다기보다는 설사 구현 컨트랙트에서 생성자 함수를 사용하여 변수들에 값을 초기화했다고 하더라도 의미가 없다.

이전 글에서 보았듯이 프록시 패턴의 기본 아이디어는 데이터와 로직을 분리하는 것이고, 데이터는 새롭게 배포된 구현 컨트랙트의 스토리지를 활용하는 것이 아니라 이미 배포되어있던 프록시 컨트랙트의 스토리지를 이어서 활용한다는 것이 업그레이드의 의미이기 때문이다.

실제 프로덕트로 활용되고 있는 컨트랙트 데이터는 프록시 컨트랙트의 데이터일 것이기 때문에, 구현 컨트랙트가 배포되면서 실행된 생성자 함수의 로직은 의미없이 동작한 채로 끝날 것이다. 생성자 함수는 컨트랙트가 배포되는 순간에 한 번 실행된 이후로 프록시 컨트랙트에서 호출할 수 없기 때문에, 만약 초기 셋팅이 필요하다면 생성자 함수가 아닌 다른 방식을 사용해야 한다.

일반적으로 사용되는 방식은 구현 컨트랙트에서 임의의 초기화 함수를 만들어놓고 버전 별로 딱 한 번만 실행되고, 한 번 호출된 이후로는 호출되더라도 실행되지 않게 [제한 해놓는 방식](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/utils/Initializable.sol#L107)이다.

같은 이유로 프록시 패턴을 사용할 때는 구현 컨트랙트를 작성할 때 변수에 초기값을 대입하는 방식을 사용할 수 없다. 대입한 값은 구현 컨트랙트의 스토리지에 저장돼있을 뿐, 프록시 컨트랙트의 스토리지와는 상관이 없기 때문이다.

### 함수 충돌
다시 ERC1967로 돌아와서, ERC1967을 사용했을 때 발생할 수 있는 위험 중에는 스토리지 충돌만 존재하는 것은 아니다. 위에서 테스트를 위해 구현된 ERC1967 컨트랙트를 살펴보면, 구현 컨트랙트의 주소를 변경하는 `upgradeTo` 함수와 업그레이드 하면서 구현 컨트랙트에 미리 작성해놓은 초기화 함수를 함께 호출하는 경우에 활용하는 `upgradeToAndCall` 함수, 그리고 현재 구현 컨트랙트의 주소를 조회하는 `implementation` 함수가 외부 함수로 존재하는 것을 볼 수 있다.

우리는 여기서 한 가지 합당한 궁금증을 가질 수 있다. 만약 구현 컨트랙트에도 `upgradeTo`라는 이름의 함수가 존재한다면, 프록시 컨트랙트로 `upgradeTo` 함수를 호출 했을 때, 프록시 컨트랙트에 존재하는 함수가 동작해야 정상적으로 동작한 것일까 아니면 구현 컨트랙트에 존재하는 함수가 동작해야 정상적으로 동작한 것일까?

프록시 컨트랙트에 구현 컨트랙트의 주소값이 꼭 필요한 것처럼, 업그레이드를 위해서는 구현 컨트랙트의 주소를 수정하는 로직의 함수가 꼭 필요하다. 물론 구현 컨트랙트를 작성하는 개발자가 이 점을 잘 숙지하고 있을 것이기 때문에 구현 컨트랙트에 굳이 프록시 컨트랙트에서 자체적으로 사용하는 함수와 동일한 함수명과 인자를 가진 함수를 만들지는 않을 것이다.

하지만 사람은 언제나 실수를 할 수 있을 뿐더러, 더 까다로운 문제는 함수명이 동일하지 않더라도 동일한 함수로 인식되는 경우가 발생할 수 있다는 것이다.

### 컨트랙트가 함수를 식별하는 방식
컨트랙트에 어떤 함수를 호출하는 요청이 들어왔을 때, 호출된 함수가 무엇인지는 트랜잭션의 데이터 필드(calldata)에 들어있는 데이터들을 통해 결정된다. 여기에는 함수의 이름과 인자 타입을 sha3 해싱한 함수 시그니처의 4바이트 함수 식별자와 인자값들이 포함되어있다.

fallback 함수를 기반으로 구현된 프록시 컨트랙트는 calldata에 담긴 함수 식별자와 동일한 식별자를 가진 함수가 존재하는지 확인하고, 존재하지 않으면 fallback 함수를 실행시킬 것이다. 그러면 fallback 함수에서는 구현 컨트랙트에 해당 함수를 delegatecall 하는 로직을 수행할 것이다.

문제는 함수 식별자가 해시값의 앞부분 4바이트 값만으로 이루어진다는 것이다. 때문에 함수명과 인자가 다른 함수라하더라도 동일한 함수 식별자를 갖게 되는 경우가 발생할 수 있다. 하나의 컨트랙트 안에서 함수 식별자가 충돌되는 경우에는 [솔리디티 컴파일러](https://solidity-kr.readthedocs.io/ko/latest/using-the-compiler.html)가 컴파일 과정에서 에러를 발생시키기 때문에 미리 방지할 수 있다.

```bash
"DeclarationError" : 유효하지 않거나 혹은 의결 할수 없는(unresolvable), 식별자 이름충돌입니다.
```

하지만 프록시 컨트랙트와 구현 컨트랙트에서처럼 서로 다른 컨트랙트에서 함수 식별자가 중복되는 경우는 컴파일 과정에서 방지할 수 없다.

<hr/>

```sol title="contracts/ERC1967/v3.sol"
//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

contract ERC1967ImplementationV3 {
    mapping(address => uint256) public counts;

    function count() external {
        counts[msg.sender] += 3;
    }

    function upgradeTo(address _target) external {
        counts[_target] += 3;
    }
}
```

위처럼 구현 컨트랙트에 프록시 컨트랙트와 동일한 이름과 파라미터를 가진 `upgradeTo` 함수가 있을 때, 해당 함수를 호출하면 어떻게 될까?

```ts
console.log("V3 ------ upgradeTo function Error ------");  
await expect(proxy.upgradeTo(users[0].address)).to.be.revertedWith("ERC1967: new implementation is not a contract");
```

테스트 결과를 보면, 업그레이드 하려는 구현 컨트랙트의 주소가 컨트랙트인지 확인하는 require문에 걸려 revert 되는 것을 볼 수 있다.

프록시 컨트랙트에는 해당 함수식별자를 가진 함수가 이미 존재하기 때문에 fallback 함수로 넘어가지 않고 프록시 컨트랙트의 `upgradeTo` 함수가 실행된다.

만약 함수호출자가 컨트랙트를 업그레이드 하려던게 아니라, 구현 컨트랙트에 있는 target 주소에 카운트를 3 더 해주는 기능을 수행하고 싶었던 것이라면 요청의 실패가 무척 당황스웠을 것이다.

이처럼 호출자의 의도와는 다르게 컨트랙트의 기능들이 동작할 수 있기 때문에 ERC1967을 사용할 때는 함수 충돌의 문제를 고려해야한다.