---
layout: single
tags: 
 - python

toc: true
toc_sticky: true

title: "[python] function parameters"
---

{% raw %}

## Function Parameters

### **positional argument**

다음과 같이 함수에 인수를 순서대로 넣는 방식을 위치 인수(positional argument)라고 합니다. 즉, 인수의 위치가 정해져 있습니다.

```python
>>> print(10, 20, 30)
10 20 30

>>> def print_numbers(a, b, c):
...     print(a)
...     print(b)
...     print(c)
...

>>> print_numbers(10, 20, 30)
10
20
30
```

```python
>>> def print_numbers(a, b, c):
...     print(a)
...     print(b)
...     print(c)
...

>>> x = [10, 20, 30]
>>> print_numbers(*x)
10
20
30
```

print_numbers에 10, 20, 30이 들어있는 리스트 x를 넣고 *만 붙였는데도 숫자가 각 줄에 출력되었습니다. 즉, 리스트(튜플) 앞에 *를 붙이면 언패킹(unpacking)이 되어서 print_numbers(10, 20, 30)과 똑같은 동작이 됩니다. 말 그대로 리스트의 포장을 푼다는 뜻입니다.

![img](https://dojang.io/pluginfile.php/13788/mod_page/content/2/030001.png)

단, 이때 함수의 매개변수 개수와 리스트의 요소 개수는 같아야 합니다. 만약 개수가 다르면 함수를 호출할 수 없습니다. 여기서는 함수를 def print_numbers(a, b, c):로 만들었으므로 리스트에는 요소를 3개 넣어야 합니다.

**variable argument**

```python
>>> def print_numbers(*args):
...     for arg in args:
...         print(arg)
...

>>> print_numbers(10)
10
>>> print_numbers(10, 20, 30, 40)
10
20
30
40
```

매개변수 이름은 원하는 대로 지어도 되지만 관례적으로 **arg**ument**s**를 줄여서 args로 사용합니다. 특히 이 args는 튜플이라서 for로 반복할 수 있습니다.

```python
>>> x = [10]
>>> print_numbers(*x)
10
>>> y = [10, 20, 30, 40]
>>> print_numbers(*y)
10
20
30
40
```

함수에 인수 여러 개를 직접 넣어도 되고, 리스트(튜플) 언패킹을 사용해도 됩니다.

리스트 x는 [10]이므로 print_numbers(*x)로 호출하면 print_numbers(10)과 같고 리스트 y는 [10, 20, 30, 40]이므로 print_numbers(10, 20, 30, 40)과 같습니다.

```python
>>> def print_numbers(a, *args):
...     print(a)
...     print(args)
...
>>> print_numbers(1)
1
()
>>> print_numbers(1, 10, 20)
1
(10, 20)
>>> print_numbers(*[10, 20, 30])
10
(20, 30)
```

고정 인수와 가변 인수를 함께 사용할 때는 다음과 같이 고정 매개변수를 먼저 지정하고, 그 다음 매개변수에 *를 붙여주면 됩니다.

단, 이때 def print_numbers(*args, a):처럼 *args가 고정 매개변수보다 앞쪽에 오면 안 됩니다. 매개변수 순서에서 *args는 반드시 가장 뒤쪽에 와야 합니다.

### keyword argument

키워드 인수는 말 그대로 인수에 이름(키워드)을 붙이는 기능인데 **키워드=값** 형식으로 사용합니다.

```python
>>> def personal_info(name, age, address):
...     print('이름: ', name)
...     print('나이: ', age)
...     print('주소: ', address)
...

>>> personal_info('홍길동', 30, '서울시 용산구 이촌동')
이름:  홍길동
나이:  30
주소:  서울시 용산구 이촌동

>>> personal_info(name='홍길동', age=30, address='서울시 용산구 이촌동')
이름:  홍길동
나이:  30
주소:  서울시 용산구 이촌동

>>> personal_info(age=30, address='서울시 용산구 이촌동', name='홍길동')
이름:  홍길동
나이:  30
주소:  서울시 용산구 이촌동
```

키워드 인수를 사용하니 함수를 호출할 때 인수의 용도가 명확하게 보입니다. 특히 키워드 인수를 사용하면 인수의 순서를 맞추지 않아도 키워드에 해당하는 값이 들어갑니다

print 함수에서 사용했던 sep, end도 키워드 인수입니다.

```python
print(10, 20, 30, sep=':', end='')
```

```python
>>> x = {'name': '홍길동', 'age': 30, 'address': '서울시 용산구 이촌동'}
>>> personal_info(**x)
이름:  홍길동
나이:  30
주소:  서울시 용산구 이촌동
```

![img](https://dojang.io/pluginfile.php/13790/mod_page/content/2/030002.png)

딕셔너리 언패킹을 사용할 때는 함수의 매개변수 이름과 딕셔너리의 키 이름이 같아야 합니다. 또한, 매개변수 개수와 딕셔너리 키의 개수도 같아야 합니다.

딕셔너리는 **처럼 *를 왜 두 번 사용할까요? 왜냐하면 딕셔너리는 키-값 쌍 형태로 값이 저장되어 있기 때문입니다.

```python
>>> x = {'name': '홍길동', 'age': 30, 'address': '서울시 용산구 이촌동'}
>>> personal_info(*x)
이름:  name
나이:  age
주소:  address
```

personal_info에 *x를 넣으면 x의 키가 출력됩니다. 즉, 딕셔너리를 한 번 언패킹하면 키를 사용한다는 뜻이 됩니다. 따라서 **처럼 딕셔너리를 두 번 언패킹하여 값을 사용하도록 만들어야 합니다.

**variable argument**

```python
>>> def personal_info(**kwargs):
...     for kw, arg in kwargs.items():
...         print(kw, ': ', arg, sep='')
...

>>> personal_info(name='홍길동')
name: 홍길동
>>> personal_info(name='홍길동', age=30, address='서울시 용산구 이촌동')
name: 홍길동
age: 30
address: 서울시 용산구 이촌동

>>> x = {'name': '홍길동'}
>>> personal_info(**x)
name: 홍길동
>>> y = {'name': '홍길동', 'age': 30, 'address': '서울시 용산구 이촌동'}
>>> personal_info(**y)
name: 홍길동
age: 30
address: 서울시 용산구 이촌동
```

매개변수 이름은 원하는 대로 지어도 되지만 관례적으로 **k**ey**w**ord **arg**ument**s**를 줄여서 kwargs로 사용합니다. 특히 이 kwargs는 딕셔너리라서 for로 반복할 수 있습니다.

def personal_info(**kwargs):와 같이 매개변수에 **를 붙여주면 키워드 인수를 사용하는 가변 인수 함수를 만들 수 있습니다. 그리고 이런 함수를 호출할 때는 키워드와 인수를 각각 넣거나 딕셔너리 언패킹을 사용하면 됩니다.

보통 **kwargs를 사용한 가변 인수 함수는 다음과 같이 함수 안에서 특정 키가 있는지 확인한 뒤 해당 기능을 만듭니다.

```python
def personal_info(**kwargs):
    if 'name' in kwargs:    # in으로 딕셔너리 안에 특정 키가 있는지 확인
        print('이름: ', kwargs['name'])
    if 'age' in kwargs:
        print('나이: ', kwargs['age'])
    if 'address' in kwargs:
        print('주소: ', kwargs['address'])
```

```python
>>> def personal_info(name, **kwargs):
...     print(name)
...     print(kwargs)
...
>>> personal_info('홍길동')
홍길동
{}
>>> personal_info('홍길동', age=30, address='서울시 용산구 이촌동')
홍길동
{'age': 30, 'address': '서울시 용산구 이촌동'}
>>> personal_info(**{'name': '홍길동', 'age': 30, 'address': '서울시 용산구 이촌동'})
홍길동
{'age': 30, 'address': '서울시 용산구 이촌동'}
```

함수에서 위치 인수를 받는 *args와 키워드 인수를 받는 **kwargs를 함께 사용할 수도 있습니다. 대표적인 함수가 print인데 print는 출력할 값을 위치 인수로 넣고 sep, end 등을 키워드 인수로 넣습니다. 

```python
>>> def custom_print(*args, **kwargs):
...     print(*args, **kwargs)
...
>>> custom_print(1, 2, 3, sep=':', end='')
1:2:3
```

단, 이때 매개변수 순서에서 **kwargs는 반드시 가장 뒤쪽에 와야 합니다.

특히 고정 매개변수를 함께 사용한다면 매개변수는 고정 매개변수, *args, **kwargs 순으로 지정해야 합니다.

### 매개변수에 초깃값 지정하기

print 함수의 sep는 초깃값이 ' '(공백)으로 지정되어 있어서 대부분 그대로 사용하고, 가끔 sep에 다른 값을 넣어서 사용합니다.

```python
>>> def personal_info(name, age, address='비공개'):
...     print('이름: ', name)
...     print('나이: ', age)
...     print('주소: ', address)
...

>>> personal_info('홍길동', 30)
이름:  홍길동
나이:  30
주소:  비공개

>>> personal_info('홍길동', 30, '서울시 용산구 이촌동')
이름:  홍길동
나이:  30
주소:  서울시 용산구 이촌동
```

address는 초깃값이 있으므로 personal_info는 다음과 같이 address 부분을 비워 두고 호출할 수 있습니다.

매개변수에 초깃값이 지정되어 있더라도 값을 넣으면 해당 값이 전달됩니다.

매개변수의 초깃값을 지정할 때 한 가지 주의할 점이 있습니다. 초깃값이 지정된 매개변수 다음에는 초깃값이 없는 매개변수가 올 수 없습니다. 

```python
>>> def personal_info(name, address='비공개', age):
...     print('이름: ', name)
...     print('나이: ', age)
...     print('주소: ', address)
...
  File "<stdin>", line 1
SyntaxError: non-default argument follows default argument
```

왜냐하면 함수를 이렇게 만들어버리면 personal_info('홍길동', 30)으로 함수를 호출했을 때 30이 어디로 들어가야 할지 알 수가 없기 때문입니다.

참고로 def personal_info(name='비공개', age=0, address='비공개'):와 같이 모든 매개변수에 초깃값을 지정하면 personal_info()처럼 인수를 넣지 않고 호출할 수 있습니다.


{% endraw %}
