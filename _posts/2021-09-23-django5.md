## 게시물

```python
class PostView(View) :
    # 게시물 등록
    @login_decorator
    def post(self, request) :
        try :
            data = json.loads(request.body)
            user = request.user

            content = data['content']
            image_list = data['image'].split(',')
            

            post = Post.objects.create(
                content = content,
                user = user,
            )

            for image in image_list :
                Image.objects.create(
                    url = image,
                    post = post,
                )
        
            return JsonResponse({'MASSAGE':'SUCCESS'}, status=200)

        except KeyError :
            return JsonResponse({'MASSAGE':'KEY_ERROR'}, status=400)
        
        except JSONDecodeError :
            return JsonResponse({'message':'JSON_DECODE_ERROR'}, status=400)
    
    # 전체 게시물 가져오기
    def get(self, request) :
        post_list = [{
            '작성자' : User.objects.get(id=post.user.id).name,
            'content' : post.content,
            'images' : [image.url for image in post.images.all()],
            '좋아요' : post.likes.all().count(),
            '댓글 수' : post.comments.all().count(),
            'created_at' : post.created_at
        } for post in Post.objects.all().order_by('-created_at')
        ]

        return JsonResponse({'DATA' : post_list}, status=200)
```

전체 게시물을 조회했을 때 count()를 이용해서 좋아요가 눌린 횟수와 댓글 수도 함께 보여주도록 추가했다. 그리고 order_by를 통해 데이터베이스에서 데이터를 가져올 때 created_at을 기준으로 내림차순 정렬로 가져오도록 지정해서 게시물이 최신순으로 정렬되도록 했다.

![](https://user-images.githubusercontent.com/61782539/134490581-ed9d0953-abed-46a7-aaea-3e7f2cde3ecb.png)

```python
class PostDetailView(View) :
    # 특정 게시물 보기 (댓글 포함)
    def get(self, request, post_id) :
        if not Post.objects.filter(id=post_id).exists():
            return JsonResponse({'message' : 'POST_DOES_NOT_EXIST'}, status=404)
        
        post = Post.objects.get(id=post_id)        
        post_info = [{
            '작성자' : User.objects.get(id=post.user.id).name,
            'content' : post.content,
            'images' : [image.url for image in post.images.all()],
            '좋아요' : post.likes.all().count(),
            'created_at' : post.created_at
        }
        ]
        comment_list = [{
            '작성자' : User.objects.get(id=comment.user.id).name,
            'content' : comment.content,
            'created_at': comment.created_at
        } for comment in Comment.objects.filter(post = post)
        ]

        return JsonResponse({'post_info': post_info, 'comment_list': comment_list} ,status=200)

    # 게시물 삭제
    @login_decorator
    def delete(self, request, post_id) :
        user= request.user
        if not Post.objects.filter(id=post_id).exists():
            return JsonResponse({'message' : 'POST_DOES_NOT_EXIST'}, status=404)
        
        post = Post.objects.get(id=post_id)
        
        if user != post.user :
            return JsonResponse({'message' : 'INVALID_USER'}, status=401)
        
        Post.objects.filter(id=post_id).delete()
        return JsonResponse({'message' : 'SUCCESS'}, status=200)

    # 게시물 수정
    @login_decorator
    def post(self, request, post_id) :
        try : 
            user = request.user
            data = json.loads(request.body)
            if not Post.objects.filter(id=post_id).exists():
                return JsonResponse({'message' : 'POST_DOES_NOT_EXIST'}, status=404)
            
            post = Post.objects.get(id=post_id)
            
            if user != post.user :
                return JsonResponse({'message' : 'INVALID_USER'}, status=401)
            
            post.content = data.get('content', post.content)
            post.save()

            return JsonResponse({'message' : 'SUCCESS'}, status=201)

        except JSONDecodeError :
            return JsonResponse({'message':'JSON_DECODE_ERROR'}, status=400)
```

게시물 삭제와 수정은 디테일 뷰를 따로 만들어서 함수를 작성했다. 

```python
urlpatterns = [
    path('/post', PostView.as_view()),
    path('/comment', CommentView.as_view()),
    path('/post/<int:post_id>', PostDetailView.as_view()),
    path('/comment/<int:comment_id>', CommentDetailView.as_view()),
    path('/like', LikeView.as_view()),
    path('/follow', FollowView.as_view()),
]
```

url.py 에 /post 다음에 post_id(int)를 넣으면 PostDetaileView로 가도록 지정했다. url에서 바로 post_id를 얻을 수 있기 때문에 단순히 데이터를 조회하거나 삭제할 때는 body 값이 필요하지 않다. 게시물 삭제나 수정은 로그인한 유저만 가능할 것이므로 로그인 데코레이터를 붙여주었다. 데코레이터에서 request.user로 로그인한 유저 정보를 넣어주기 때문에 그 뒤에 작동할 함수에서 바로 유저 정보에 접근할 수 있다. 

```python
user = request.user
```

그 다음 url에서 얻은 post_id에 해당하는 게시물이 있는지 확인하고 존재하지 않는 게시물이면 404(Not Found, 찾을 수 없음) 코드를 반환한다.

```python
if not Post.objects.filter(id=post_id).exists():
                return JsonResponse({'message' : 'POST_DOES_NOT_EXIST'}, status=404)
```

게시물을 삭제, 수정하려는 유저가 해당 게시물을 작성한 유저가 맞는지 확인하고 아니면 401(권한 없음) 코드를 반환한다.

```python
if user != post.user :
            return JsonResponse({'message' : 'INVALID_USER'}, status=401)
```

게시물 삭제일 경우 delete()를 통해 삭제해준다.

```python
Post.objects.filter(id=post_id).delete()
return JsonResponse({'message' : 'SUCCESS'}, status=200)
```

게시물 수정일 경우 body에서 가져온 data 값(딕셔너리)에 get 메서드를 통해 접근해서 수정할 content 값을 가져온다. get()에선 두번째 인자에 딕셔너리에 해당하는 key가 없을 때 반환되는 값을 지정할 수 있다. 따로 지정하지 않았을 때 해당하는 key가 없을 시 반환되는 기본값은 None이다. body에 content 값이 제대로 들어가지 않았을 경우를 대비해서 두번째 인자에 본래 content 값을 넣어준다. 

```python
post.content = data.get('content', post.content)
post.save()

return JsonResponse({'message' : 'SUCCESS'}, status=201)
```

특정 게시물 보기를 했을 때는 해당 게시물에 달린 댓글의 내용까지 전부 보여지도록 했다.

## 댓글

```python
class CommentView(View) :
    # 댓글, 대댓글 등록
    @login_decorator
    def post(self, request) :
        try:
            data = json.loads(request.body)
            user = request.user
            content = data.get('content')
            post_id = data.get('post_id')
            parent_comment_id = data.get('parent_comment_id')

            if not content and post_id :
                return JsonResponse({'message' : 'KEY_ERROR'}, status=400)
        
            if not Post.objects.filter(id=post_id).exists():
                return JsonResponse({'message' : 'POST_DOES_NOT_EXIST'}, status=404)
        
            post = Post.objects.get(id=post_id)

            Comment.objects.create(
                content = content,
                user = user,
                post = post,
                parent_comment_id = parent_comment_id
                )
            return JsonResponse({'message' : 'SUCCESS'}, status=200)
        
        except JSONDecodeError :
            return JsonResponse({'message':'JSON_DECODE_ERROR'}, status=400)
    

class CommentDetailView(View):
    # 댓글 삭제
    @login_decorator
    def delete(self, request, comment_id) :
        user = request.user
        if not Comment.objects.filter(id=comment_id).exists():
            return JsonResponse({'message' : 'COMMENT_DOES_NOT_EXIST'}, status=404)
        
        comment = Comment.objects.get(id= comment_id)

        if user != comment.user :
            return JsonResponse({'message' : 'INVALID_USER'}, status=401)

        Comment.objects.filter(id=comment_id).delete()
        return JsonResponse({'message' : 'SUCCESS'}, status=200)
```

대댓글 생성을 위해 Comment 모델에 parent_comment 칼럼을 추가했다.

```python
class Comment(models.Model) :
    content = models.CharField(max_length=1000)
    created_at = models.DateTimeField(auto_now_add=True)
    user = models.ForeignKey('users.User', on_delete=models.CASCADE, related_name='comments')
    post = models.ForeignKey('Post', on_delete=models.CASCADE, related_name='comments')
    parent_comment = models.ForeignKey('self', on_delete=models.CASCADE, null=True, 
    related_name='child_comments')

    class Meta :
        db_table = 'comments'
```

parent_comment는 자기 자신을 참조하는 foreignkey를 갖는다. 만약 대댓글이 아니라 그냥 댓글이라면 parent_comment에 값이 없을 것이고 (null= True), 대댓글이라면 참조하고 있는 부모댓글 값이 들어간다.

```python
parent_comment_id = data.get('parent_comment_id')
```

get 메서드에서 해당 key가 없을 때 None을 반환해주기 때문에, 생성하려는 댓글이 대댓글이 아니라서 body에 parent_comment_id가 들어있지 않으면 변수에 None이 저장되고 keyError가 발생하지 않는다. 

```python
>>> data = { '1' : 1, '2':2}
>>> a = data.get('3')
>>> print(a)
None
>>> a= data['3']
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: '3'
```

때문에 아래와 같이 생성했을 때

```python
Comment.objects.create(
                content = content,
                user = user,
                post = post,
                parent_comment_id = parent_comment_id
                )
return JsonResponse({'message' : 'SUCCESS'}, status=200)
```

![](https://user-images.githubusercontent.com/61782539/134446202-feeff62f-30b3-42b9-b220-43d2f66216be.png)

그냥 댓글이면 부모 댓글 값이 NULL이고 대댓글이면 참조하고 있는 부모 댓글이 저장된다.

댓글을 생성할 때는 댓글의 내용과 댓글을 달려는 게시물 정보는 꼭 필요하기 때문에 해당 값들이 제대로 전달되지 않았을 때는 400(잘못된 요청) 코드를 반환했다. 그리고 댓글을 달려는 게시물이 존재하지 않는 게시물이면 404(Not Found, 찾을 수 없음) 코드를 반환했다.

```python
if not content and post_id :
                return JsonResponse({'message' : 'KEY_ERROR'}, status=400)
        
if not Post.objects.filter(id=post_id).exists():
                return JsonResponse({'message' : 'POST_DOES_NOT_EXIST'}, status=404)
```

댓글 삭제는 CommentDetailView를 따로 만들어주었다. PostDetailView와 마찬가지로 url.py에서 comment/ 다음에 comment_id(int)가 입력되면 해당 뷰로 연결시켜주었다. 

```python
urlpatterns = [
    path('/post', PostView.as_view()),
    path('/comment', CommentView.as_view()),
    path('/post/<int:post_id>', PostDetailView.as_view()),
    path('/comment/<int:comment_id>', CommentDetailView.as_view()),
    path('/like', LikeView.as_view()),
    path('/follow', FollowView.as_view()),
]
```

대댓글 기능을 추가한 후에 특정 게시물을 조회했을 때 댓글과 대댓글 구분이 없이 보여지므로 부모 댓글 안에 대댓글들이 딸려서 보여지도록 수정했다.

```python
def get(self, request, post_id) :
        if not Post.objects.filter(id=post_id).exists():
            return JsonResponse({'message' : 'POST_DOES_NOT_EXIST'}, status=404)
        
        post = Post.objects.get(id=post_id)        
        post_info = [{
            '작성자' : User.objects.get(id=post.user.id).name,
            'content' : post.content,
            'images' : [image.url for image in post.images.all()],
            '좋아요' : post.likes.all().count(),
            'created_at' : post.created_at
        }
        ]
            
       	comment_list = []
        for comment in Comment.objects.filter(post=post) :
            if comment.child_comments.count() == 0 and comment.parent_comment == None :
                comment_list.append(
                    {
                        '작성자' : User.objects.get(id=comment.user.id).name,
                        'content' : comment.content,
                        'created_at' : comment.created_at
                    }
                )
            if comment.child_comments.count() > 0:
                child_comment_list = [
                    {'작성자' : User.objects.get(id=child_comment.user.id).name,
                     'content' : child_comment.content,
                     'created_at' : child_comment.created_at
                    }for child_comment in comment.child_comments.all()
                ]
               
                comment_list.append(
                    {
                        '작성자' : User.objects.get(id=comment.user.id).name,
                        'content' : comment.content,
                        'created_at' : comment.created_at,
                        '대댓글' : child_comment_list                   
                    }
                )
         
        return JsonResponse({'post_info': post_info, 'comment_list': comment_list} ,status=200)
```

댓글에 child_comments(related_name 지정)가 없고, 그 자신이 대댓글이 아니라면 혼자 존재하는 댓글이기 때문에 그대로 댓글 리스트에 추가해주었다. child_comments를 하나 이상 갖고 있다면 대댓글 리스트를 따로 생성해서 for 문을 돌려 해당 댓글의 대댓글들을 리스트에 넣어주고 댓글 정보에 '대댓글' 로 추가해주었다.

![](https://user-images.githubusercontent.com/61782539/134483423-98c10bbc-d5c9-4c35-ae9e-24efd24defd2.png)

## 좋아요

```python
class LikeView(View) :
    # 좋아요 기능
    @login_decorator
    def post(self, request) :
        try :
            data = json.loads(request.body)
            user = request.user
            post_id = data.get('post_id')
        
            if not post_id :
                return JsonResponse({'message':'KEY_ERROR'}, status=400)
            
            if not Post.objects.filter(id=post_id).exists() :
                return JsonResponse({'message':'POST_DOES_NOT_EXIST'}, status=404)

            post = Post.objects.get(id=post_id)

            if Like.objects.filter(user=user, post=post).exists() :
                Like.objects.filter(user=user, post=post).delete()
                like_count = Like.objects.filter(post=post).count()
                return JsonResponse({'message':'SUCCESS', '좋아요 수' : like_count}, status=200)

            Like.objects.create(
                user= user,
                post= post
            )
            like_count = Like.objects.filter(post=post).count()
            return JsonResponse({'message':'SUCCESS', '좋아요 수' : like_count}, status=200)
        
        except JSONDecodeError :
            return JsonResponse({'message':'JSON_DECODE_ERROR'}, status=400)
```

좋아요 기능도 마찬가지로 post_id가 제대로 들어왔는지, 해당 post_id의 게시물이 존재하는지 확인해주었다. 한번 좋아요를 눌렀던 게시물에 또 다시 좋아요를 누르면 delete()로 좋아요가 삭제되게끔 만들었다. 그리고 좋아요를 누르거나 취소했을 때 해당 게시물의 좋아요 수가 함께 반환되도록 했다.

## 팔로우

```python
class FollowView(View) :
    # 팔로우 기능
    @login_decorator
    def post(self, request) :
        try :
            data = json.loads(request.body)
            follower = request.user
            following_id = data.get('following_id')

            if not following_id :
                return JsonResponse({'message' : 'KEY_ERROR'}, status= 400)
            
            if not User.objects.filter(id= following_id).exists() :
                return JsonResponse({'message':'USER_DOES_NOT_EXIST'}, status=404)
            
            following = User.objects.get(id=following_id)

            if Follow.objects.filter(follower = follower, following= following).exists() :
                return JsonResponse({'message': 'ALREADY_FOLLOW'}, status=400)

            Follow.objects.create(
                follower = follower,
                following = following
            )
            following_list = [ follower.following.name
                for follower in Follow.objects.filter(follower = follower)]
            
            return JsonResponse({'message':'SUCCESS', 'FOLLOWING' : following_list}, status=200)

        except JSONDecodeError :
            return JsonResponse({'message':'JSON_DECODE_ERROR'}, status=400)

    # 언팔로우 기능
    @login_decorator
    def delete(self, request) :
        try :
            data = json.loads(request.body)
            follower = request.user
            un_following_id = data.get('un_following_id')

            if not un_following_id :
                return JsonResponse({'message' : 'KEY_ERROR'}, status=400)
            
            if not User.objects.filter(id= un_following_id).exists() :
                return JsonResponse({'message':'USER_DOES_NOT_EXIST'}, status=404)
            
            un_following = User.objects.get(id=un_following_id)

            if not Follow.objects.filter(follower = follower, following= un_following).exists() :
                return JsonResponse({'message': 'DOES_NOT_FOLLOW'}, status=400)
            
            Follow.objects.filter(follower=follower, following= un_following).delete()
            return JsonResponse({'message' : 'SUCCESS'}, status=200)
        
        except JSONDecodeError :
            return JsonResponse({'message':'JSON_DECODE_ERROR'}, status=400)

    # 팔로잉 게시물 모아보기
    @login_decorator
    def get(self, request) :
        follower = request.user 
        
        post_list = [{
        '작성자' : User.objects.get(id=post.user.id).name,
        'content' : post.content,
        'images' : [image.url for image in post.images.all()],
        '좋아요' : post.likes.all().count(),
        '댓글 수' : post.comments.all().count(),
        'created_at' : post.created_at
        } for follower in Follow.objects.filter(follower=follower) for post in 		  		
          Post.objects.filter(user=follower.following)] 

        post_list = sorted(post_list, key=lambda post : post['created_at'], reverse= True)
        
        return JsonResponse({'data': post_list}, status= 202)
```

팔로우 모델은 한 클래스 내에서 User 모델을 두 번 참조한다. 한 클래스에서 같은 객체를 참조할 때는 데이터베이스가 이를 구분할 수 있게 related_name을 필수로 지정해주야 한다. 

```python
class Follow(models.Model) :
    following = models.ForeignKey('users.User', on_delete=models.CASCADE, related_name='follower')
    follower = models.ForeignKey('users.User', on_delete=models.CASCADE, related_name='following')

    class Meta :
        db_table = 'follows'
```

만약 이미 팔로우한 상대를 또 팔로우 했을 때 좋아요 때처럼 delete()를 해줄까 고민하다 보통 팔로우 취소 기능은 따로 있으므로 그냥 400(잘못된 요청) 코드를 반환해주었다. 그리고 언팔로우 함수를 따로 만들어주었다.

```python
if Follow.objects.filter(follower = follower, following= following).exists() :
                return JsonResponse({'message': 'ALREADY_FOLLOW'}, status=400)
```

자신이 팔로우하고 있는 유저들의 게시물만 모아서 볼 수 있는 함수를 만들었다. 팔로우하고 있는 유저가 여러명일 것이고 또 그 유저 개개인의 게시물들도 여러개일 것이기 때문에 두 번의 반복문으로 접근했다. 전체게시물을 조회했을 때처럼 최신순으로 정렬하고 싶었는데, order_by로 데이터를 꺼내오는 과정에서 정렬시키면 Post.objects.filter(user=follower.following)에서 유저 한 명, 한 명의 게시물들을 꺼내오면서 정렬될 것이기 때문에 유저가 섞이지 않고 정렬될 것 같았다. 그래서 일단 post_list에 데이터들을 모두 넣어준 후에 마지막에 sorted() 와 람다 표현식을 사용해서 'created_at'을 기준으로 내림차순으로 정렬했다.

```python
# 팔로잉 게시물 모아보기
@login_decorator
def get(self, request) :
    follower = request.user 
        
    post_list = [{
    '작성자' : User.objects.get(id=post.user.id).name,
    'content' : post.content,
    'images' : [image.url for image in post.images.all()],
    '좋아요' : post.likes.all().count(),
    '댓글 수' : post.comments.all().count(),
    'created_at' : post.created_at
     } for follower in Follow.objects.filter(follower=follower) for post in 		  		
     Post.objects.filter(user=follower.following)] 

     post_list = sorted(post_list, key=lambda post : post['created_at'], reverse= True)
        
     return JsonResponse({'data': post_list}, status= 202)
```

![](https://user-images.githubusercontent.com/61782539/134490673-a6d454c4-f835-410a-bd4e-3d682e18e2c9.png)

