## boolean과 비교, 논리 연산자 사용하기

**비교 연산자**

| 연산자 | 문법       | 설명                       |
| ------ | ---------- | -------------------------- |
| ==     | a == b     | 같음                       |
| !=     | a != b     | 같지 않음, 다름            |
| >      | a > b      | 큼, 초과                   |
| <      | a < b      | 작음, 미만                 |
| >=     | a >= b     | 크거나 같음, 이상          |
| <=     | a <= b     | 작거나 같음, 이하          |
| is     | a is b     | 같음(객체 비교)            |
| is not | a is not b | 같지 않음, 다름(객체 비교) |

**논리 연산자**

| 연산자 | 문법    | 설명                                   |
| ------ | ------- | -------------------------------------- |
| and    | a and b | AND(논리곱), 양쪽 모두 참일 때 참      |
| or     | a or b  | OR(논리합), 양쪽 중 한쪽만 참이라도 참 |
| not    | not x   | NOT(논리 부정), 참과 거짓을 뒤집음     |

불은 True, False로 표현하며 1, 3.6, 'Python'처럼 값의 일종입니다.

```python
>>> True
True
>>> False
False
```

파이썬에서는 비교 연산자와 논리 연산자의 판단 결과로 True, False를 사용합니다. 즉, 비교 결과가 맞으면 True, 아니면 False입니다.

```python
>>> 3 > 1
True
```

```python
>>> 10 == 10    # 10과 10이 같은지 비교
True
>>> 10 != 5     # 10과 5가 다른지 비교
True
>>> 'Python' == 'Python'
True
>>> 'Python' == 'python'
False
>>> 'Python' != 'python'
True
```

```python
>>> 10 > 20    # 10이 20보다 큰지 비교
False
>>> 10 < 20    # 10이 20보다 작은지 비교
True
>>> 10 >= 10    # 10이 10보다 크거나 같은지 비교
True
>>> 10 <= 10    # 10이 10보다 작거나 같은지 비교
True
```

==, !=는 값 자체를 비교하고, is, is not은 객체(object)를 비교합니다.

```python
>>> 1 == 1.0
True
>>> 1 is 1.0
False
>>> 1 is not 1.0
True
```

```python
>>> a = -5
>>> a is -5
True
>>> a = -6
>>> a is -6
False
```

값을 비교할 때는 is를 사용하면 안 됩니다. 다음과 같이 변수 a에 -5를 할당한 뒤 a is -5를 실행하면 True가 나오지만 다시 -6을 할당한 뒤 a is -6을 실행하면 False가 나옵니다. 왜냐하면 변수 a가 있는 상태에서 다른 값을 할당하면 메모리 주소가 달라질 수 있기 때문입니다. 따라서 다른 객체가 되므로 값이 같더라도 is로 비교하면 False가 나옵니다. 값(숫자)를 비교할 때는 is가 아닌 비교 연산자를 사용해야 합니다.

```python
>>> True and True
True
>>> True and False
False
>>> False and True
False
>>> False and False
False #논리 연산자 and
```

and는 두 값이 모두 True라야 True입니다. 하나라도 False이면 False가 나옵니다.

```python
>>> True or True
True
>>> True or False
True
>>> False or True
True
>>> False or False
False #논리 연산자 or
```

or는 두 값 중 하나라도 True이면 True입니다. 두 값이 모두 False라야 False가 됩니다.

```python
>>> not True
False
>>> not False
True
```

not은 논릿값을 뒤집습니다. 그래서 not True는 False가 되고, not False는 True가 됩니다.

```python
not True and False or not False
False and False or True
False or True
True

>>> ((not True) and False) or (not False)
True
```

and, or, not 논리 연산자가 식 하나에 들어있으면 not, and, or 순으로 판단합니다.

```python
>>> 10 == 10 and 10 != 5    # True and True
True
>>> 10 > 5 or 10 < 3        # True or False
True
>>> not 10 > 5              # not True
False
>>> not 1 is 1.0            # not False
True
```

```python
>>> bool(1)
True
>>> bool(0)
False
>>> bool(1.5)
True
>>> bool('False')
True
```

**정수 0, 실수 0.0이외의 모든 숫자는 True입니다. 그리고 빈 문자열 '', ""를 제외한 모든 문자열은 True입니다.**

```python
# 첫 번째 값이 거짓이므로 두 번째 값은 확인하지 않고 거짓으로 결정
print(False and True)     # False
print(False and False)    # False
```

논리 연산에서 중요한 부분이 단락 평가(short-circuit evalution)입니다. 단락 평가는 첫 번째 값만으로 결과가 확실할 때 두 번째 값은 확인(평가)하지 않는 방법을 말합니다. 즉, and 연산자는 두 값이 모두 참이라야 참이므로 첫 번째 값이 거짓이면 두 번째 값은 확인하지 않고 바로 거짓으로 결정합니다.

or 연산자는 두 값 중 하나만 참이라도 참이므로 첫 번째 값이 참이면 두 번째 값은 확인하지 않고 바로 참으로 결정합니다.

```python
# 첫 번째 값이 참이므로 두 번째 값은 확인하지 않고 참으로 결정
print(True or True)     # True
print(True or False)    # True
```

```python
>>> True and 'Python'
'Python'
>>> 'Python' and True
True
>>> 'Python' and False
False
```

문자열 'Python'도 불로 따지면 True라서 True and True가 되어 True가 나올 것 같지만 'Python'이 나왔습니다. 왜냐하면 파이썬에서 논리 연산자는 마지막으로 단락 평가를 실시한 값을 그대로 반환하기 때문입니다. 따라서 논리 연산자는 무조건 불을 반환하지 않습니다.

```python
>>> False and 'Python'
False
>>> 0 and 'Python'    # 0은 False이므로 and 연산자는 두 번째 값을 평가하지 않음
0
```

다음과 같이 and 연산자 앞에 False나 False로 치는 값이 와서 첫 번째 값 만으로 결과가 결정나는 경우에는 첫 번째 값이 반환됩니다.

```python
>>> True or 'Python'
True
>>> 'Python' or True
'Python'
>>> False or 'Python'
'Python'
>>> 0 or False
False
```

## 문자열 사용하기

```python
>>> hello = '''Hello, world!
안녕하세요.
Python입니다.'''
>>> print(hello)
Hello, world!
안녕하세요.
Python입니다.
```

```python
>>> s = "Python isn't difficult"
>>> s
"Python isn't difficult"
>>> s = 'He said "Python is easy"'
>>> s
'He said "Python is easy"'
```

여러 줄로 된 문자열은 작은따옴표 안에 작은따옴표와 큰따옴표를 둘 다 넣을 수 있습니다. 또한, 큰따옴표 안에도 작은따옴표와 큰따옴표를 넣을 수 있습니다.

```python
>>> 'Python isn\'t difficult'
"Python isn't difficult"
```

문자열 안에 ', " 등의 특수 문자를 포함하기 위해 앞에 \를 붙이는 방법을 이스케이프(escape)라고 부릅니다.

## 리스트와 튜플 사용하기

지금까지 변수에는 값을 한 개씩만 저장했습니다.

```python
a = 10
b = 20
```

```python
a1 = 10
a2 = 20
# ... (생략)
a29 = 60
a30 = 40
```

이때는 리스트를 사용하면 편리합니다. 리스트는 말 그대로 목록이라는 뜻이며 값을 일렬로 늘어놓은 형태입니다.

변수에 값을 저장할 때 [] 대괄호로 묶어주면 리스트가 되며 각 값은 **,**(콤마)로 구분해줍니다.

```python
>>> a = [38, 21, 53, 62, 19]
>>> a
[38, 21, 53, 62, 19]
```

리스트에 저장된 각 값을 요소(element)라고 부릅니다.

리스트는 문자열, 정수, 실수, 불 등 모든 자료형을 저장할 수 있으며 자료형을 섞어서 저장해도 됩니다.

```python
>>> person = ['james', 17, 175.3, True]
>>> person
['james', 17, 175.3, True]
```

```python
>>> a = []
>>> a
[]
>>> b = list()
>>> b
[]
#빈 리스트 만들기
```

```python
>>> a = list(range(10))
>>> a
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

range는 연속된 숫자를 생성하는데 range에 10을 지정하면 0부터 9까지 숫자를 생성합니다. range는 시작하는 숫자와 끝나는 숫자를 지정할 수도 있습니다. 이때도 끝나는 숫자는 생성되는 숫자에 포함되지 않습니다. 즉, list에 range(5, 12)를 넣으면 5부터 11까지 들어있는 리스트가 생성됩니다.

```python
>>> b = list(range(5, 12))
>>> b
[5, 6, 7, 8, 9, 10, 11]
```

```python
>>> c = list(range(-4, 10, 2))
>>> c
[-4, -2, 0, 2, 4, 6, 8] # range(시작, 끝, 증가폭)

>>> d = list(range(10, 0, -1))
>>> d
[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
```

**튜플은 리스트처럼 요소를 일렬로 저장하지만, 안에 저장된 요소를 변경, 추가, 삭제를 할 수 없습니다.** 

변수에 값을 저장할 때 () 괄호로 묶어주면 튜플이 되며 각 값은 **,**(콤마)로 구분해줍니다. 또는, 괄호로 묶지 않고 값만 콤마로 구분해도 튜플이 됩니다.

```python
>>> a = (38, 21, 53, 62, 19)
>>> a
(38, 21, 53, 62, 19)
>>> a = 38, 21, 53, 62, 19
>>> a
(38, 21, 53, 62, 19)
>>> person = ('james', 17, 175.3, True)
>>> person
('james', 17, 175.3, True)
```

보통 튜플은 요소가 절대 변경되지 않고 유지되어야 할 때 사용합니다. 튜플을 만든 상태에서 요소를 변경하게 되면 에러가 발생하게 됩니다. 따라서 요소를 실수로 변경하는 상황을 방지할 수 있습니다.

```python
>>> (38)
38 #값 한 개를 괄호로 묶으면 튜플이 아니라 그냥 값이 됩니다.
>>> (38, )
(38,)
>>> 38,
(38,)
```

```python
>>> a = [1, 2, 3]
>>> tuple(a)
(1, 2, 3) # 튜플에 리스트를 넣으면 튜플 생성

>>> b = (4, 5, 6)
>>> list(b)
[4, 5, 6] # 리스트에 튜플을 넣으면 리스트 생성

```

```python
>>> list('Hello')
['H', 'e', 'l', 'l', 'o']
>>> tuple('Hello')
('H', 'e', 'l', 'l', 'o')
```

리스트와 튜플을 사용하면 변수 여러 개를 한 번에 만들 수 있습니다. 이때 변수의 개수와 리스트(튜플)의 요소 개수는 같아야 합니다.

```python
>>> a, b, c = [1, 2, 3]
>>> print(a, b, c)
1 2 3
>>> d, e, f = (4, 5, 6)
>>> print(d, e, f)
4 5 6
```

리스트와 튜플 변수로도 변수 여러 개를 만들 수 있습니다. 다음과 같이 리스트와 튜플의 요소를 변수 여러 개에 할당하는 것을 리스트 언패킹(list unpacking), 튜플 언패킹(tuple unpacking)이라고 합니다.

```python
>>> x = [1, 2, 3]
>>> a, b, c = x
>>> print(a, b, c)
1 2 3
>>> y = (4, 5, 6)
>>> d, e, f = y
>>> print(d, e, f)
4 5 6
```

input().split()은 리스트를 반환합니다. 그래서 리스트 언패킹 형식으로 입력 값을 변수 여러 개에 저장할 수 있었습니다.

```python
>>> input().split()
10 20
['10', '20']
>>> x = input().split()
10 20
>>> a, b = x         # a, b = input().split()과 같음
>>> print(a, b)
10 20
```

```python
a = [1, 2, 3]    # 리스트 패킹
b = (1, 2, 3)    # 튜플 패킹
c = 1, 2, 3      # 튜플 패킹
```

리스트 패킹(list packing)과 튜플 패킹(tuple packing)은 변수에 리스트 또는 튜플을 할당하는 과정을 뜻합니다.

## 시퀀스 자료형 활용하기

파이썬에서는 리스트, 튜플, range, 문자열처럼 값이 연속적으로 이어진 자료형을 시퀀스 자료형(sequence types)라고 부릅니다. 이 시퀀스 자료형 중에서 list, tuple, range, str을 주로 사용하며 bytes, bytearray라는 자료형도 있습니다.

시퀀스 자료형으로 만든 객체를 시퀀스 객체라고 하며, 시퀀스 객체에 들어있는 각 값을 요소(element)라고 부릅니다.

<img src="/Users/chihun/Desktop/011003.png" style="zoom:75%;" />

```python
>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> 30 in a
True
>>> 100 in a
False
```

시퀀스 객체에 in 연산자를 사용했을 때 특정 값이 있으면 True, 없으면 False가 나옵니다. 따라서 리스트 a에 30이 있으므로 True, 100이 없으므로 False가 나옵니다.

반대로 in 앞에 not을 붙이면 특정 값이 없는지 확인합니다.

```python
>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> 100 not in a
True
>>> 30 not in a
False
```

```python
>>> 43 in (38, 76, 43, 62, 19)
True
>>> 1 in range(10)
True
>>> 'P' in 'Hello, Python'
True
```

시퀀스 객체는 + 연산자를 사용하여 객체를 서로 연결하여 새 객체를 만들 수 있습니다.

```python
>>> a = [0, 10, 20, 30]
>>> b = [9, 8, 7, 6]
>>> a + b
[0, 10, 20, 30, 9, 8, 7, 6]
```

단, 시퀀스 자료형 중에서 range는 + 연산자로 객체를 연결할 수 없습니다.

```python
>>> range(0, 10) + range(10, 20)
Traceback (most recent call last):
  File "<pyshell#1>", line 1, in <module>
    range(0, 10) + range(10, 20)
TypeError: unsupported operand type(s) for +: 'range' and 'range' 
```

이때는 range를 리스트 또는 튜플로 만들어서 연결하면 됩니다.

```python
>>> list(range(0, 10)) + list(range(10, 20))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
>>> tuple(range(0, 10)) + tuple(range(10, 20))
(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19)
```

```python
>>> 'Hello, ' + 'world!'
'Hello, world!' # 문자열 연결

>>> 'Hello, ' + 10
Traceback (most recent call last):
  File "<pyshell#2>", line 1, in <module>
    'Hello, ' + 10
TypeError: Can't convert 'int' object to str implicitly 
  
>>> 'Hello, ' + str(10)      # str을 사용하여 정수를 문자열로 변환
'Hello, 10'
>>> 'Hello, ' + str(1.5)     # str을 사용하여 실수를 문자열로 변환
'Hello, 1.5'
```

 \* 연산자는 시퀀스 객체를 특정 횟수만큼 반복하여 새 시퀀스 객체를 만듭니다(0 또는 음수를 곱하면 빈 객체가 나오며 실수는 곱할 수 없습니다).

```python
>>> [0, 10, 20, 30] * 3
[0, 10, 20, 30, 0, 10, 20, 30, 0, 10, 20, 30]
```

```python
>>> range(0, 5, 2) * 3
Traceback (most recent call last):
  File "<pyshell#3>", line 1, in <module>
    range(0, 5, 2) * 3
TypeError: unsupported operand type(s) for *: 'range' and 'int'
    
>>> list(range(0, 5, 2)) * 3
[0, 2, 4, 0, 2, 4, 0, 2, 4]
>>> tuple(range(0, 5, 2)) * 3
(0, 2, 4, 0, 2, 4, 0, 2, 4)

>>> 'Hello, ' * 3
'Hello, Hello, Hello, '
```

시퀀스 객체의 요소의 개수(길이)를 구할 때는 len 함수를 사용합니다(len은 길이를 뜻하는 length에서 따왔습니다).

```python
>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> len(a)
10

>>> b = (38, 76, 43, 62, 19)
>>> len(b)
5

>>> len(range(0, 10, 2))
5 # 0,2,4,6,8

>>> hello = 'Hello, world!'
>>> len(hello)
13
```

시퀀스 객체의 각 요소는 순서가 정해져 있으며, 이 순서를 인덱스라고 부릅니다.

다음과 같이 시퀀스 객체에 [ ](대괄호)를 붙이고 [ ] 안에 각 요소의 인덱스를 지정하면 해당 요소에 접근할 수 있습니다.

```python
>>> a = [38, 21, 53, 62, 19]
>>> a[0]    # 리스트의 첫 번째(인덱스 0) 요소 출력
38
>>> a[2]    # 리스트의 세 번째(인덱스 2) 요소 출력
53
>>> a[4]    # 리스트의 다섯 번째(인덱스 4) 요소 출력
19

>>> r = range(0, 10, 2)
>>> r[2]        # range의 세 번째(인덱스 2) 요소 출력
4

>>> hello = 'Hello, world!'
>>> hello[7]    # 문자열의 여덟 번째(인덱스 7) 요소 출력
'w'
```

시퀀스 객체에서 [ ](대괄호)를 사용하면 실제로는 getitem 메서드를 호출하여 요소를 가져옵니다. 따라서 다음과 같이 getitem 메서드를 직접 호출하여 요소를 가져올 수도 있습니다.

시퀀스객체.getitem(인덱스)

```python
>>> a = [38, 21, 53, 62, 19]
>>> a.__getitem__(1)
21
```

```python
>>> a = [38, 21, 53, 62, 19]
>>> a[-1]   # 리스트의 뒤에서 첫 번째(인덱스 -1) 요소 출력
19
>>> a[-5]   # 리스트의 뒤에서 다섯 번째(인덱스 -5) 요소 출력
38
```

```python
>>> a = [38, 21, 53, 62, 19]
>>> a[5]    # 인덱스 5는 범위를 벗어났으므로 에러
Traceback (most recent call last):
  File "<pyshell#1>", line 1, in <module>
    a[5]
IndexError: list index out of range 
```

```python
>>> a = [38, 21, 53, 62, 19]
>>> a[len(a)]
Traceback (most recent call last):
  File "<pyshell#3>", line 1, in <module>
    a[len(a)]
IndexError: list index out of range #len(a)는 5이므로 인덱스가 범위를 벗어납니다. 이때는 len(a)에서 1을 빼주어야 인덱스가 범위를 벗어나지 않습니다.
  
>>> a[len(a) - 1]    # 마지막 요소(인덱스 4) 출력
19
```

시퀀스 객체는 [ ]로 요소에 접근한 뒤 =로 값을 할당합니다.

```python
>>> a = [0, 0, 0, 0, 0]    # 0이 5개 들어있는 리스트
>>> a[0] = 38
>>> a[1] = 21
>>> a[2] = 53
>>> a[3] = 62
>>> a[4] = 19
>>> a
[38, 21, 53, 62, 19]

>>> a[5] = 90
Traceback (most recent call last):
  File "<pyshell#4>", line 1, in <module>
    a[5] = 90
IndexError: list assignment index out of range  # 범위를 벗어난 인덱스는 오류
```

```python
>>> b = (0, 0, 0, 0, 0)
>>> b[0] = 38
Traceback (most recent call last):
  File "<pyshell#5>", line 1, in <module>
    b[0] = 38
TypeError: 'tuple' object does not support item assignment # 튜플은 변경 불가
  
>>> r = range(0, 10, 2)
>>> r[0] = 3
Traceback (most recent call last):
  File "<pyshell#6>", line 1, in <module>
    r[0] = 3
TypeError: 'range' object does not support item assignment 


>>> hello = 'Hello, world!'
>>> hello[0] = 'A'
Traceback (most recent call last):
  File "<pyshell#7>", line 1, in <module>
    hello[0] = 'A'
TypeError: 'str' object does not support item assignment  #range 와 문자열도 불가
```

**즉, 시퀀스 자료형 중에서 튜플, range, 문자열은 읽기 전용입니다.**

```python
>>> a = [38, 21, 53, 62, 19]
>>> del a[2]
>>> a
[38, 21, 62, 19]
```

요소 삭제는 다음과 같이 del 뒤에 삭제할 요소를 지정해주면 됩니다.

```python
>>> b = (38, 21, 53, 62, 19)
>>> del b[2]
Traceback (most recent call last):
  File "<pyshell#7>", line 1, in <module>
    del b[2]
TypeError: 'tuple' object doesn't support item deletion # 튜플 삭제 불가

>>> r = range(0, 10, 2)
>>> del r[2]
Traceback (most recent call last):
  File "<pyshell#8>", line 1, in <module>
    del r[2]
TypeError: 'range' object doesn't support item deletion 

  
>>> hello = 'Hello, world!'
>>> del hello[2]
Traceback (most recent call last):
  File "<pyshell#9>", line 1, in <module>
    del hello[2]
TypeError: 'str' object doesn't support item deletion # range, 문자열도 삭제 불가
```

시퀀스 자료형은 슬라이스라는 기능을 자주 사용합니다. 슬라이스(slice)는 무엇인가의 일부를 잘라낸다는 뜻인데, 시퀀스 슬라이스도 말 그대로 시퀀스 객체의 일부를 잘라냅니다.

```python
>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> a[0:4]     # 인덱스 0부터 3까지 잘라서 새 리스트를 만듦
[0, 10, 20, 30]

>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> a[1:1]    # 인덱스 1부터 0까지 잘라서 새 리스트를 만듦
[]
>>> a[1:2]    # 인덱스 1부터 1까지 잘라서 새 리스트를 만듦
[10]
```

[ ] 안에 시작 인덱스와 끝 인덱스를 지정하면 해당 범위의 리스트를 잘라서 가져올 수 있습니다. 여기서 주의할 점이 있는데, 끝 인덱스는 가져오려는 범위에 포함되지 않습니다. 따라서 끝 인덱스는 실제로 가져오려는 인덱스보다 1을 더 크게 지정해야 합니다.

슬라이스를 했을 때 실제로 가져오는 요소는 **시작 인덱스**부터 **끝 인덱스 - 1**까지입니다.

```python
>>> a[4:-1]    # 인덱스 4부터 -2까지 요소 5개를 가져옴
[40, 50, 60, 70, 80]
```

끝 인덱스는 가져오려는 인덱스보다 1을 더 크게 지정한다고 했으므로 실제로는 뒤에서 두 번째(인덱스 -2) 요소인 80까지만 가져옵니다(음수는 숫자가 작을 수록 큰 수입니다. 그래서 -1은 -2보다 1이 더 큽니다).

```python
>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> a[2:8:3]    # 인덱스 2부터 3씩 증가시키면서 인덱스 7까지 가져옴
[20, 50]
>>> a[2:9:3]    # 인덱스 2부터 3씩 증가시키면서 인덱스 8까지 가져옴
[20, 50, 80]

>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> a[:7]    # 리스트 처음부터 인덱스 6까지 가져옴
[0, 10, 20, 30, 40, 50, 60]

>>> a[7:]    # 인덱스 7부터 마지막 요소까지 가져옴
[70, 80, 90]

>>> a[:]     # 리스트 전체를 가져옴
[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]

>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> a[:7:2]    # 리스트의 처음부터 인덱스를 2씩 증가시키면서 인덱스 6까지 가져옴
[0, 20, 40, 60]

>>> a[::2]     # 리스트 전체에서 인덱스 0부터 2씩 증가시키면서 요소를 가져옴
[0, 20, 40, 60, 80]

>>> a[::]    # 리스트 전체를 가져옴
[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
```

```python
>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> a[5:1:-1]
[50, 40, 30, 20]
```

슬라이스를 사용할 때 인덱스 증가폭을 음수로 지정하면 요소를 뒤에서부터 가져올 수 있습니다. 다음은 리스트 a에서 인덱스 5부터 2까지 1씩 감소시키면서 요소를 가져옵니다.

여기서 주의할 점은 인덱스가 감소하므로 끝 인덱스보다 시작 인덱스를 더 크게 지정해야 한다는 점입니다. 즉, a[5:1:-1]과 같이 시작 인덱스부터 끝 인덱스까지 감소하도록 지정합니다. 그리고 끝 인덱스는 가져오려는 범위에 포함되지 않습니다

```python
>>> a[::-1]
[90, 80, 70, 60, 50, 40, 30, 20, 10, 0]
```

```python
>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> a[0:len(a)]    # 시작 인덱스에 0, 끝 인덱스에 len(a) 지정하여 리스트 전체를 가져옴
[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> a[:len(a)]     # 시작 인덱스 생략, 끝 인덱스에 len(a) 지정하여 리스트 전체를 가져옴
[0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
```

```python
>>> r = range(10)
>>> r
range(0, 10)
>>> r[4:7]     # 인덱스 4부터 6까지 숫자 3개를 생성하는 range 객체를 만듦
range(4, 7)
>>> r[4:]      # 인덱스 4부터 9까지 숫자 6개를 생성하는 range 객체를 만듦
range(4, 10)
>>> r[:7:2]    # 인덱스 0부터 2씩 증가시키면서 인덱스 6까지 숫자 4개를 생성하는 range 객체를 만듦
range(0, 7, 2)
>>> list(r[:7:2])
[0, 2, 4, 6]
```

range는 리스트, 튜플과는 달리 요소가 모두 표시되지 않고 생성 범위만 표시됩니다.

```python
>>> hello = 'Hello, world!'
>>> hello[2:9]    # 인덱스 2부터 인덱스 8까지 잘라서 문자열을 만듦
'llo, wo'
>>> hello[2:]     # 인덱스 2부터 마지막 요소까지 잘라서 문자열을 만듦
'llo, world!'
>>> hello[:9:2]   # 문자열의 처음부터 인덱스를 2씩 증가시키면서 인덱스 8까지 잘라서 문자열을 만듦
'Hlo o'
```

파이썬에서는 slice 객체를 사용하여 시퀀스 객체(시퀀스 자료형으로 만든 변수)를 잘라낼 수도 있습니다.

슬라이스객체 = slice(끝인덱스)

슬라이스객체 = slice(시작인덱스, 끝인덱스)

슬라이스객체 = slice(시작인덱스, 끝인덱스, 인덱스증가폭)

시퀀스객체[슬라이스객체]

시퀀스객체.getitem(슬라이스객체)

```python
>>> range(10)[slice(4, 7, 2)]
range(4, 7, 2)
>>> range(10).__getitem__(slice(4, 7, 2))
range(4, 7, 2)
```

slice 객체를 하나만 만든 뒤 여러 시퀀스 객체에 사용하는 방법도 가능합니다.

```python
>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> s = slice(4, 7)    # 인덱스 4부터 6까지 자르는 slice 객체 생성
>>> a[s]
[40, 50, 60]
>>> r = range(10)
>>> r[s]
range(4, 7)
>>> hello = 'Hello, world!'
>>> hello[s]
'o, '
```

시퀀스객체[시작인덱스:끝인덱스] = 시퀀스객체

```python
>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> a[2:5] = ['a', 'b', 'c']    # 인덱스 2부터 4까지 값 할당
>>> a
[0, 10, 'a', 'b', 'c', 50, 60, 70, 80, 90]

>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> a[2:5] = ['a']    # 인덱스 2부터 4까지에 값 1개를 할당하여 요소의 개수가 줄어듦
>>> a
[0, 10, 'a', 50, 60, 70, 80, 90]

>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> a[2:5] = ['a', 'b', 'c', 'd', 'e'] # 인덱스 2부터 4까지 값 5개를 할당하여 요소의 개수가 늘어남
>>> a
[0, 10, 'a', 'b', 'c', 'd', 'e', 50, 60, 70, 80, 90]

>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> a[2:8:2] = ['a', 'b', 'c']    # 인덱스 2부터 2씩 증가시키면서 인덱스 7까지 값 할당
>>> a
[0, 10, 'a', 30, 'b', 50, 'c', 70, 80, 90]
```

이렇게 하면 인덱스 2부터 4까지 문자 'a', 'b', 'c'가 들어갑니다. 특히 이렇게 범위를 지정해서 요소를 할당했을 경우에는 원래 있던 리스트가 변경되며 새 리스트는 생성되지 않습니다.

단, 인덱스 증가폭을 지정했을 때는 슬라이스 범위의 요소 개수와 할당할 요소 개수가 정확히 일치해야 합니다.

튜플, range, 문자열은 슬라이스 범위를 지정하더라도 요소를 할당할 수 없습니다.

```python
>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> del a[2:5]    # 인덱스 2부터 4까지 요소를 삭제
>>> a
[0, 10, 50, 60, 70, 80, 90]

>>> a = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]
>>> del a[2:8:2]    # 인덱스 2부터 2씩 증가시키면서 인덱스 6까지 삭제
>>> a
[0, 10, 30, 50, 70, 80, 90]
```

del로 요소를 삭제하면 원래 있던 리스트가 변경되며 새 리스트는 생성되지 않습니다.

물론 튜플, range, 문자열은 del로 슬라이스를 삭제할 수 없습니다.

## 딕셔너리 사용하기

파이썬에서는 연관된 값을 묶어서 저장하는 용도로 딕셔너리라는 자료형을 제공합니다.

```python
happy = {'나이': 4, '다리': 4, '꼬리': 1,}
```

이처럼 딕셔너리는 값마다 이름을 붙여서 저장하는 방식입니다.

즉, 사전(dictionary)에서 단어를 찾듯이 값을 가져올 수 있다고 하여 딕셔너리라고 부릅니다.

딕셔너리는 **{ }**(중괄호) 안에 **키: 값** 형식으로 저장하며 각 키와 값은 **,**(콤마)로 구분해줍니다.

딕셔너리는 키를 먼저 지정하고 :(콜론)을 붙여서 값을 표현합니다. 특히 키에는 값을 하나만 지정할 수 있으며 이런 특성을 따서 키-값 쌍(key-value pair)이라 부릅니다(키-값은 1:1 대응).

```python
>>> lux = {'health': 490, 'health': 800, 'mana': 334, 'melee': 550, 'armor': 18.72}
>>> lux['health']    # 키가 중복되면 가장 뒤에 있는 값만 사용함
800
>>> lux    # 중복되는 키는 저장되지 않음
{'health': 800, 'mana': 334, 'melee': 550, 'armor': 18.72}
```

```python
>>> x = {100: 'hundred', False: 0, 3.5: [3.5, 3.5]}
>>> x
{100: 'hundred', False: 0, 3.5: [3.5, 3.5]}

```

딕셔너리의 키는 문자열뿐만 아니라 정수, 실수, 불도 사용할 수 있으며 자료형을 섞어서 사용해도 됩니다. 그리고 값에는 리스트, 딕셔너리 등을 포함하여 모든 자료형을 사용할 수 있습니다.

```python
>>> x = {[10, 20]: 100}
Traceback (most recent call last):
  File "<pyshell#3>", line 1, in <module>
    x = {[10, 20]: 100}
TypeError: unhashable type: 'list'
>>> x = {{'a': 10}: 100}
Traceback (most recent call last):
  File "<pyshell#4>", line 1, in <module>
    x = {{'a': 10}: 100}
TypeError: unhashable type: 'dict'
```

단, 키에는 리스트와 딕셔너리를 사용할 수 없습니다.

```python
>>> x = {}
>>> x
{}
>>> y = dict()
>>> y
{} # 빈 딕셔너리 만들기
```

dict는 다음과 같이 키와 값을 연결하거나, 리스트, 튜플, 딕셔너리로 딕셔너리를 만들 때 사용합니다.

딕셔너리 = dict(키1=값1, 키2=값2)

딕셔너리 = dict(zip([키1, 키2], [값1, 값2]))

딕셔너리 = dict([(키1, 값1), (키2, 값2)])

딕셔너리 = dict({키1: 값1, 키2: 값2})

```python
>>> lux1 = dict(health=490, mana=334, melee=550, armor=18.72)    # 키=값 형식으로 딕셔너리를 만듦
>>> lux1
{'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
```

```python
>>> lux2 = dict(zip(['health', 'mana', 'melee', 'armor'], [490, 334, 550, 18.72]))    # zip 함수로
>>> lux2                                                            # 키 리스트와 값 리스트를 묶음
{'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
```

```python
>>> lux3 = dict([('health', 490), ('mana', 334), ('melee', 550), ('armor', 18.72)])
>>> lux3                                                  # (키, 값) 형식의 튜플로 딕셔너리를 만듦
{'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72} 
```

```python
>>> lux4 = dict({'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72})     # dict 안에서
>>> lux4                                                           # 중괄호로 딕셔너리를 만듦
{'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
```

딕셔너리의 키에 접근할 때는 딕셔너리 뒤에 [ ](대괄호)를 사용하며 [ ] 안에 키를 지정해주면 됩니다.

```python
>>> lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
>>> lux['health']
490
>>> lux['armor']
18.72
```

딕셔너리는 [ ]로 키에 접근한 뒤 값을 할당합니다.

```python
>>> lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
>>> lux['health'] = 2037    # 키 'health'의 값을 2037로 변경
>>> lux['mana'] = 1184      # 키 'mana'의 값을 1184로 변경
>>> lux
{'health': 2037, 'mana': 1184, 'melee': 550, 'armor': 18.72}
```

딕셔너리는 없는 키에 값을 할당하면 해당 키가 추가되고 값이 할당됩니다.

```python
>>> lux['mana_regen'] = 3.28    # 키 'mana_regen'을 추가하고 값 3.28 할당
>>> lux
{'health': 2037, 'mana': 1184, 'melee': 550, 'armor': 18.72, 'mana_regen': 3.28}
```

딕셔너리는 없는 키에서 값을 가져오려고 하면 에러가 발생합니다.

딕셔너리에서 키가 있는지 확인하고 싶다면 in 연산자를 사용하면 됩니다.

```python
>>> lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
>>> 'health' in lux
True
>>> 'attack_speed' in lux
False

>>> 'attack_speed' not in lux
True
>>> 'health' not in lux
False
```

```python
>>> lux = {'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72}
>>> len(lux)
4
>>> len({'health': 490, 'mana': 334, 'melee': 550, 'armor': 18.72})
4 #키와 값은 1:1 관계이므로 키의 개수는 곧 값의 개수입니다
```

[참조]: https://dojang.io/course/view.php?id=7	"코딩도장"



