---
layout: single
tags: 
 - python

toc: true
toc_sticky: true

title: "[python] 코딩도장 04"
---

{% raw %}


## 딕셔너리 응용하기

setdefault: 키-값 쌍 추가

update: 키의 값 수정, 키가 없으면 키-값 쌍 추가

```python
>>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
>>> x.setdefault('e')
>>> x
{'a': 10, 'b': 20, 'c': 30, 'd': 40, 'e': None}
```

**setdefault(키)**는 딕셔너리에 키-값 쌍을 추가합니다. setdefault에 키만 지정하면 값에 None을 저장합니다. 다음은 키 'e'를 추가하고 값에 None을 저장합니다.

```python
>>> x.setdefault('f', 100)
100
>>> x
{'a': 10, 'b': 20, 'c': 30, 'd': 40, 'e': None, 'f': 100}
```

**setdefault(키, 기본값)**처럼 키와 기본값을 지정하면 값에 기본값을 저장한 뒤 해당 값을 반환합니다. 다음은 키 'f'를 추가하고 값에 100을 저장한 뒤 100을 반환합니다.

**update(키=값)**은 이름 그대로 딕셔너리에서 키의 값을 수정합니다. 예를 들어 딕셔너리가 x = {'a': 10}이라면 x.update(a=90)과 같이 키에서 작은따옴표 또는 큰따옴표를 빼고 키 이름과 값을 지정합니다.

```python
>>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
>>> x.update(a=90)
>>> x
{'a': 90, 'b': 20, 'c': 30, 'd': 40}

>>> x.update(e=50)
>>> x
{'a': 90, 'b': 20, 'c': 30, 'd': 40, 'e': 50} # 만약 딕셔너리에 키가 없으면 키-값 쌍을 추가합니다. 딕셔너리 x에는 키 'e'가 없으므로 x.update(e=50)을 실행하면 'e': 50을 추가합니다.

>>> x.update(a=900, f=60)
>>> x
{'a': 900, 'b': 20, 'c': 30, 'd': 40, 'e': 50, 'f': 60} # 키가 있으면 해당 키의 값을 수정하고 없으면 키-값 쌍을 추가합니다. 다음은 키 'a'의 값을 900으로 수정하고, 'f': 60을 추가합니다.
```

update(키=값)은 키가 문자열일 때만 사용할 수 있습니다. 만약 키가 숫자일 경우에는 **update(딕셔너리)**처럼 딕셔너리를 넣어서 값을 수정할 수 있습니다.

```python
>>> y = {1: 'one', 2: 'two'}
>>> y.update({1: 'ONE', 3: 'THREE'})
>>> y
{1: 'ONE', 2: 'two', 3: 'THREE'}

>>> y.update([[2, 'TWO'], [4, 'FOUR']])
>>> y
{1: 'ONE', 2: 'TWO', 3: 'THREE', 4: 'FOUR'}

>>> y.update(zip([1, 2], ['one', 'two']))
>>> y
{1: 'one', 2: 'two', 3: 'THREE', 4: 'FOUR'}
```

setdefault는 키-값 쌍 추가만 할 수 있고, 이미 들어있는 키의 값은 수정할 수 없습니다. 하지만 update는 키-값 쌍 추가와 값 수정이 모두 가능합니다. 다음과 같이 setdefault로 이미 들어있는 키 'a'를 90으로 저장해도 'a'의 값은 바뀌지 않습니다.

```python
>>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
>>> x.setdefault('a', 90)
10
>>> x
{'a': 10, 'b': 20, 'c': 30, 'd': 40}
```

**pop(키)**는 딕셔너리에서 특정 키-값 쌍을 삭제한 뒤 삭제한 값을 반환합니다. 다음은 딕셔너리 x에서 키 'a'를 삭제한 뒤 10을 반환합니다.

```python
>>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
>>> x.pop('a')
10
>>> x
{'b': 20, 'c': 30, 'd': 40}

>>> x.pop('z', 0)
0 # pop(키, 기본값)처럼 기본값을 지정하면 딕셔너리에 키가 있을 때는 해당 키-값 쌍을 삭제한 뒤 삭제한 값을 반환하지만 키가 없을 때는 기본값만 반환합니다. 딕셔너리 x에는 키 'z'가 없으므로 기본값으로 지정한 0을 반환합니다.
```

pop 대신 del로 특정 키-값 쌍을 삭제할 수도 있습니다. 이때는 [ ]에 키를 지정하여 del을 사용합니다. 다음은 딕셔너리 x의 키 'a'를 삭제합니다.

```python
>>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
>>> del x['a']
>>> x
{'b': 20, 'c': 30, 'd': 40}
```

**popitem()**은 딕셔너리에서 임의의 키-값 쌍을 삭제한 뒤 삭제한 키-값 쌍을 튜플로 반환합니다. 이 메서드는 파이썬 버전에 따라 동작이 달라지는데, 파이썬 3.6 이상에서는 마지막 키-값 쌍을 삭제하며 3.5 이하에서는 임의의 키-값 쌍을 삭제합니다.

```python
>>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
>>> x.popitem()
('d', 40)
>>> x
{'a': 10, 'b': 20, 'c': 30} # 파이썬 3.6

>>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
>>> x.popitem()    # 파이썬 3.5 이하에서는 매번 삭제하는 키-값 쌍이 달라짐
('a', 10)
>>> x
{'b': 20, 'c': 30, 'd': 40}
```

**get(키)**는 딕셔너리에서 특정 키의 값을 가져옵니다. 다음은 딕셔너리 x에서 키 'a'의 값을 가져옵니다.

```python
>>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
>>> x.get('a')
10

>>> x.get('z', 0)
0 # get(키, 기본값)처럼 기본값을 지정하면 딕셔너리에 키가 있을 때는 해당 키의 값을 반환하지만 키가 없을 때는 기본값을 반환합니다. 딕셔너리 x에는 키 'z'가 없으므로 기본값으로 지정한 0을 반환합니다.
```

items: 키-값 쌍을 모두 가져옴

keys: 키를 모두 가져옴

values: 값을 모두 가져옴

```python
>>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
>>> x.items()
dict_items([('a', 10), ('b', 20), ('c', 30), ('d', 40)])

>>> x.keys()
dict_keys(['a', 'b', 'c', 'd'])

>>> x.values()
dict_values([10, 20, 30, 40])
```

**dict.fromkeys(키리스트)**는 키 리스트로 딕셔너리를 생성하며 값은 모두 None으로 저장합니다. (튜플도 가능)

```python
>>> keys = ['a', 'b', 'c', 'd']
>>> x = dict.fromkeys(keys)
>>> x
{'a': None, 'b': None, 'c': None, 'd': None}

>>> y = dict.fromkeys(keys, 100)
>>> y
{'a': 100, 'b': 100, 'c': 100, 'd': 100}
```

```python
>>> x = {'a': 0, 'b': 0, 'c': 0, 'd': 0}
>>> x['z']    # 키 'z'는 없음
Traceback (most recent call last):
  File "<pyshell#5>", line 1, in <module>
    x['z']
KeyError: 'z'

>>> from collections import defaultdict    # collections 모듈에서 defaultdict를 가져옴
>>> y = defaultdict(int)    # int로 기본값 생성

>>> y['z']
0

>>> int()
0 # int는 실수나 문자열을 정수로 변환하지만, 다음과 같이 int에 아무것도 넣지 않고 호출하면 0을 반환합니다.

>>> z = defaultdict(lambda: 'python')
>>> z['a']
'python'
>>> z[0]
'python'
```

```python
>>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
>>> for i in x:
...     print(i, end=' ')
...
a b c d
```

for i in x:처럼 for 반복문에 딕셔너리를 지정한 뒤에 print로 변수 i를 출력해보면 값은 출력되지 않고 키만 출력됩니다. 

```python
for 키, 값 in 딕셔너리.items():
     반복할 코드
     
>>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
>>> for key, value in x.items():
...     print(key, value)
...
a 10
b 20
c 30
d 40
```

for key, value in x.items():는 딕셔너리 x에서 키-값 쌍을 꺼내서 키는 key에 값은 value에 저장하고, 꺼낼 때마다 코드를 반복합니다. 따라서 print로 key와 value를 출력하면 키-값 쌍을 모두 출력할 수 있습니다.

```python
>>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
>>> for key in x.keys():
...     print(key, end=' ')
...
a b c d # key만 가져오기

>>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
>>> for value in x.values():
...     print(value, end=' ')
...
10 20 30 40 # 값만 가져오기
```

```python
>>> keys = ['a', 'b', 'c', 'd']
>>> x = {key: value for key, value in dict.fromkeys(keys).items()}
>>> x
{'a': None, 'b': None, 'c': None, 'd': None}

>>> {key: 0 for key in dict.fromkeys(['a', 'b', 'c', 'd']).keys()}               # 키만 가져옴
{'a': 0, 'b': 0, 'c': 0, 'd': 0}
>>> {value: 0 for value in {'a': 10, 'b': 20, 'c': 30, 'd': 40}.values()}        # 값을 키로 사용
{10: 0, 20: 0, 30: 0, 40: 0}

>>> {value: key for key, value in {'a': 10, 'b': 20, 'c': 30, 'd': 40}.items()}  # 키-값 자리를 바꿈
{10: 'a', 20: 'b', 30: 'c', 40: 'd'}
```

딕셔너리 표현식은 딕셔너리에서 특정 값을 찾아서 삭제할 때 유용합니다. 딕셔너리는 특정 키를 삭제하는 pop 메서드만 제공할 뿐 특정 값을 삭제하는 메서드는 제공하지 않습니다. 

```python
x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
 
for key, value in x.items():
    if value == 20:    # 값이 20이면
        del x[key]     # 키-값 쌍 삭제
 
print(x)

Traceback (most recent call last):
  File "C:\project\dict_del_by_value_error.py", line 3, in <module>
    for key, value in x.items():
RuntimeError: dictionary changed size during iteration # 딕셔너리는 for 반복문으로 반복하면서 키-값 쌍을 삭제하면 안 됩니다.
```

이때는 딕셔너리 표현식에서 if 조건문을 사용하여 삭제할 값을 제외하면 됩니다.

```python
>>> x = {'a': 10, 'b': 20, 'c': 30, 'd': 40}
>>> x = {key: value for key, value in x.items() if value != 20}
>>> x
{'a': 10, 'c': 30, 'd': 40}
```

딕셔너리 표현식에서 if value != 20과 같이 if 조건문을 지정하면 값이 20이 아닌 키-값 쌍으로 다시 딕셔너리를 만듭니다. 직접 키-값 쌍을 삭제하는 방식이 아니라 삭제할 키-값 쌍을 제외하고 남은 키-값 쌍으로 딕셔너리를 새로 만드는 것입니다.

**딕셔너리 = {키1: {키A: 값A}, 키2: {키B: 값B}}**

```python
terrestrial_planet = {
    'Mercury': {
        'mean_radius': 2439.7,
        'mass': 3.3022E+23,
        'orbital_period': 87.969
    },
    'Venus': {
        'mean_radius': 6051.8,
        'mass': 4.8676E+24,
        'orbital_period': 224.70069,
    },
    'Earth': {
        'mean_radius': 6371.0,
        'mass': 5.97219E+24,
        'orbital_period': 365.25641,
    },
    'Mars': {
        'mean_radius': 3389.5,
        'mass': 6.4185E+23,
        'orbital_period': 686.9600,
    }
}
 
print(terrestrial_planet['Venus']['mean_radius'])    # 6051.8

#6051.8
```

딕셔너리 안에 들어있는 딕셔너리에 접근하려면 딕셔너리 뒤에 [ ](대괄호)를 단계만큼 붙이고 키를 지정해주면 됩니다.

```python
>>> x = {'a': 0, 'b': 0, 'c': 0, 'd': 0}
>>> y = x.copy()

>>> x is y
False
>>> x == y
True

>>> y['a'] = 99
>>> x
{'a': 0, 'b': 0, 'c': 0, 'd': 0}
>>> y
{'a': 99, 'b': 0, 'c': 0, 'd': 0}

>>> x = {'a': {'python': '2.7'}, 'b': {'python': '3.6'}}
>>> import copy             # copy 모듈을 가져옴
>>> y = copy.deepcopy(x)    # copy.deepcopy 함수를 사용하여 깊은 복사
>>> y['a']['python'] = '2.7.15'
>>> x
{'a': {'python': '2.7'}, 'b': {'python': '3.6'}}
>>> y
{'a': {'python': '2.7.15'}, 'b': {'python': '3.6'}} # 중첩 딕셔너리를 완전히 복사하려면 copy 메서드 대신 copy 모듈의 deepcopy 함수를 사용해야 합니다.
```

## 세트 사용하기

파이썬은 집합을 표현하는 세트(set)라는 자료형을 제공합니다. 집합을 영어로 하면 세트인데 수학에서 배우는 그 집합이 맞습니다. 따라서 세트는 합집합, 교집합, 차집합 등의 연산이 가능합니다.

세트는 **{ }**(중괄호) 안에 값을 저장하며 각 값은 **,**(콤마)로 구분해줍니다.

**세트 = {값1, 값2, 값3}**

```python
>>> fruits = {'strawberry', 'grape', 'orange', 'pineapple', 'cherry'}
>>> fruits
{'pineapple', 'orange', 'grape', 'strawberry', 'cherry'}

>>> fruits = {'orange', 'orange', 'cherry'}
>>> fruits
{'cherry', 'orange'}
```

세트는 요소의 순서가 정해져 있지 않습니다(unordered). 따라서 세트를 출력해보면 매번 요소의 순서가 다르게 나옵니다.

또한, 세트에 들어가는 요소는 중복될 수 없습니다.

특히 세트는 리스트, 튜플, 딕셔너리와는 달리 [ ]로 특정 요소만 출력할 수는 없습니다.

```python
>>> fruits = {'strawberry', 'grape', 'orange', 'pineapple', 'cherry'}
>>> print(fruits[0])
Traceback (most recent call last):
  File "<pyshell#42>", line 1, in <module>
    print(fruits[0])
TypeError: 'set' object does not support indexing
>>> fruits['strawberry']
Traceback (most recent call last):
  File "<pyshell#43>", line 1, in <module>
    fruits['strawberry']
TypeError: 'set' object is not subscriptable
```

```python
>>> fruits = {'strawberry', 'grape', 'orange', 'pineapple', 'cherry'}
>>> 'orange' in fruits
True
>>> 'peach' in fruits
False

>>> 'peach' not in fruits
True
>>> 'orange' not in fruits
False
```

**set(반복가능한객체)**

```python
>>> a = set('apple')    # 유일한 문자만 세트로 만듦
>>> a
{'e', 'l', 'a', 'p'}

>>> b = set(range(5))
>>> b
{0, 1, 2, 3, 4}

>>> c = set()
>>> c
set()

# 단, 세트가 { }를 사용한다고 해서 c = {}와 같이 만들면 빈 딕셔너리가 만들어지므로 주의해야 합니다.

>>> c = {}
>>> type(c)
<class 'dict'>
>>> c = set()
>>> type(c)
<class 'set'>
```

세트는 리스트, 딕셔너리와 달리 세트 안에 세트를 넣을 수 없습니다.

```python
>>> a = {{1, 2}, {3, 4}}
Traceback (most recent call last):
  File "<pyshell#3>", line 1, in <module>
    a = {{1, 2}, {3, 4}}
TypeError: unhashable type: 'set'
```

**프로즌세트 = frozenset(반복가능한객체)**

frozenset는 집합 연산과 메서드에서 요소를 추가하거나 삭제하는 연산, 메서드는 사용할 수 없습니다. 즉, 다음과 같이 frozenset의 요소를 변경하려고 하면 에러가 발생합니다.

```python
>>> a = frozenset(range(10))
>>> a |= 10
Traceback (most recent call last):
  File "<pyshell#4>", line 1, in <module>
    a |= 10
TypeError: unsupported operand type(s) for |=: 'frozenset' and 'int'
>>> a.update({10})
Traceback (most recent call last):
  File "<pyshell#5>", line 1, in <module>
    a.update({10})
AttributeError: 'frozenset' object has no attribute 'update'
```

frozenset는 세트 안에 세트를 넣고 싶을 때 사용합니다. 다음과 같이 frozenset는 frozenset를 중첩해서 넣을 수 있습니다. 단, frozenset만 넣을 수 있고, 일반 set는 넣을 수 없습니다.

```python
>>> frozenset({frozenset({1, 2}), frozenset({3, 4})})
frozenset({frozenset({1, 2}), frozenset({3, 4})})
```

| 연산자는 합집합(union)을 구하며 OR 연산자 |를 사용합니다. set.union 메서드와 동작이 같습니다.

```python
>>> a = {1, 2, 3, 4}
>>> b = {3, 4, 5, 6}
>>> a | b
{1, 2, 3, 4, 5, 6}
>>> set.union(a, b)
{1, 2, 3, 4, 5, 6}
```

& 연산자는 교집합(intersection)을 구하며 AND 연산자 &를 사용합니다. set.intersection 메서드와 동작이 같습니다.

```python
>>> a & b
{3, 4}
>>> set.intersection(a, b)
{3, 4}
```

\- 연산자는 차집합(difference)을 구하며 뺄셈 연산자 -를 사용합니다. set.difference 메서드와 동작이 같습니다. 

```python
>>> a - b
{1, 2}
>>> set.difference(a, b)
{1, 2}
```

^ 연산자는 대칭차집합(symmetric difference)을 구하며 XOR 연산자 ^를 사용합니다. set.symmetric_difference 메서드와 동작이 같습니다.

```python
>>> a ^ b
{1, 2, 5, 6}
>>> set.symmetric_difference(a, b)
{1, 2, 5, 6}
```

대칭차집합은 XOR 연산자의 특성을 그대로 따르는데 XOR은 서로 다르면 참입니다. 따라서 집합에서는 두 집합 중 겹치지 않는 요소만 포함합니다. 다음은 세트 {1, 2, 3, 4}와 {3, 4, 5, 6} 중에서 같은 값 3과 4를 제외한 다른 모든 요소를 구하므로 {1, 2, 5, 6}이 나옵니다.

세트 자료형에 |, &, -, ^ 연산자와 할당 연산자 =을 함께 사용하면 집합 연산의 결과를 변수에 다시 저장(할당)합니다.

```python
>>> a = {1, 2, 3, 4}
>>> a |= {5}
>>> a
{1, 2, 3, 4, 5}
>>> a = {1, 2, 3, 4}
>>> a.update({5})
>>> a
{1, 2, 3, 4, 5}
```

|=은 현재 세트에 다른 세트를 더하며 update 메서드와 같습니다.

```python
>>> a = {1, 2, 3, 4}
>>> a |= {5}
>>> a
{1, 2, 3, 4, 5}
>>> a = {1, 2, 3, 4}
>>> a.update({5})
>>> a
{1, 2, 3, 4, 5}
```

&=은 현재 세트와 다른 세트 중에서 겹치는 요소만 현재 세트에 저장하며 intersection_update 메서드와 같습니다. 

```python
>>> a = {1, 2, 3, 4}
>>> a &= {0, 1, 2, 3, 4}
>>> a
{1, 2, 3, 4}
>>> a = {1, 2, 3, 4}
>>> a.intersection_update({0, 1, 2, 3, 4})
>>> a
{1, 2, 3, 4}
```

-=은 현재 세트에서 다른 세트를 빼며 difference_update 메서드와 같습니다. 

```python
>>> a = {1, 2, 3, 4}
>>> a -= {3}
>>> a
{1, 2, 4}
>>> a = {1, 2, 3, 4}
>>> a.difference_update({3})
>>> a
{1, 2, 4}
```

^=은 현재 세트와 다른 세트 중에서 겹치지 않는 요소만 현재 세트에 저장하며 symmetric_difference_update 메서드와 같습니다. 

```python
>>> a = {1, 2, 3, 4}
>>> a ^= {3, 4, 5, 6}
>>> a
{1, 2, 5, 6}
>>> a = {1, 2, 3, 4}
>>> a.symmetric_difference_update({3, 4, 5, 6})
>>> a
{1, 2, 5, 6}
```

<=은 현재 세트가 다른 세트의 부분집합(subset)인지 확인하며 issubset 메서드와 같습니다.

**현재세트 <= 다른세트**

**현재세트.issubset(다른세트)**

```python
>>> a = {1, 2, 3, 4}
>>> a <= {1, 2, 3, 4}
True
>>> a.issubset({1, 2, 3, 4, 5})
True
```

<은 현재 세트가 다른 세트의 진부분집합(proper subset)인지 확인하며 메서드는 없습니다. 즉, 부분집합이지만 같지는 않을 때 참입니다.

**현재세트 < 다른세트**

```python
>>> a = {1, 2, 3, 4}
>>> a < {1, 2, 3, 4, 5}
True
```

\>=은 현재 세트가 다른 세트의 상위집합(superset)인지 확인하며 issuperset 메서드와 같습니다.

**현재세트 >= 다른세트**

**현재세트.issuperset(다른세트)**

```
>>> a = {1, 2, 3, 4}
>>> a >= {1, 2, 3, 4}
True
>>> a.issuperset({1, 2, 3, 4})
True
```

\>은 현재 세트가 다른 세트의 진상위집합(proper superset)인지 확인하며 메서드는 없습니다. 즉, 상위집합이지만 같지는 않을 때 참입니다.

**현재세트 > 다른세트**

```python
>>> a = {1, 2, 3, 4}
>>> a > {1, 2, 3}
True
```

```python
>>> a = {1, 2, 3, 4}
>>> a == {1, 2, 3, 4}
True
>>> a == {4, 2, 1, 3}
True

>>> a = {1, 2, 3, 4}
>>> a != {1, 2, 3}
True
```

disjoint는 현재 세트가 다른 세트와 겹치지 않는지 확인합니다. 겹치는 요소가 없으면 True, 있으면 False입니다.

**현재세트.isdisjoint(다른세트)**

```python
>>> a = {1, 2, 3, 4}
>>> a.isdisjoint({5, 6, 7, 8})       # 겹치는 요소가 없음
True
>>> a.isdisjoint({3, 4, 5, 6})    # a와 3, 4가 겹침
False
```

**add(요소)**는 세트에 요소를 추가합니다.

```python
>>> a = {1, 2, 3, 4}
>>> a.add(5)
>>> a
{1, 2, 3, 4, 5}
```

**remove(요소)**는 세트에서 특정 요소를 삭제하고 요소가 없으면 에러를 발생시킵니다.

```python
>>> a.remove(3)
>>> a
{1, 2, 4, 5}
```

**discard(요소)**는 세트에서 특정 요소를 삭제하고 요소가 없으면 그냥 넘어갑니다. 다음은 세트 a에 2가 있으므로 2를 삭제하고, 3은 없으므로 그냥 넘어갑니다.

```python
>>> a.discard(2)
>>> a
{1, 4, 5}
>>> a.discard(3)
>>> a
{1, 4, 5}
```

**pop()**은 세트에서 임의의 요소를 삭제하고 해당 요소를 반환합니다. 만약 요소가 없으면 에러를 발생시킵니다.

```python
>>> a = {1, 2, 3, 4}
>>> a.pop()
1
>>> a
{2, 3, 4}
```

**clear()**는 세트에서 모든 요소를 삭제합니다.

```python
>>> a.clear()
>>> a
set()
```

**len(세트)**는 세트의 요소 개수(길이)를 구합니다.

```python
>>> a = {1, 2, 3, 4}
>>> len(a)
4
```

세트 a와 b를 완전히 두 개로 만들려면 copy 메서드로 모든 요소를 복사해야 합니다.

```python
>>> a = {1, 2, 3, 4}
>>> b = a.copy()
>>> b.add(5)
>>> a
{1, 2, 3, 4}
>>> b
{1, 2, 3, 4, 5}
```

```python
for 변수 in 세트:
     반복할 코드
     
>>> a = {1, 2, 3, 4}
>>> for i in a:
...     print(i)
...
1
2
3
4
```

for i in a:는 세트 a에서 요소를 꺼내서 i에 저장하고, 꺼낼 때마다 코드를 반복합니다. 따라서 print로 i를 출력하면 요소를 모두 출력할 수 있습니다. 단, 세트의 요소는 순서가 없으므로 출력할 때마다 순서가 달라집니다(숫자로만 이루어진 세트는 순서대로 출력됨).

**{식 for 변수 in 반복가능한객체}**

**set(식 for 변수 in 반복가능한객체)**

```python
>>> a = {i for i in 'apple'}
>>> a
{'l', 'p', 'e', 'a'}
```

{ } 또는 set() 안에 식, for, 변수, in, 반복 가능한 객체를 지정하여 세트를 생성합니다. 여기서는 반복 가능한 객체로 문자열 'apple'을 지정했습니다.

다음과 같이 문자열 'apple'에서 유일한 문자인 'a', 'p', 'l', 'e'만 변수 i에 꺼내고 최종적으로 i로 세트를 만듭니다. 즉, 문자열에서 중복된 문자는 세트에 포함되지 않습니다.

**{식 for 변수 in 세트 if 조건식}**

**set(식 for 변수 in 세트 if 조건식)**

```python
>>> a = {i for i in 'pineapple' if i not in 'apl'}
>>> a
{'e', 'i', 'n'}
```

{i for i in 'pineapple' if i not in 'apl'}은 문자열 'pineapple'에서 'a', 'p', 'l'을 제외한 문자들로 세트를 생성합니다. 

## **딕셔너리 메서드**

| 메서드                                                       | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| setdefault(키, 기본값)                                       | 딕셔너리에 키-값 쌍을 추가, 키만 지정하면 값에 None을 저장   |
| update(키=값)update(딕셔너리)update(리스트)update(튜플)update(반복가능한객체) | 딕셔너리에서 키의 값을 수정, 딕셔너리에 키가 없으면 키-값 쌍을 추가 |
| pop(키)pop(키, 기본값)                                       | 딕셔너리에서 특정 키-값 쌍을 삭제한 뒤 값을 반환, del 딕셔너리[키]와 같음기본값을 지정하면 키가 없을 때 기본 값을 반환 |
| popitem()                                                    | 딕셔너리에서 임의의 키-값 쌍을 삭제하고 해당 키-값 쌍을 튜플로 반환 |
| clear()                                                      | 딕셔너리의 모든 키-값 쌍을 삭제                              |
| get(키)get(키, 기본값)                                       | 딕셔너리에서 특정 키의 값을 가져옴기본값을 지정하면 키가 없을 때 기본값을 반환 |
| items()keys()      values()                                  | items는 딕셔너리의 키-값 쌍을 모두 가져옴keys는 딕셔너리의 키를 모두 가져옴values는 딕셔너리의 값을 모두 가져옴 |
| copy()                                                       | 딕셔너리를 복사하여 새 딕셔너리 생성                         |
| dict.fromkeys(키리스트)dict.fromkeys(키리스트, 값)           | 리스트(튜플)로 딕셔너리를 만듦, 키 리스트만 지정하면 값은 모두 None이 저장됨키 리스트와 값을 지정하면 해당 값이 딕셔너리의 값으로 저장됨 |

## **세트의 메서드와 집합 연산**

| 메서드                                 | 집합 연산자 | 설명                                                         |
| -------------------------------------- | ----------- | ------------------------------------------------------------ |
| set.union(세트1, 세트2)                | \|          | 두 세트의 합집합                                             |
| set.intersection(세트1, 세트2)         | &           | 두 세트의 교집합                                             |
| set.difference(세트1, 세트2)           | -           | 두 세트의 차집합                                             |
| set.symmetric_difference(세트1, 세트2) | ^           | 두 세트의 대칭차집합                                         |
| update(다른세트)                       | \|=         | 현재 세트에 다른 세트를 더함                                 |
| intersection_update(다른세트)          | &=          | 현재 세트와 다른 세트 중에서 겹치는 요소만 현재 세트에 저장  |
| difference_update(다른세트)            | -=          | 현재 세트에서 다른 세트를 뺌                                 |
| symmetric_difference_update(다른세트)  | ^=          | 현재 세트와 다른 세트 중에서 겹치지 않는 요소만 현재 세트에 저장 |
| issubset(다른세트)                     | <=          | 현재 세트가 다른 세트의 부분집합인지 확인                    |
|                                        | <           | 현재 세트가 다른 세트의 진부분집합인지 확인                  |
| issuperset(다른세트)                   | >=          | 현재 세트가 다른 세트의 상위집합인지 확인                    |
|                                        | >           | 현재 세트가 다른 세트의 진상위집합인지 확인                  |
| isdisjoint(다른세트)                   |             | 현재 세트가 다른 세트와 겹치지 않는지 확인                   |
| add(요소)                              |             | 세트에 요소를 추가                                           |
| remove(요소)                           |             | 세트에서 특정 요소를 삭제, 없으면 에러 발생                  |
| discard(요소)                          |             | 세트에서 특정 요소를 삭제, 요소가 없으면 그냥 넘어감         |
| pop()                                  |             | 세트에서 임의의 요소를 삭제하고 해당 요소를 반환             |
| clear()                                |             | 세트에서 모든 요소를 삭제                                    |
| copy()                                 |             | 세트를 복사하여 새로운 세트 생성                             |

## 파일 사용하기

파일에 문자열을 쓸 때는 open 함수로 파일을 열어서 파일 객체(file object)를 얻은 뒤에 write 메서드를 사용합니다.

```python
file = open('hello.txt', 'w')    # hello.txt 파일을 쓰기 모드(w)로 열기. 파일 객체 반환
file.write('Hello, world!')      # 파일에 문자열 저장
file.close()                     # 파일 객체 닫기
```

소스 코드를 실행하면 .py 파일이 있는 폴더에 hello.txt 파일이 생성됩니다. 메모장이나 기타 텍스트 편집기를 사용하여 hello.txt 파일을 열어보면 'Hello, world!' 문자열이 저장된 것을 볼 수 있습니다.

파일을 읽을 때도 open 함수로 파일을 열어서 파일 객체를 얻은 뒤 read 메서드로 파일의 내용을 읽습니다. 단, 이때는 파일 모드를 읽기 모드 'r'로 지정합니다.

```python
file = open('hello.txt', 'r')    # hello.txt 파일을 읽기 모드(r)로 열기. 파일 객체 반환
s = file.read()                  # 파일에서 문자열 읽기
print(s)                         # Hello, world!
file.close()                     # 파일 객체 닫기

# Hello, world!
```

```python
with open('hello.txt', 'r') as file:    # hello.txt 파일을 읽기 모드(r)로 열기
    s = file.read()                     # 파일에서 문자열 읽기
    print(s)                            # Hello, world!
```

 **with as**를 사용하면 파일을 사용한 뒤 자동으로 파일 객체를 닫아줍니다.

```python
with open('hello.txt', 'w') as file:    # hello.txt 파일을 쓰기 모드(w)로 열기
    for i in range(3):
        file.write('Hello, world! {0}\n'.format(i))
        
# Hello, world! 0
# Hello, world! 1
# Hello, world! 2
```

**파일객체.writelines(문자열리스트)**

```python
lines = ['안녕하세요.\n', '파이썬\n', '코딩 도장입니다.\n']
 
with open('hello.txt', 'w') as file:    # hello.txt 파일을 쓰기 모드(w)로 열기
    file.writelines(lines)
    
# 안녕하세요.
# 파이썬
# 코딩 도장입니다.
```

read는 파일의 내용을 읽어서 문자열로 가져오지만 readlines는 파일의 내용을 한 줄씩 리스트 형태로 가져옵니다..

**변수 = 파일객체.readlines()**

```python
with open('hello.txt', 'r') as file:    # hello.txt 파일을 읽기 모드(r)로 열기
    lines = file.readlines()
    print(lines)
    
# ['안녕하세요.\n', '파이썬\n', '코딩 도장입니다.\n']

with open('hello.txt', 'r') as file:    # hello.txt 파일을 읽기 모드(r)로 열기
    line = None    # 변수 line을 None으로 초기화
    while line != '':
        line = file.readline()
        print(line.strip('\n'))    # 파일에서 읽어온 문자열에서 \n 삭제하여 출력
        
# 안녕하세요.
# 파이썬
# 코딩 도장입니다.

with open('hello.txt', 'r') as file:    # hello.txt 파일을 읽기 모드(r)로 열기
    for line in file:    # for에 파일 객체를 지정하면 파일의 내용을 한 줄씩 읽어서 변수에 저장함
        print(line.strip('\n'))    # 파일에서 읽어온 문자열에서 \n 삭제하여 출력
        
# 안녕하세요.
# 파이썬
# 코딩 도장입니다.
```

```python
>>> file = open('hello.txt', 'r')
>>> a, b, c = file
>>> a, b, c
('안녕하세요.\n', '파이썬\n', '코딩 도장입니다.\n')
```

파일 객체는 이터레이터입니다. 따라서 변수 여러 개에 저장하는 언패킹(unpacking)도 가능합니다. 물론 a, b, c = file과 같이 사용하려면 hello.txt에는 문자열 3줄이 들어있어야 합니다. 즉, 할당할 변수의 개수와 파일에 저장된 문자열의 줄 수가 일치해야 합니다.

```python
import pickle
 
name = 'james'
age = 17
address = '서울시 서초구 반포동'
scores = {'korean': 90, 'english': 95, 'mathematics': 85, 'science': 82}
 
with open('james.p', 'wb') as file:    # james.p 파일을 바이너리 쓰기 모드(wb)로 열기
    pickle.dump(name, file)
    pickle.dump(age, file)
    pickle.dump(address, file)
    pickle.dump(scores, file)
```

소스 코드를 실행하면 .py 파일이 있는 폴더에 james.p 파일이 생성됩니다. 여기서는 확장자를 **p**ickle의 p를 사용했지만 다른 확장자를 사용해도 상관없습니다.

특히 pickle.dump로 객체(값)를 저장할 때는 open('james.p', 'wb')와 같이 파일 모드를 'wb'로 지정해야 합니다. b는 바이너리(binary)를 뜻하는데, 바이너리 파일은 컴퓨터가 처리하는 파일 형식입니다. 따라서 메모장 같은 텍스트 편집기로 열어도 사람이 알아보기 어렵습니다.

```python
import pickle
 
with open('james.p', 'rb') as file:    # james.p 파일을 바이너리 읽기 모드(rb)로 열기
    name = pickle.load(file)
    age = pickle.load(file)
    address = pickle.load(file)
    scores = pickle.load(file)
    print(name)
    print(age)
    print(address)
    print(scores)
    
# james
# 17
# 서울시 서초구 반포동
# {'korean': 90, 'english': 95, 'mathematics': 85, 'science': 82}
```

파일 모드는 조합에 따라 여러 종류가 있습니다. 읽기 'r', 쓰기 'w' 이외에 추가 'a', 배타적 생성 'x'도 있습니다. 추가 모드는 이미 있는 파일에서 끝에 새로운 내용을 추가할 때 사용하고, 배타적 생성 모드는 파일이 이미 있으면 에러(FileExistsError)를 발생시키고 없으면 파일을 만듭니다. 'x'는 베타적 생성(e**x**clusive creation)의 x입니다

또한, 파일의 형식도 함께 지정할 수 있는데, 텍스트 모드 't'와 바이너리 모드 'b'가 있습니다. 이 파일 형식과 읽기, 쓰기 모드를 조합한 텍스트 모드 'rt', 'wt'는 파일을 텍스트 모드로 엽니다. 특히 텍스트 모드는 생략할 수 있어서 그냥 'r', 'w'도 텍스트 모드입니다. 그리고 바이너리 모드 'rb', 'wb' 등은 피클링을 사용하거나 바이너리 데이터를 직접 저장할 때 사용합니다.

그다음에 '+'가 있는데 파일을 읽기/쓰기 모드로 엽니다. 이 모드는 'r+t', 'w+t', 'r+', 'w+', 'r+b', 'w+b' 등으로 조합할 수 있으며 읽기/쓰기 모드인 것은 같지만 파일 처리 방법이 조금씩 다릅니다.

## 회문 판별과 N-gram 만들기

회문은 유전자 염기서열 분석에서 많이 쓰고, N-gram은 빅 데이터 분석, 검색 엔진에서 많이 쓰입니다.

회문(palindrome)은 순서를 거꾸로 읽어도 제대로 읽은 것과 같은 단어와 문장을 말합니다.

```python
word = input('단어를 입력하세요: ')
 
is_palindrome = True                 # 회문 판별값을 저장할 변수, 초깃값은 True
for i in range(len(word) // 2):      # 0부터 문자열 길이의 절반만큼 반복
    if word[i] != word[-1 - i]:      # 왼쪽 문자와 오른쪽 문자를 비교하여 문자가 다르면
        is_palindrome = False        # 회문이 아님
        break
 
print(is_palindrome)                 # 회문 판별값 출력

# 단어를 입력하세요: level (입력)
# True

# 단어를 입력하세요: hello (입력)
# False
```

for 반복문의 i가 0부터 1씩 증가하므로 word[i]는 왼쪽에서 오른쪽으로 진행하고, word[-1 - i]는 오른쪽에서 왼쪽으로 진행합니다. 즉, 문자열의 마지막 문자는 word[-1]이므로 여기서 인덱스를 i만큼 계속 빼주면 오른쪽에서 왼쪽으로 진행합니다. 이 부분은 파이썬에서 음수 인덱스를 지정하면 뒤에서부터 요소에 접근할 수 있다는 점을 이용한 것입니다. 음수 -1에서 숫자를 빼면 -2, -3, -4처럼 되므로 i가 커질 수록 더 왼쪽으로 옵니다. 참고로 word[-1 - i]는 word[-(1 + i)]와 같이 숫자를 i만큼 증가시킨 뒤 음수로 바꾸는 방식으로도 표현할 수 있습니다.

```python
word = input('단어를 입력하세요: ')
 
print(word == word[::-1])    # 원래 문자열과 반대로 뒤집은 문자열을 비교
```

word[::-1]은 문자열 전체에서 인덱스를 1씩 감소시키면서 요소를 가져오므로 문자열을 반대로 뒤집습니다. 

```python
>>> word = 'level'
>>> list(word) == list(reversed(word))
True

>>> word = 'level'
>>> word == ''.join(reversed(word))
True
```

N-gram은 문자열에서 N개의 연속된 요소를 추출하는 방법입니다. 만약 'Hello'라는 문자열을 문자(글자) 단위 2-gram으로 추출하면 다음과 같이 됩니다.

```python
He
el
ll
lo
```

```python
text = 'Hello'
 
for i in range(len(text) - 1):             # 2-gram이므로 문자열의 끝에서 한 글자 앞까지만 반복함
    print(text[i], text[i + 1], sep='')    # 현재 문자와 그다음 문자 출력
```

만약 3-gram이라면 반복 횟수는 range(len(text) - 2))와 같이 되고, 문자열 끝에서 두 글자 앞까지 반복하면 됩니다. 문자열을 출력할 때는 print(text[i], text[i + 1], text[i + 2], sep='')가 됩니다. 여기서 문자열의 끝까지 반복하면 text[i + 1], text[i + 2]는 문자열의 범위를 벗어난 접근을 하게 되므로 주의해야 합니다.

```python
text = 'this is python script'
words = text.split()                 # 공백을 기준으로 문자열을 분리하여 리스트로 만듦
 
for i in range(len(words) - 1):      # 2-gram이므로 리스트의 마지막에서 요소 한 개 앞까지만 반복함
    print(words[i], words[i + 1])    # 현재 문자열과 그다음 문자열 출력
    
# this is
# is python
# python script
```

```python
text = 'hello'
 
two_gram = zip(text, text[1:])
for i in two_gram:
    print(i[0], i[1], sep='')
    
>>> text = 'hello'
>>> list(zip(text, text[1:]))
[('h', 'e'), ('e', 'l'), ('l', 'l'), ('l', 'o')]

>>> text = 'this is python script'
>>> words = text.split()
>>> list(zip(words, words[1:]))
[('this', 'is'), ('is', 'python'), ('python', 'script')]
```

```python
>>> text = 'hello'
>>> [text[i:] for i in range(3)]
['hello', 'ello', 'llo']

>>> list(zip(['hello', 'ello', 'llo']))
[('hello',), ('ello',), ('llo',)]

>>> list(zip(*['hello', 'ello', 'llo']))
[('h', 'e', 'l'), ('e', 'l', 'l'), ('l', 'l', 'o')]

>>> list(zip(*[text[i:] for i in range(3)]))
[('h', 'e', 'l'), ('e', 'l', 'l'), ('l', 'l', 'o')]
```

## 파일 모드 및 메서드

| 파일 모드 | 기능                   | 설명                                                         |
| --------- | ---------------------- | ------------------------------------------------------------ |
| 'r'       | 읽기 전용              | 파일을 읽기 전용으로 열기. 단, 파일이 반드시 있어야 하며 파일이 없으면 에러 발생 |
| 'w'       | 쓰기 전용              | 쓰기 전용으로 새 파일을 생성. 만약 파일이 있으면 내용을 덮어씀 |
| 'a'       | 추가                   | 파일을 열어 파일 끝에 값을 이어 씀. 만약 파일이 없으면 파일을 생성 |
| 'x'       | 배타적 생성(쓰기)      | 파일을 쓰기 모드로 생성. 파일이 이미 있으면 에러 발생        |
| 'r+'      | 읽기/쓰기              | 파일을 읽기/쓰기용으로 열기. 단, 파일이 반드시 있어야 하며 파일이 없으면 에러 발생 |
| 'w+'      | 읽기/쓰기              | 파일을 읽기/쓰기용으로 열기. 파일이 없으면 파일을 생성하고, 파일이 있으면 내용을 덮어씀 |
| 'a+'      | 추가(읽기/쓰기)        | 파일을 열어 파일 끝에 값을 이어 씀. 만약 파일이 없으면 파일을 생성. 읽기는 파일의 모든 구간에서 가능하지만, 쓰기는 파일의 끝에서만 가능함 |
| 'x+'      | 배타적 생성(읽기/쓰기) | 파일을 읽기/쓰기 모드로 생성. 파일이 이미 있으면 에러 발생   |
| t         | 텍스트 모드            | 파일을 읽거나 쓸 때 개행 문자 \n과 \r\n을 서로 변환t를 생략하면 텍스트 모드 |
| b         | 바이너리 모드          | 파일의 내용을 그대로 읽고, 값을 그대로 씀                    |

| 메서드                      | 설명                                                         |
| --------------------------- | ------------------------------------------------------------ |
| read()                      | 파일에서 문자열을 읽음                                       |
| write('문자열')             | 파일에 문자열을 씀                                           |
| readline()                  | 파일의 내용을 한 줄 읽음                                     |
| readlines()                 | 파일의 내용을 한 줄씩 리스트 형태로 가져옴                   |
| writelines(문자열리스트)    | 파일에 리스트의 문자열을 씀, 리스트의 각 문자열에는 \n을 붙여주어야 함 |
| pickle.load(파일객체)       | 파일에서 파이썬 객체를 읽음                                  |
| pickle.dump(객체, 파일객체) | 파이썬 객체를 파일에 저장                                    |

## 함수 사용하기

함수는 def에 함수 이름을 지정하고 **( )**(괄호)와 **:**(콜론)을 붙인 뒤 다음 줄에 원하는 코드를 작성합니다(함수의 이름을 짓는 방법은 변수와 같습니다). 이때 코드는 반드시 들여쓰기를 해야 합니다(들여쓰기 규칙은 if, for, while과 같습니다).  def는 정의하다(**def**ine)에서 따온 키워드입니다.

```python
def 함수이름():
     코드
     
>>> def hello():
...      print('Hello, world!')
... 

>>> hello()
Hello, world!


hello()         # hello 함수를 만들기 전에 함수를 먼저 호출
 
def hello():    # hello 함수를 만듦
    print('Hello, world!')
    
Traceback (most recent call last):
  File "C:\project\function.py", line 1, in <module>
    hello()    # hello 함수를 만들기 전에 함수를 먼저 호출
NameError: name 'hello' is not defined 
```

함수를 먼저 호출하면 함수가 정의(define)되지 않았다는 에러가 발생합니다. 왜냐하면 파이썬 코드는 위에서 아래로 순차적으로 실행되기 때문입니다. 반드시 함수를 먼저 만든 뒤에 함수를 호출해야 합니다.

```python
def hello():
    pass
```

내용이 없는 빈 함수를 만들 때는 코드 부분에 pass를 넣어줍니다.

함수에서 값을 받으려면 ( )(괄호) 안에 변수 이름을 지정해주면 됩니다. 특히 이 변수를 매개변수(parameter)라고 부릅니다.

```python
def 함수이름(매개변수1, 매개변수2):
    코드
    
>>> def add(a, b):
...     print(a + b)
...

>>> add(10, 20)
30
```

여기서 함수를 호출할 때 넣는 값을 인수(argument)라고 부릅니다. 즉, add(10, 20)에서 10과 20이 인수입니다.

```python
def add(a, b):
    """이 함수는 a와 b를 더한 뒤 결과를 반환하는 함수입니다."""
    return a + b
 
x = add(10, 20)       # 함수를 호출해도 독스트링은 출력되지 않음
print(x)
 
print(add.__doc__)    # 함수의 __doc__로 독스트링 출력

# 30
# 이 함수는 a와 b를 더한 뒤 결과를 반환하는 함수입니다.

# help에 함수를 넣으면 함수의 이름, 매개변수, 독스트링을 도움말 형태로 출력해줍니다.
>>> help(add)
Help on function add in module __main__:
 
add(a, b)
    이 함수는 a와 b를 더한 뒤 결과를 반환하는 함수입니다.
```

파이썬에서는 함수의 :(콜론) 바로 다음 줄에 """ """(큰따옴표 세 개)로 문자열을 입력하면 함수에 대한 설명을 넣을 수 있습니다. 이런 방식의 문자열을 독스트링(문서화 문자열, documentation strings, docstrings)이라고 합니다. 단, 독스트링의 윗줄에 다른 코드가 오면 안 됩니다.

함수 안에서 return을 사용하면 값을 함수 바깥으로 반환합니다(return에 값을 지정하지 않으면 None을 반환).

```python
def 함수이름(매개변수):
    return 반환값
    
>>> def add(a, b):
...     return a + b
...

>>> x = add(10, 20)
>>> x
30
```

return으로 반환하는 값은 반환값이라고 하며 함수를 호출해준 바깥에 결과를 알려주기 위해 사용합니다.

반환값은 변수에 저장하지 않고 바로 다른 함수에 넣을 수도 있습니다. 다음은 print에서 바로 add를 호출하여 결과를 출력합니다.

```python
>>> print(add(10, 20))
30
```

```python
>>> def one():
...     return 1
...
>>> x = one()
>>> x
1

# 함수를 만들 때 매개변수는 없지만 값만 반환하는 함수를 만들 수도 있습니다. 다음은 매개변수 없이 1만 반환합니다.

>>> def not_ten(a):
...     if a == 10:
...         return
...     print(a, '입니다.', sep='')
...
>>> not_ten(5)
5입니다.
>>> not_ten(10)
>>> 

# return은 값을 반환하는 기능뿐만 아니라 함수 중간에서 바로 빠져나오는 기능도 있습니다. 다음은 매개변수 a가 10이면 함수를 그냥 빠져나옵니다. 10을 넣으면 return으로 함수 중간에서 바로 빠져나오므로 그 아래에 있는 print는 실행하지 않습니다. 따라서 아무것도 출력되지 않습니다.
```

함수에서 값을 여러 개 반환할 때는 다음과 같이 return에 값이나 변수를 ,(콤마)로 구분해서 지정하면 됩니다.

```python
def 함수이름(매개변수):
    return 반환값1, 반환값2
    
>>> def add_sub(a, b):
...     return a + b, a - b
...

>>> x, y = add_sub(10, 20)
>>> x
30
>>> y
-10
```

return으로 값을 여러 개 반환하면 실제로는 튜플이 반환됩니다. 다음과 같이 add_sub의 결과를 변수 한 개에 저장해서 출력해보면 튜플이 반환되는 것을 볼 수 있습니다.

```python
>>> x = add_sub(10, 20)
>>> x
(30, -10)

>>> x, y = (30, -10)
>>> x
30
>>> y
-10 # 튜플이 변수 여러 개에 할당되는 특성을 이용한 것입니다(언패킹).
```

```python
def mul(a, b):
    c = a * b
    return c
 
def add(a, b):
    c = a + b
    print(c)
    d = mul(a, b)
    print(d)
 
x = 10
y = 20
add(x, y)

# 30
# 200
```

함수에 인수를 순서대로 넣는 방식을 위치 인수(positional argument)라고 합니다. 즉, 인수의 위치가 정해져 있습니다.

```python
>>> print(10, 20, 30)
10 20 30 # print에 10, 20, 30 순으로 넣었으므로 출력될 때도 10 20 30으로 출력됩니다.

>>> def print_numbers(a, b, c):
...     print(a)
...     print(b)
...     print(c)
...

>>> print_numbers(10, 20, 30)
10
20
30
```

인수를 순서대로 넣을 때는 리스트나 튜플을 사용할 수도 있습니다. 다음과 같이 리스트 또는 튜플 앞에 *(애스터리스크)를 붙여서 함수에 넣어주면 됩니다.

**함수(\*리스트)**

**함수(\*튜플)**

```python
>>> x = [10, 20, 30]
>>> print_numbers(*x)
10
20
30

# print_numbers에 10, 20, 30이 들어있는 리스트 x를 넣고 *만 붙였는데도 숫자가 각 줄에 출력되었습니다. 즉, 리스트(튜플) 앞에 *를 붙이면 언패킹(unpacking)이 되어서 print_numbers(10, 20, 30)과 똑같은 동작이 됩니다. 
```

함수의 매개변수 개수와 리스트의 요소 개수는 같아야 합니다. 만약 개수가 다르면 함수를 호출할 수 없습니다. 여기서는 함수를 def print_numbers(a, b, c):로 만들었으므로 리스트에는 요소를 3개 넣어야 합니다. 다음과 같이 요소가 두 개인 리스트를 넣으면 에러가 발생합니다.

```python
>>> print_numbers(*[10, 20])
Traceback (most recent call last):
  File "<pyshell#16>", line 1, in <module>
    print_numbers(*[10, 20])
TypeError: print_numbers() missing 1 required positional argument: 'c'
```

가변 인수 함수는 매개변수 앞에 *를 붙여서 만듭니다.

```python
def 함수이름(*매개변수):
    코드
    
>>> def print_numbers(*args):
...     for arg in args:
...         print(arg)
...

>>> print_numbers(10)
10
>>> print_numbers(10, 20, 30, 40)
10
20
30
40

>>> x = [10]
>>> print_numbers(*x)
10
>>> y = [10, 20, 30, 40]
>>> print_numbers(*y)
10
20
30
40
```

매개변수 이름은 원하는 대로 지어도 되지만 관례적으로 **arg**ument**s**를 줄여서 args로 사용합니다. 특히 이 args는 튜플이라서 for로 반복할 수 있습니다.

```python
>>> def print_numbers(a, *args):
...     print(a)
...     print(args)
...
>>> print_numbers(1)
1
()
>>> print_numbers(1, 10, 20)
1
(10, 20)
>>> print_numbers(*[10, 20, 30])
10
(20, 30)

# 이때 def print_numbers(*args, a):처럼 *args가 고정 매개변수보다 앞쪽에 오면 안 됩니다. 
# 매개변수 순서에서 *args는 반드시 가장 뒤쪽에 와야 합니다.
```

파이썬에서는 인수의 순서와 용도를 매번 기억하지 않도록 키워드 인수(keyword argument)라는 기능을 제공합니다. 키워드 인수는 말 그대로 인수에 이름(키워드)을 붙이는 기능인데 **키워드=값** 형식으로 사용합니다.

**함수(키워드=값)**

```python
>>> def personal_info(name, age, address):
...     print('이름: ', name)
...     print('나이: ', age)
...     print('주소: ', address)
...

>>> personal_info(name='홍길동', age=30, address='서울시 용산구 이촌동')
이름:  홍길동
나이:  30
주소:  서울시 용산구 이촌동

>>> personal_info(age=30, address='서울시 용산구 이촌동', name='홍길동')
이름:  홍길동
나이:  30
주소:  서울시 용산구 이촌동

print(10, 20, 30, sep=':', end='')
```

**함수(\**딕셔너리)**

```python
>>> def personal_info(name, age, address):
...     print('이름: ', name)
...     print('나이: ', age)
...     print('주소: ', address)
...

>>> x = {'name': '홍길동', 'age': 30, 'address': '서울시 용산구 이촌동'}
>>> personal_info(**x)
이름:  홍길동
나이:  30
주소:  서울시 용산구 이촌동 
```

이때 딕셔너리의 키워드(키)는 반드시 문자열 형태라야 합니다. **x처럼 딕셔너리를 언패킹하면 딕셔너리의 값들이 함수의 인수로 들어갑니다. 딕셔너리 언패킹을 사용할 때는 함수의 매개변수 이름과 딕셔너리의 키 이름이 같아야 합니다. 또한, 매개변수 개수와 딕셔너리 키의 개수도 같아야 합니다. 만약 이름과 개수가 다르면 함수를 호출할 수 없습니다.

```python
>>> personal_info(**{'name': '홍길동', 'old': 30, 'address':'서울시 용산구 이촌동'})
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: personal_info() got an unexpected keyword argument 'old'
>>> personal_info(**{'name': '홍길동', 'age': 30})
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: personal_info() missing 1 required positional argument: 'address'
```

```python
>>> x = {'name': '홍길동', 'age': 30, 'address': '서울시 용산구 이촌동'}
>>> personal_info(*x)
이름:  name
나이:  age
주소:  address # personal_info에 *x를 넣으면 x의 키가 출력됩니다. 즉, 딕셔너리를 한 번 언패킹하면 키를 사용한다는 뜻이 됩니다.
  
  >>> x = {'name': '홍길동', 'age': 30, 'address': '서울시 용산구 이촌동'}
>>> personal_info(**x)
이름:  홍길동
나이:  30
주소:  서울시 용산구 이촌동
```

키워드 인수를 사용하는 가변 인수 함수는 매개변수 앞에 **를 붙여서 만듭니다.

```python
def 함수이름(**매개변수):
    코드

>>> def personal_info(**kwargs):
...     for kw, arg in kwargs.items():
...         print(kw, ': ', arg, sep='')
...

>>> personal_info(name='홍길동')
name: 홍길동
>>> personal_info(name='홍길동', age=30, address='서울시 용산구 이촌동')
name: 홍길동
age: 30
address: 서울시 용산구 이촌동

>>> x = {'name': '홍길동'}
>>> personal_info(**x)
name: 홍길동
>>> y = {'name': '홍길동', 'age': 30, 'address': '서울시 용산구 이촌동'}
>>> personal_info(**y)
name: 홍길동
age: 30
address: 서울시 용산구 이촌동
  

def personal_info(**kwargs):
    if 'name' in kwargs:    # in으로 딕셔너리 안에 특정 키가 있는지 확인
        print('이름: ', kwargs['name'])
    if 'age' in kwargs:
        print('나이: ', kwargs['age'])
    if 'address' in kwargs:
        print('주소: ', kwargs['address'])
        

>>> def personal_info(name, **kwargs):
...     print(name)
...     print(kwargs)
...
>>> personal_info('홍길동')
홍길동
{}
>>> personal_info('홍길동', age=30, address='서울시 용산구 이촌동')
홍길동
{'age': 30, 'address': '서울시 용산구 이촌동'}
>>> personal_info(**{'name': '홍길동', 'age': 30, 'address': '서울시 용산구 이촌동'})
홍길동
{'age': 30, 'address': '서울시 용산구 이촌동'}
```

매개변수 이름은 원하는 대로 지어도 되지만 관례적으로 **k**ey**w**ord **arg**ument**s**를 줄여서 kwargs로 사용합니다. 특히 이 kwargs는 딕셔너리라서 for로 반복할 수 있습니다.

함수에서 위치 인수를 받는 *args와 키워드 인수를 받는 kwargs를 함께 사용할 수도 있습니다. 대표적인 함수가 print인데 print는 출력할 값을 위치 인수로 넣고 sep, end 등을 키워드 인수로 넣습니다. 다음과 같이 함수의 매개변수를 *args, **kwargs로 지정하면 위치 인수와 키워드 인수를 함께 사용합니다.

```python
>>> def custom_print(*args, **kwargs):
...     print(*args, **kwargs)
...
>>> custom_print(1, 2, 3, sep=':', end='')
1:2:3
```

매개변수 순서에서 kwargs는 반드시 가장 뒤쪽에 와야 합니다. 매개변수는 고정 매개변수, *args, **kwargs 순으로 지정해야 합니다.

인수를 생략하고 싶을 때는 초깃값을 지정하면 됩니다. 초깃값은 다음과 같이 함수를 만들 때 **매개변수=값** 형식으로 지정합니다.

```python
def 함수이름(매개변수=값):
    코드
    
>>> def personal_info(name, age, address='비공개'):
...     print('이름: ', name)
...     print('나이: ', age)
...     print('주소: ', address)
...

>>> personal_info('홍길동', 30)
이름:  홍길동
나이:  30
주소:  비공개

>>> personal_info('홍길동', 30, '서울시 용산구 이촌동')
이름:  홍길동
나이:  30
주소:  서울시 용산구 이촌동
```

매개변수의 초깃값은 주로 사용하는 값이 있으면서 가끔 다른 값을 사용해야 할 때 활용합니다. 대표적인 예가 print 함수인데, print 함수의 sep는 초깃값이 ' '(공백)으로 지정되어 있어서 대부분 그대로 사용하고, 가끔 sep에 다른 값을 넣어서 사용합니다.

**초깃값이 지정된 매개변수 다음에는 초깃값이 없는 매개변수가 올 수 없습니다.** 

```python
>>> def personal_info(name, address='비공개', age):
...     print('이름: ', name)
...     print('나이: ', age)
...     print('주소: ', address)
...
  File "<stdin>", line 1
SyntaxError: non-default argument follows default argument
```

함수를 이렇게 만들어버리면 personal_info('홍길동', 30)으로 함수를 호출했을 때 30이 어디로 들어가야 할지 알 수가 없기 때문입니다.

## 재귀호출 사용하기

함수 안에서 함수 자기자신을 호출하는 방식을 재귀호출(recursive call)이라고 합니다.

```python
def hello():
    print('Hello, world!')
    hello()
 
hello()


Hello, world!
Hello, world!
Hello, world!
...(생략)
Traceback (most recent call last):
  File "C:\project\recursive_function_error.py", line 5, in <module>
    hello()
  File "C:\project\recursive_function_error.py", line 3, in hello
    hello()
  File "C:\project\recursive_function_error.py", line 3, in hello
    hello()
  File "C:\project\recursive_function_error.py", line 3, in hello
    hello()
  [Previous line repeated 974 more times]
  File "C:\project\recursive_function_error.py", line 2, in hello
    print('Hello, world!')
RecursionError: maximum recursion depth exceeded while pickling an object 
```

hello 함수 안에서 다시 hello 함수를 호출하고 있습니다.

소스 코드를 실행해보면 'Hello, world!' 문자열이 계속 출력되다가 에러가 발생합니다. 왜냐하면 파이썬에서는 최대 재귀 깊이(maximum recursion depth)가 1,000으로 정해져 있어서 그렇습니다. 즉, hello 함수가 자기자신을 계속 호출하다가 최대 재귀 깊이를 초과하면 RecursionError가 발생합니다.

```python
def hello(count):
    if count == 0:    # 종료 조건을 만듦. count가 0이면 다시 hello 함수를 호출하지 않고 끝냄
        return
    
    print('Hello, world!', count)
    
    count -= 1      # count를 1 감소시킨 뒤
    hello(count)    # 다시 hello에 넣음
 
hello(5)    # hello 함수 호출

Hello, world! 5
Hello, world! 4
Hello, world! 3
Hello, world! 2
Hello, world! 1
```

```python
def factorial(n):
    if n == 1:      # n이 1일 때
        return 1    # 1을 반환하고 재귀호출을 끝냄
    return n * factorial(n - 1)    # n과 factorial 함수에 n - 1을 넣어서 반환된 값을 곱함
 
print(factorial(5))

# 120
```

먼저 factorial 함수를 만들 때 매개변수 n을 지정해줍니다. 팩토리얼은 1부터 n까지의 곱을 구하는 문제인데 여기서는 n부터 역순으로 1씩 감소하면서 재귀호출을 하고 n이 1이 되었을 때 재귀호출을 중단합니다. 계산 결과가 즉시 구해지는 것이 아니라 재귀호출로 n - 1을 계속 전달하다가 n이 1일 때 비로소 1을 반환하면서 n과 곱하고 다시 결괏값을 반환합니다. 그 뒤 n과 반환된 결괏값을 곱하여 다시 반환하는 과정을 반복합니다. if n == 1:을 만나서 factorial 함수가 1을 반환합니다. 그 뒤 1과 2를 곱해서 2를 반환하고, 3과 2를 곱해서 6을 반환하고, 4와 6을 곱해서 24를 반환하고, 5와 24를 곱해서 120을 반환하게 됩니다.

```python
def hello():
    print('Hello, world!')
 
x = hello    # 함수를 변수에 할당
x()          # Hello, world!: 변수에 들어있는 함수 호출
 
y = [hello, hello]    # 함수를 리스트에 넣음
y[0]()                # Hello, world!: 리스트에 들어있는 함수 호출
y[1]()                # Hello, world!: 리스트에 들어있는 함수 호출
```

함수는 변수에 할당하거나 리스트에 넣어서 호출할 수 있습니다. 단, ( )(괄호)를 붙이지 않고 함수를 그대로 넣어야 합니다. 만약, ()를 붙이면 반환값이 들어갑니다.

순수 함수(pure function)는 함수의 실행이 외부 상태에 영향을 끼치지 않는 함수를 뜻합니다. 따라서 순수 함수는 부수효과(side effect)가 없어야 하고 입력 값이 같으면 언제나 같은 출력 값을 반환합니다.

```python
def add(a, b):      # 함수 실행이 외부 상태에 영향을 끼치지 않음
    return a + b
 
print(add(1, 2))
```

반대로 비순수 함수(impure function)는 수정자 함수(modifier function)라고도 하는데 함수의 실행이 외부 상태에 영향을 끼치는 함수입니다.

```python
number_list = [1, 2, 3]
 
def append_number(n):        # 함수 실행이 외부 상태에 영향을 끼침
    number_list.append(n)    # 함수 외부에 있는 number_list의 상태가 바뀜
 
append_number(4)
```

출처 : https://dojang.io

{% endraw %}
