## 비밀번호 암호화

```python
import json
import bcrypt
import jwt

from my_settings import SECRET_KEY

from django.http            import JsonResponse
from django.views           import View
from django.core.exceptions import ValidationError

from users.validation       import validate_email, validate_password
from users.models           import User

# Create your views here.
class SignUp(View):
    def post(self, request):
        data = json.loads(request.body)
        try :
            name = data['name']
            email = data['email']
            password = data['password']
            phone_number = data['phone_number']

            validate_email(email)
            validate_password(password)
            
            if User.objects.filter(email = email).exists():
                return JsonResponse({'MESSAGE':'ALREADY_EXISTS_EMAIL'}, status=400)
            
            hashed_pw = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())
            decoded_hashed_pw = hashed_pw.decode('utf-8')
            
            User.objects.create(
                name = name,
                email = email,
                password = decoded_hashed_pw,
                phone_number = phone_number,
            )

            return JsonResponse({'MESSAGE':'SUCCESS'} , status = 201)

        except KeyError :
            return JsonResponse({'MESSAGE':"KEY_ERROR"}, status = 400)
        
        except ValidationError as e:
            return JsonResponse({'MESSAGE':(e.message)}, status=400)
```

```python
bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())
decoded_hashed_pw = hashed_pw.decode('utf-8')
```

먼저 새로 생성하는 이메일과 비밀번호를 정규표현식으로 검사하고 이미 있는 이메일이 아닌지 확인한다.

**bcrypt**는 Salting과 Key Stretching을 구현한 해쉬 함수이다. Key Stretching는 해쉬를 반복해서 추적을 어렵게 만드는 것이고 Salting은 랜덤한 데이터를 더해서 해쉬값을 계산한다. 

암호화 함수는 str 데이터가 아닌 Bytes 데이터를 암호화하기 때문에 비밀번호를 encode 해준다. 파이썬에서는 str을 encode하면 bytes(이진화) 되고, Bytes 를 decode하면 str화 된다.

encode된 binary text는 mysql DB에 들어갈 수 없기 때문에 해쉬값을 데이터베이스에 저장하기 위해 다시 decode 해준다. 

최종적으로 decode된 해쉬값을 비밀번호로 저장한다.

![](https://user-images.githubusercontent.com/61782539/133426937-e99b1557-0b94-4424-a71f-e5d506bf9c72.png)

![](https://user-images.githubusercontent.com/61782539/133427266-26146753-3bbe-418b-ac5c-92bffe6a86c4.png)



## 로그인 토큰 발행

```python
class SignIn(View):
    def post(self, request):
        data = json.loads(request.body)
        try :
            email = data['email']
            password = data['password']

            if User.objects.filter(email=email).exists() :
                user = User.objects.get(email=email)
                if bcrypt.checkpw(password.encode('utf-8'), user.password.encode('utf-8')) :
                    access_token = jwt.encode({'id' : user.id}, SECRET_KEY, 
                                              algorithm='HS256')
                    return JsonResponse({'access_token': access_token}, status=200)
            
                return JsonResponse({'MESSAGE':'INVALID_PASSWORD'}, status=401)

            return JsonResponse({'MESSAGE':'INVALID_USER_EMAIL'}, status=401)

            
        except KeyError :
            return JsonResponse({'MESSAGE':"KEY_ERROR"}, status = 400)
```

```python
if bcrypt.checkpw(password.encode('utf-8'), user.password.encode('utf-8')) :
                    access_token = jwt.encode({'id' : user.id}, SECRET_KEY, 
                                              algorithm='HS256')
                    return JsonResponse({'access_token': access_token}, status=200)
```

데이터베이스에 저장된 해당 유저의 비밀번호를 가져와서 encode 해주고 로그인을 위해 입력된 비밀번호도 encode 해준 다음checkpw를 통해 비교한다. 같으면 True를 반환하기 때문에 True일시 jwt를 통해 토큰을 만들고 반환해준다.

**jwt** :  Json 포맷을 이용하여 사용자에 대한 속성을 저장하는 Claim 기반의 Web Token이다.

JWT는 Header, Payload, Signature의 3 부분으로 이루어지며, Json 형태인 각 부분은 Base64로 인코딩 되어 표현된다. 또한 각각의 부분을 이어 주기 위해 **.** 구분자를 사용하여 구분한다. 추가로 Base64는 암호화된 문자열이 아니고, 같은 문자열에 대해 항상 같은 인코딩 문자열을 반환한다.

![JWT. JSON WEB TOKEN | by posibean | Medium](https://miro.medium.com/max/1400/1*XJJygmigKAWmcI3oZ-YL6A.png)

**헤더(Header)**

헤더는 JWT 토큰을 어떻게 해석해야 하는지를 알려주는 부분.

헤더는 다음 2가지 정보를 가진다.

typ : 토큰의 종류

alg : 해싱 알고리즘. 보통 HMAC SH256 혹은 RSA

**내용(Payload)**

name / value 쌍으로 이루어져 있습니다.

페이로드에 있는 속성들을 클레임 셋(Claim Set)이라고 부릅니다.

페이로드는 등록된 클레임(Registered claims), 공개 클래임(Public claims), 비공개 클래임(Private claims)으로 구분됩니다.

Payload 종류 1: 등록된 클레임(Registered Claim Names)

- ss(issuer): 토큰 발급자
- sub(subject): 토큰 제목
- aud(audience): 토큰 대상자
- exp(expiration): 토큰 만료 시간 - NumericDate 형식으로 작성되어야 합니다. ex) 1480849147370
- nbf(not before): 토큰 활성 날짜 - 이 날이 지나기 전에 토큰은 활성화되지 않습니다.
- iat(issued at): 토큰이 발급된 시간 - 토큰 발급 이후의 경과 시간을 알 수 있습니다.
- jti(JWT ID): JWT 토큰 식별자 - 중복 방지를 위해 사용하며, 일회용 토큰(Access Token) 등에 사용하면 유용.

Payload 종류 2: 공개 클래임(Public Claim)

- 사용자 정의 클레임으로 공개용 정보를 위해 사용된다. 충돌 방지를 위해 URI 포맷을 이용해야 한다.

  ```python
  {
    "https://tandohak.co.kr/is_authenticated": True
  }
  ```

Payload 종류 3: 비공개 클래임(Private Claim)

- 등록된 클레임도 아니며, 공개 클래임도 아닌 서버와 클라이언트 사이에 임의로 지정한 정보를 저장하기 위해 만들어진 사용자 지정 클레임입니다.

  ```python
  {
    "username": "tandohak"
  }
  ```

- 비공개 클래임을 조심해서 사용하지 않으면 등록된 클래임과 공개 클래임과 다르게 충돌이 일어날 수 있기에 주의해야 합니다.

**서명(Signature)**

- 헤더와 페이로드는 암호화 한 것이 아니라 단순히 JSON 문자열을 base64로 인코딩한 것입니다.
- 누구나 디코딩을 한다면 헤더와 페이로드의 내용을 볼 수 있습니다.
- 누군가 JWT를 탈취하여 수정한 후 서버로 보낼 수 있습니다. 이 경우에 대비해 다른 사람이 위변조 했는지 검증하기 위한 부분입니다.
- 서명은 헤더의 인코딩 값, 정보의 인코딩 값을 합친 후 비밀키로 해쉬를 하여 생성합니다.

![](https://user-images.githubusercontent.com/61782539/133422451-b95b5cc2-36ee-4100-beb1-2e019b067854.png)

참고로 pyjwt 버전 2.0 이상부터는 jwt.encode의 결과값이 bytes 타입이 아니라 str 타입이므로 Response에 값을 전달할 때 decode 과정을 거치지 않아도 된다.

```python
>>> import jwt
>>> encoded_jwt = jwt.encode({"some": "payload"}, "secret", algorithm="HS256")
>>> print(encoded_jwt)
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzb21lIjoicGF5bG9hZCJ9.Joh1R2dYzkRvDkqv3sygm5YyK8Gi4ShZqbhK2gxcs2U
>>> jwt.decode(encoded_jwt, "secret", algorithms=["HS256"])
{'some': 'payload'}
```

jwt를 decode했을 때 넣어줬던 유저정보를 가져올 수 있다.