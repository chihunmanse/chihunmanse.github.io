---
layout: single
tags: 
 - python

toc: true
toc_sticky: true

title: "[python] module"
---

{% raw %}

### sys.modules와 sys.path의 차이점

**sys.modules**

파이썬이 모듈이나 package를 찾기 위해 가장 먼저 확인하는 곳이다.
`sys.modules`는 단순한 dictionary이고 이미 import된 모듈과 package들을 저장하고 있다.
즉, 한번 import된 모듈과 package들은 파이썬이 또 다시 찾지 않아도 되도록 하는 기능을 가지고 있다.
그렇기때문에 새로 import하는 모듈은 `sys.modules`에서 찾을수 없다.

**sys.path**

파이썬이 마지막으로 보는 장소가 `sys.path`이다.
`sys.path`는 기본적으로 list이며 string 요소들을 가지고 있는 list이다.

- python 모듈이 실행되고 있는 현재 디렉터리
- Python 환경변수에 정의되어 있는 디렉터리
- python과 함께 설치된 기본 라이브러리

```python
['',
 '/Users/song-eun-u/anaconda3/bin',
 '/Users/song-eun-u/anaconda3/lib/python36.zip',
 '/Users/song-eun-u/anaconda3/lib/python3.6',
 '/Users/song-eun-u/anaconda3/lib/python3.6/lib-dynload',
 '/Users/song-eun-u/anaconda3/lib/python3.6/site-packages',
 '/Users/song-eun-u/anaconda3/lib/python3.6/site-packages/aeosa',
 '/Users/song-eun-u/anaconda3/lib/python3.6/site-packages/IPython/extensions',
 '/Users/song-eun-u/.ipython']
```

각 string 요소들은 다음 처럼 경로를 나타냄.

파이썬은 import 하고자 하는 모듈과 package를 찾을때에 먼저 `sys.modules`를 보고, 없으면 파이썬 **built-in 모듈**들을 확인 하고 마지막으로 `sys.path`에 지정되어 있는 경로들을 확인해서 찾습니다.

**sys.path 에서도 못찾으면** `ModuleNotFoundError` **에러를 리턴합니다.**

### **Absolute path**와 **relative path**의 차이점

,`pip` 으로 설치한 외무 모듈은 자동으로 `site-packages` 라는 디렉토리에 설치가 되는데, 이 `site-packages` 는 `sys.path`에 이미 포함되어 있기때문에 찾는데 문제가 없습니다.

직접 개발한 local package를 import 할때는 해당 package의 위치에 맞게 import 경로를 잘 선언해야 합니다.

Local package를 import 하는 경로에는 **absolute path** 와 **relative path** 가 있습니다.

**absolute path**

```python
└── my_app
    ├── main.py
    ├── package1
    │   ├── module1.py
    │   └── module2.py
    └── package2
        ├── __init__.py
        ├── module3.py
        ├── module4.py
        └── subpackage1
            └── module5.py
```

Absolute path를 사용해 `package1` 과 `package2`를 import 하면 다음과 같습니다.

```python
from package1 import module1
from package1.module2 import function1
from package2 import class1
from package2.subpackage1.module5 import function2
```

경로들의 시작점이 전부 `my_app` 프로젝트의 가장 최상위 디렉토리에서 시작하는것을 볼 수 있습니다.

파이썬에서는 slash `/` 나 back slash `\` 대신에 dot `.` 을 사용해서 경로를 표현 합니다.

이미 `my_app` 프로젝트 안에 있으므로 `my_app` 은 생략됩니다.

`my_app` 프로젝트 내에서는 어느 파일, 어느 위치에서 import 하던지 경로가 항상 위와 같이 동일하게 되므로 absolute path 라고 하는 것입니다.

참고로 current directory 라고 하는 현재의 프로젝트 디렉토리는 default로 sys.path 에 포함되게 됩니다.

그러므로 absolute path는 current directory 로 부터 경로를 시작하게 되는것입니다.

일반적으로 local package를 import 할때는 absolute path를 사용하면 됩니다.

다만 absolute path를 사용하게 되면 한가지 단점이 있는데 바로 경로가 길어질 수 있다는 점입니다.

그래서 이러한 단점을 보완하기 위해서 relative path를 사용할 수 있습니다.

**relative path**

Relative path 는 absolute path와 다르게 프로젝트의 최상단 디렉토리를 기준으로 경로를 잡는게 아니라 import 하는 위치를 기준으로 경로를 정의합니다. 그래서 일반적으로 relative path는 local package 안에서 다른 local package를 import 할때 사용됩니다.

예를 들어, `package2`의 `module3`에서 `package2`의 `class1`과 `package2`의 하위 package인 `subpackage1`의 `module5`의 `function2` 함수를 import 하려고 하면 다음 처럼 할 수 있습니다.

```python
# package2/module3.py
 
from . import class1
from .subpackage1.module5 import function2
```

여기서 dot `.`은 import 가 선언되는 파일의 현재 위치를 이야기 합니다.

현재위치는 `package2/module3.py` 이므로 현재 위치에서부터 원하는 모듈의 경로만 선언해주면 되는 것입니다.

또한 dot 2개를 사용할 수도 있습니다. dot 2개 `..` 는 현재위치에서 상위 디렉토리로 가는 경로입니다.

```python
# subpackage1/module5.py
from ..module4 import class4
```

Relative path는 선언해야 하는 경로의 길이를 줄여준다는 장점은 있지만 헷갈리기 쉽고 파일 위치가 변경되면 경로 위치도 변경되어야 하는 단점이 있습니다.

그러므로 웬만한 경우 absolute path를 사용하는게 권장 됩니다.

### `__init__.py` 파일의 역할

 **init 파일은 해당 디렉토리가 패키지임을 알려주는 역할을 합니다.**

`__init__.py` 파일이 존재하지 않는다면 패키지의 일부인지 인식을 하지 못하기 때문에 속성을 가지고 있지 않는다는 에러가 발생하게 됩니다.

**`__init__.py` 파일을 통해 하는일들**

Import 할때 경로의 총 길이 줄여줌

Package에서 import 할 수 있는 변수/함수/클래스 제한

package가 import될때 꼭 먼저 실행되어야 하는 코드 삽입

 python3.3 버전부터는 `__init__.py` 파일이 없어도 패키지로 인식하지만 하위 버전 호환을 위해 `__init__.py` 파일을 생성하는 것이 안전한 방법입니다.

### `main.py`에서 상대경로로 `add_and_mutiply` 를 임포트 했을 때 발생하는 에러

```python
Traceback (most recent call last):
  File "/Users/chihun/Desktop/my_app/main.py", line 5, in <module>
    from .calculator.add_and_multiply import add_and_multiply
ImportError: attempted relative import with no known parent package
(base) chihun@bagchihun-ui-MacBookAir my_app % 
```

if `__name__` == '`__main__`':처럼 `__name__` 변수의 값이 '`__main__`'인지 확인하는 코드는 현재 스크립트 파일이 프로그램의 시작점이 맞는지 판단하는 작업입니다. 즉, 스크립트 파일이 메인 프로그램으로 사용될 때와 모듈로 사용될 때를 구분하기 위한 용도입니다.

relative import는 현재의 모듈을 기반으로 이루어진다. 메인 모듈의 이름은 항상 `__main__`이고, 파이썬에서 메인 모듈은 항상 absolute import를 사용해야하기 때문에 relative path를 absolute path로 설정해주면 오류가 발생하지 않는다.

### `add_and_multiply.py`에서 `multiply`함수를 절대경로와 상대경로도 각각 임포트 해보고 main 모듈과 차이점

add_and_multiply.py 모듈 자체를 실행하는 경우에는 multiply 함수를 상대경로로 지정했을 때 main.py와 같은 오류가 발생한다. **즉, 모듈 자체를 실행하는 경우에는 그 모듈안에 다른 모듈을 import할 때 반드시 절대경로로 import해야한다.** 다시 말하면, 실행하는 파이썬 스크립트 파일안에서는 다른 모듈을 import할 경우 무조건 절대경로로 import해야 정상적으로 동작한다.  

**모듈이 직접 실행되는 모듈이 아닌 경우에는 상대경로 import를 허용한다.** add_and_multiply.py 모듈에 multiply 함수를 상대경로로 지정하고 main.py를 실행했을 때는 잘 동작한다.


{% endraw %}
