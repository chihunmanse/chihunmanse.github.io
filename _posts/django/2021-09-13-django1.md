### 주인과 강아지 과제

**models.py**

```python
from django.db import models

# Create your models here.
class Owners(models.Model) :
    name = models.CharField(max_length=45)
    email = models.CharField(max_length=300)
    age = models.IntegerField()

    class Meta :
        db_table = 'owners'

class Dogs(models.Model) :
    owner = models.ForeignKey("Owners", on_delete=models.CASCADE) 
    # Dogs가 Owners를 참조하는 일대 다 관계
    name = models.CharField(max_length=45)
    age = models.IntegerField()

    class Meta :
        db_table = 'dogs'
```

**views.py**

```python
import json

from django.http    import JsonResponse
from django.views   import View

from owners.models  import Owners , Dogs
# Create your views here.
class OwnersView(View) : 
    def post(self, request) :
        data = json.loads(request.body)

        Owners.objects.create(
            name = data['name'] , 
            email = data['email'] , 
            age = data['age']
            )

        return JsonResponse({'MASSAGE' : 'CREATED'} , status = 201)

    def get(self, request) :
        owners = Owners.objects.all()
        result = []
        
        for owner in owners:
            dogs = owner.dogs_set.all() 
            dog_list = [] 

            for dog in dogs:
                dog_info = (
                    {
                        'name': dog.name,
                        'age': dog.age,
                    }
                )
                dog_list.append(dog_info)
            
            result.append(
                {
                    'name' : owner.name,
                    'age': owner.age,
                    'email': owner.email,
                    'dog' : dog_list
                }
            )

        return JsonResponse({'result':result}, status = 200)

class DogsView(View) :
    def post(self, request) :
        data  = json.loads(request.body)
        owner = Owners.objects.get(name = data['owner'])

        Dogs.objects.create(
            name = data['name'],
            age = data['age'],
            owner = owner
        )
        return JsonResponse({'MASSAGE' : 'CREATED'} , status = 201)

    def get(self, request) :
        dogs = Dogs.objects.all()
        result = []
        
        for dog in dogs :
            result.append(
                {
                    'name' : dog.name,
                    'age' : dog.age,
                    'owner' : dog.owner.name
                }
            )

        return JsonResponse({'result' : result} , status = 200)
```

주인에 속한 강아지 리스트는 자신이 참조하고 있는 모델에 대한 정보(강아지의 주인 이름, 정참조) 를 가져오는게 아니라 **자신을 참조하고 있는** 모델에 대한 정보를 불러오는 역참조이다.

### 역참조 데이터를 불러오는 법

역참조란? ForeinKey에 의해 참조 되고 있는 모델에서 참조하는 모델을 호출하는 경우를 역참조 라고 한다.

**참조하는 모델에서 참조되는 모델의 id값을 통해 필터링 하는 방법**

```python
owner1 = Owners.objects.first()
Dogs.objects.filter(owner=owner1)
```

**_set을 사용하는 방법**

```python
owner1 = Owners.objects.first()
owner1.dogs_set.all()
```

**related_name을 지정하는 방법**

Dogs 모델에서 Owners에 대한 ForeignKey를 선언할 때 속성값으로 related_name을 지정

models.py 에서 

```python
owner = models.ForeignKey("Owners", on_delete=models.CASCADE, related_name='dogs') 
```

위와 같이 속성값을 줬을 때

```python
owner1 = Owners.objects.first()
owner1.dogs.all()
```

related_name을 통해 Owners가 Dogs를 참조하고 있는 것처럼 사용할 수 있다.

### 배우와 영화 과제

**models.py**

```python
from django.db import models

# Create your models here.
class Actor(models.Model) :
    first_name = models.CharField(max_length=45)
    last_name = models.CharField(max_length=45)
    date_of_birth = models.DateField( null=True)

    class Meta :
        db_table = 'actors'

class Movie(models.Model) :
    title = models.CharField(max_length=45)
    release_date = models.DateField()
    running_time = models.IntegerField()
    actors = models.ManyToManyField('Actor', related_name= 'movies') 
    # ManyToManyField를 설정하면 중간 테이블이 저절로 생성된다.

    class Meta :
        db_table = 'movies'
```

**views.py**

```python
import json

from django.http import JsonResponse
from django.views import View
from movies.models import Actor , Movie

# Create your views here.
class ActorView(View) :
    def post(self, request) :
        data = json.loads(request.body)

        Actor.objects.create(
            first_name = data['first_name'],
            last_name = data['last_name'],
            date_of_birth = data['date_of_birth']
        )

        return JsonResponse({'MASSAGE' : 'CREATED'}, status = 201)

    def get(self, request) :
        actors = Actor.objects.all()
        result = []
        for actor in actors :
            movies = actor.movies.all()
            movie_list = []
            for movie in movies :
                movie_list.append(movie.title)
            
            actor_name = actor.last_name + ' ' + actor.first_name
            result.append(
                {
                    'name' : actor_name,
                    'movies' : movie_list
                }
            )

        return JsonResponse({'RESULT' : result} , status = 200)


class MovieView(View) :
    def get(self, request) :
        movies = Movie.objects.all()
        result = []
        for movie in movies :
            actor_list = []
            actors = movie.actors.all()
            for actor in actors :
                actor_name = actor.last_name + ' ' + actor.first_name
                actor_list.append(actor_name)
            result.append(
                {'title' : movie.title,
                 'running_time' : movie.running_time,
                 'actors' : actor_list,
                 'release_date' : movie.release_date,
                 }
            )
        return JsonResponse({'RESULT': result} , status = 200)
```

many to many 관계에서

**Foriegn Key로 중간테이블을 직접 만들어서 관계를 설정했을 때**

연결되어있는 모델의 데이터를 가져오거나 새로운 연결 값을 생성할 때 꼭 중간 테이블을 거쳐야만 가능하다.

```python
from django.db import models

# Create your models here.
class Actor(models.Model) :
    first_name = models.CharField(max_length=45)
    last_name = models.CharField(max_length=45)
    date_of_birth = models.DateField( null=True)

    class Meta :
        db_table = 'actors'

class Movie(models.Model) :
    title = models.CharField(max_length=45)
    release_date = models.DateField()
    running_time = models.IntegerField()

    class Meta :
        db_table = 'movies'
       
class ActorMovie(models.Model) :
  	actor = models.ForeignKey('Actor', on_delete=models.CASCADE)
    movie = models.ForeignKey('Movie', on_delete=models.CASCADE)
```

models.py가 위와 같을 때

```python
actor1 = Actor.objects.get(id=1)
movie1 = Movie.objects.get(id=1)
ActorMovie.objects.create(actor=actor1, movie=movie1)

actor1.actormovie_set.get().movie.title
movie1.actormovie_set.get().actor.first_name
```

**ManyToManyField를 사용했을 때**

```python
actor1 = Actor.objects.get(id=1)
movie1 = Movie.objects.get(id=1)

movie1.actors.add(actor1)
actor1.movies.add(movie1) #related_name = movies

movie1.actors.all()
actor1.movies.all()# related_name = movies
```

중간테이블을 거치지 않고 서로의 정보를 참조해서 가져오거나 연결값을 추가할 수 있다.