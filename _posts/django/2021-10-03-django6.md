**Object Relational Mapping (객체-관계 매핑)**

- 객체와 관계형 데이터베이스를 자동으로 매핑(연결) 해줌
- **데이터베이스 ↔ Object** (객체를 통해 데이터베이스의 필드를 다룸)

**QuerySet 이란?**

쿼리셋은 전달받은 객체의 목록이라고 할 수 있다. 쿼리셋은 데이터베이스로부터 데이터를 읽고, 필터를 걸거나 정렬할 수 있다.

## Lazy Loading

Lazy Loading 지연로딩 : 쿼리셋은 정말 필요한 시점에 (데이터를 통한 연산 등) SQL문을 호출하는 LazyLoading이라는 특징을 가지고 있다.

```python
 post = Post.objects.all()
```

위와 같은 ORM 구문을 작성하여도 아직까지는 실제로 SQL문이 호출되지 않는다.

```python
post.count()
SELECT COUNT(*) AS "__count"
  FROM "mysite_post"
Execution time: 0.000587s [Database: default]
19
```

위의 실행 결과처럼 실제로 쿼리셋에 담겨있는 데이터를 이용하는 경우에 SQL문이 호출된다.

**쿼리셋이 평가 (evaluate) 되기 전까지는 데이터베이스 활동이 일어나지 않는다.**

**쿼리셋을 순회하는 경우**

```python
for post in Post.objects.all():
    print(post.title)
```

**쿼리셋을 슬라이싱하는 경우**

```python
post[0]
SELECT "mysite_post"."id",
       "mysite_post"."title",
       "mysite_post"."content",
       "mysite_post"."created_at",
       "mysite_post"."updated_at"
  FROM "mysite_post"
 LIMIT 1
Execution time: 0.000937s [Database: default]
<Post: Post object (1)>
```

post 쿼리셋에서 첫 번째의 결과 값(row)만 가져오고 싶을 경우에는 위와 같은 코드를 작성할 수 있다. 수행 되는 SQL문에서 LIMIT 1이라는 옵션이 걸려있다. 즉, 필요한 만큼만 SQL문을 호출하는 것을 알 수 있다.

**len() 을 사용하는 경우**

쿼리셋에 `len()` 함수를 적용하는 경우 쿼리셋이 평가된다. 쿼리셋에 포함된 데이터의 개수를 리턴한다.

**list() 를 사용하는 경우**

```python
post_list = list(Post.objects.all())
```

**쿼리셋을 검사(test) 하는 경우**

bool(), and, or, if 등으로 쿼리셋을 검사하는 경우 쿼리셋이 평가된다. 이 경우, 쿼리셋에 값이 하나라도 있으면 True, 아니면 False 가 된다.

**Lazy Loading의 단점**

- 여러 개의 쿼리셋이 한번에 합쳐 실행 되면 매우 느리게 동작할 수 있다.
- 이미 알고 있는 값도 다시 한번 호출이 일어날 수 있다 (N+1 Problem)

## Caching

쿼리셋은 호출한 SQL에 대한 결과를 캐싱하여 저장하는 특징을 가지고 있다.

```python
>>> post = Post.objects.all()
>>> post[0]

SELECT "mysite_post"."id",
       "mysite_post"."title",
       "mysite_post"."content",
       "mysite_post"."created_at",
       "mysite_post"."updated_at"
  FROM "mysite_post"
 LIMIT 1
Execution time: 0.000158s [Database: default]
<Post: Post object (1)>

>>> 
>>> list(post)

SELECT "mysite_post"."id",
       "mysite_post"."title",
       "mysite_post"."content",
       "mysite_post"."created_at",
       "mysite_post"."updated_at"
  FROM "mysite_post"
Execution time: 0.000156s [Database: default]
[<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>, 
<Post: Post object (4)>, <Post: Post object (5)>, <Post: Post object (6)>, 
<Post: Post object (7)>, <Post: Post object (8)>, <Post: Post object (9)>, 
<Post: Post object (10)>, <Post: Post object (11)>, <Post: Post object (12)>, 
<Post: Post object (13)>, <Post: Post object (14)>, <Post: Post object (15)>, 
<Post: Post object (16)>, <Post: Post object (17)>, <Post: Post object (18)>, 
<Post: Post object (19)>]
```

post의 모든 row를 쿼리셋에 가져오기 위해 all() 연산을 수행하고 첫 번째의 결과를 출력하기 위한 post[0] 연산을 수행한 뒤 리스트로 바꿔주는 작업을 진행하였을 때, SQL 호출 결과에서 볼 수 있듯이 중복(유사)된 쿼리가 2번 호출 되는 것을 볼 수 있다. (불필요한 SQL 호출)

```python
>>> post = post.objects.all()
>>> list(post) # all() 조회 결과 저장

SELECT "mysite_post"."id",
       "mysite_post"."title",
       "mysite_post"."content",
       "mysite_post"."created_at",
       "mysite_post"."updated_at"
  FROM "mysite_post"
Execution time: 0.000215s [Database: default]
[<Post: Post object (1)>, <Post: Post object (2)>, <Post: Post object (3)>,
<Post: Post object (4)>, <Post: Post object (5)>, <Post: Post object (6)>, 
<Post: Post object (7)>, <Post: Post object (8)>, <Post: Post object (9)>, 
<Post: Post object (10)>, <Post: Post object (11)>, <Post: Post object (12)>, 
<Post: Post object (13)>, <Post: Post object (14)>, <Post: Post object (15)>, 
<Post: Post object (16)>, <Post: Post object (17)>, <Post: Post object (18)>, 
<Post: Post object (19)>]

>>> post[0] # 저장된 결과 재사용
<Post: Post object (1)>
```

이러한 문제점을 해결하기 위해 QuerySet의 특징인 Caching을 이용할 수 있다. 쿼리셋은 호출한 결과를 캐싱하여 저장하고 있기 때문에 지금과 같은 단순한 경우에는 간단히 순서를 바꿔주는 것 만으로도 SQL 중복 호출을 방지할 수 있게 된다.

## **Eager Loading**

쿼리셋은 기본적으로 Lazy Loading 전략을 이용한다. 하지만 SQL로 한번에 많은 데이터를 가져오려는 경우가 있을 것이다.

이를 지원하기 위해서 쿼리셋에서는 Eager Loading (즉시 로딩) 이라는 전략이 존재한다.

select_related(), prefretch_related() 메서드를 통해 Eager Loading을 사용할 수 있다.

```python
>>> blog = Blog.objects.all()
>>> 
>>> for b in blog:
...     b.post_title
... 
SELECT "mysite_blog"."id",
       "mysite_blog"."admin",
       "mysite_blog"."created_at",
       "mysite_blog"."updated_at",
       "mysite_blog"."post_title_id"
  FROM "mysite_blog"
Execution time: 0.000213s [Database: default]
SELECT "mysite_post"."id",
       "mysite_post"."title",
       "mysite_post"."content",
       "mysite_post"."created_at",
       "mysite_post"."updated_at"
  FROM "mysite_post"
 WHERE "mysite_post"."id" = 20
 LIMIT 21
Execution time: 0.000132s [Database: default]
<Post: Post object (20)>
SELECT "mysite_post"."id",
       "mysite_post"."title",
       "mysite_post"."content",
       "mysite_post"."created_at",
       "mysite_post"."updated_at"
  FROM "mysite_post"
 WHERE "mysite_post"."id" = 20
 LIMIT 21
```

**N+1 Problem**

모든 Blog를 조회하기 위한 SQL이 1번 수행되고, 그 안에서 Post의 정보를 매번 조회하기 위해 select * from post 의 SQL문이 N번 호출 된다. 이러한 문제가 발생하는 이유는 모든 Blog의 정보를 SQL로 한 번에 가져 왔다고 할 지라도, post_title의 정보를 가져오지는 않았으므로 이를 가져오기 위한 SQL문이 N번 호출 되는 것이다.

**django.db.models.query.py**

```python
class QuerySet:
    """Represent a lazy database lookup for a set of objects."""

    def __init__(self, model=None, query=None, using=None, hints=None):
        self.model = model
        self._db = using
        self._hints = hints or {}
        self._query = query or sql.Query(self.model)
        self._result_cache = None
        self._sticky_filter = False
        self._for_write = False
        self._prefetch_related_lookups = ()
        self._prefetch_done = False
        self._known_related_objects = {}  # {rel_field: {pk: rel_obj}}
        self._iterable_class = ModelIterable
        self._fields = None
        self._defer_next_filter = False
        self._deferred_filter = None

    @property
    def query(self):
        if self._deferred_filter:
            negate, args, kwargs = self._deferred_filter
            self._filter_or_exclude_inplace(negate, args, kwargs)
            self._deferred_filter = None
        return self._query
```

- **query** : 1개의 메인 쿼리로 부를 수 있음
- **result_cache** : SQL의 수행 결과가 저장되는 부분(캐싱), 저장된 데이터가 없을 경우 새로운 SQL문 호출함
- **prefetch_related_lookups** : prefetch_relate() 부분에 선언된 값들을 저장함, 추가 쿼리셋이라고 부름

### Select_related 와 Prefetch_related

select_related, prefetch_related 는 하나의 쿼리셋을 가져올 때 연관되어 있는 objects들을 미리 불러오게(Eager Loading) 하는 함수이다. JOIN문을 사용하기 때문에 호출되는 SQL문이 복잡해질 수 있지만, 이렇게 불러온 데이터들은 앞서 알아본 result_cache 라는 부분에 cache 되기 때문에 결과적으로 중복 호출을 방지할 수 있다.

- **Select_related()**는 JOIN을 통해 데이터를 즉시 가져오는(Eager Loading) 방법 **(SQL단계에서의 JOIN)**
- **Pretfetech_related()**는 추가 쿼리를 통해 데이터를 즉시 가져오는 방법 **(추가 쿼리 발생, JOIN은 파이썬 level에서 이루어짐)**

**select_related()의 사용**

select_related는 **1:1의 관계**에서 사용할 수 있고, **1:N의 관계에서 N이 사용**할 수 있다. 즉, **정방향 참조**(Post 모델에서 Category 모델의 정보를 찾으려고 할 때)에서의 JOIN에 유리하게 사용된다.

select_related() 사용하지 않았을 때

```python
>>> post = Post.objects.all()
>>> for p in post:
...     p.category.name
... 
SELECT "mysite2_post"."id",
       "mysite2_post"."category_id",
       "mysite2_post"."title",
       "mysite2_post"."content",
       "mysite2_post"."created_at",
       "mysite2_post"."updated_at"
  FROM "mysite2_post"
Execution time: 0.000784s [Database: default]
SELECT "mysite2_category"."id",
       "mysite2_category"."blog_id",
       "mysite2_category"."name"
  FROM "mysite2_category"
 WHERE "mysite2_category"."id" = 5
 LIMIT 21
Execution time: 0.000676s [Database: default]

... 생략
```

select_related() 사용

```python
>>> post = Post.objects.select_related('category').all()
>>> for p in post:
...     p.category.name
... 
SELECT "mysite2_post"."id",
       "mysite2_post"."category_id",
       "mysite2_post"."title",
       "mysite2_post"."content",
       "mysite2_post"."created_at",
       "mysite2_post"."updated_at",
       "mysite2_category"."id",
       "mysite2_category"."blog_id",
       "mysite2_category"."name"
  FROM "mysite2_post"
  LEFT OUTER JOIN "mysite2_category"
    ON ("mysite2_post"."category_id" = "mysite2_category"."id")
Execution time: 0.007924s [Database: default]
'programming category'
'programming category'
'programming category'
'programming category'
'programming category'
```

select_related('정방향 참조 필드') 함수를 통해 category에 대한 정보를 미리(Eager Loading) 불러오는 것을 볼 수 있다.  model의 category 필드에서 on_delete=models.SET_NULL(null=True) 옵션을 걸었기에 ORM에서 LEFT OUTER JOIN 구문이 생성되었다. 만약, models.CASCADE 옵션을 걸었다면 INNER JOIN 으로 수행됐을 것이다.

***select_related()는 정참조의 JOIN을 통해 Eager Loading 하는 함수라고 할 수 있다.***

**prefetch_related()의 사용**

prefetch_related는 반대로 **1:N의 관계에서 1이 사용**할 수 있고, **N:M의 관계**에서 사용할 수 있다.

```python
>>> category = Category.objects.prefetch_related('post_set').get(name='django')
SELECT "mysite2_category"."id",
       "mysite2_category"."blog_id",
       "mysite2_category"."name"
  FROM "mysite2_category"
 WHERE "mysite2_category"."name" = 'django'
 LIMIT 21
Execution time: 0.000285s [Database: default]
SELECT "mysite2_post"."id",
       "mysite2_post"."category_id",
       "mysite2_post"."title",
       "mysite2_post"."content",
       "mysite2_post"."created_at",
       "mysite2_post"."updated_at"
  FROM "mysite2_post"
 WHERE "mysite2_post"."category_id" IN (6)
Execution time: 0.000296s [Database: default]
>>> for c in category.post_set.all():
...     c.title
... 
'django 1'
'django 2'
'django 3'
```

Select 쿼리가 두 번 수행, 첫 번째의 쿼리는 category의 정보를 위한 쿼리이고 두 번째 쿼리는 prefetch_related('역방향 필드 참조', ...) 에 작성한 필드에 대한 추가 쿼리이다. 즉, 필드 값으로 N개를 줄 경우 각 필드값에 대한 N개의 추가 쿼리가 발생하게 되는 것이다. select_related 와의 가장 큰 차이점은 **추가 쿼리가 발생한다는 것**이고, 또 다른 차이점은 발생된 추가 쿼리를 **파이썬 단계에서 JOIN**을 통해 결과를 만들어낸다는 점이다.

prefetch_related의 필드들에 추가적인 조건을 걸고 싶은 경우가 있을 것이다. 그럴때 사용하는 것이 바로 **Prefetch() 객체**이다.

Prefetch(lookup, queryset=None, to_attr=None)

참조 : https://leffept.tistory.com/312?category=950490