## 게시물 모델링

**posting/models.py**

```python
from django.db          import models
from users.models       import User
# Create your models here.
class Post(models.Model) :
    content = models.CharField(max_length=1000, null=True)
    created_at = models.DateTimeField(auto_now_add=True)
    user = models.ForeignKey('users.User', on_delete=models.CASCADE, related_name='posts')

    class Meta :
        db_table = 'posts'

class Image(models.Model) :
    url = models.URLField(max_length=2000)
    post = models.ForeignKey('Post', on_delete=models.CASCADE, related_name='images')

    class Meta :
        db_table = 'images'
```

유저와 게시물은 one to many 관계이다. users 앱의 User 모델을 import 해온다. 

```python
user = models.ForeignKey('users.User', on_delete=models.CASCADE, related_name='posts')
```

[앱 이름].[클래스] 형태로 다른 앱의 클래스를 가져올 수 있다.

하나의 게시물에는 여러 개의 이미지가 들어갈 수 있기 때문에 게시글을 참조하는 이미지 모델을 따로 만들어주었다.

## 로그인 인증

### 데코레이터 동작 원리 파악하기

중첩함수는 어떤 순서로 동작하는지 너무 헷갈려서 이래저래 코드를 치면서 실험을 해보았다.

```python
def decorator(func) :
    print('1')
    def wrapper() :
        print('3')
        def wrapper2() :
            print('4')
            return func
        return wrapper2
    print('2')
    return wrapper


 
def test() :
    print('5')
```

위와 같은 함수가 있을 때

```python
decorator(test)()()()
```

이렇게 함수를 호출해보면

```python
1
2
3
4
5
```

번호 순으로 출력되는걸 볼 수 있다.

```python
test = decorator(test)
test()

#출력
1
2
3

test()()()

#출력
1
2
3
4
5

@decorator
def test() :
    print('5')

test()

#출력
1
2
3

test()()()

#출력
1
2
3
4
5
```

@decorator의 의미가 무엇인지 알 수 있다.

**users/utils.py**

```python
import jwt
import json

from django.http                import JsonResponse

from my_settings                import SECRET_KEY									
from users.models               import User


# access_token = jwt.encode({'id' : user.id}, SECRET_KEY, algorithm='HS256')
def login_decorator(func) :
    def wrapper(self, request, *args, **kwargs) :
        try:
            access_token = request.headers.get('Authorization')
            payload = jwt.decode(access_token, SECRET_KEY, algorithms=["HS256"])
            user = User.objects.get(id=payload['id'])
            request.user = user

        except jwt.exceptions.DecodeError :
            return JsonResponse({'message' : 'INVALID_TOKEN'} , status = 400)
        
        except User.DoesNotExist :
            return JsonResponse({'message' : 'INVALID_USER'}, status = 400)
        
        return func(self, request, *args, **kwargs)
    
    return wrapper
```

로그인 토큰을 확인시켜주는 데코레이터는 users 앱에 따로 파일을 만들어서 작성했다.

로그인 토큰을 발행해줄 때 SECRET_KEY를 넣어서 인코딩 해줬기 때문에 복호화할 때도 해당 키가 필요하므로 import 해온다.

일단 request의 헤더에 담긴 토큰 값을 변수에 저장한다. 그리고 그 토큰을 디코딩해준다. 디코딩된 토큰에는 유저의 id 값이 들어있으므로 그 값을 통해 유저 정보를 불러올 수 있다. 데코레이터 함수 다음에 실행될 함수 (여기서는 게시물을 작성하는 함수가 될 것이다.) 에서 유저정보를 사용할 수 있도록 request.user에 유저 정보를 담아준다. 게시글 작성 Request 에는 토큰을 제외하고는 유저 정보가 담기지 않을 것이기 때문에 이 user값을 request에 저장해서 활용해야 한다. 여기에서 request는 다른 변수 할당이 가능한 가변객체이다.

request에 토큰이 제대로 담기지 않았거나 decode되지 않는다면 디코드에러가 발생할 것이므로 except로 처리해준다. 또 해당하는 유저가 데이터베이스에 저장돼있지 않을 때도 예외처리를 해준다.

**posting/views.py**

```python
import json

from django.http            import JsonResponse
from django.views           import View

from posting.models         import Post , Image
from users.models           import User
from users.utils            import login_decorator

# Create your views here.
class PostView(View) :
    @login_decorator
    def post(self, request) :
        try :
            data = json.loads(request.body)
            user = request.user

            content = data['content']
            image_list = data['image'].split(',')
            
            post = Post.objects.create(
                content = content,
                user = user,
            )

            for image in image_list :
                Image.objects.create(
                    url = image,
                    post = post,
                )
        
            return JsonResponse({'MASSAGE':'SUCCESS'}, status=200)

        except KeyError :
            return JsonResponse({'MASSAGE':'KEY_ERROR'}, status=400)
    
    @login_decorator
    # 작성된 게시물들 불러오기
    def get(self, request) : 
        post_list = [{
            '작성자' : User.objects.get(id=post.user.id).name,
            'content' : post.content,
            'images' : [image.url for image in post.images.all()],
            'created_at' : post.created_at
        } for post in Post.objects.all()
        ]

        return JsonResponse({'DATA' : post_list}, status=200)
```

![](https://user-images.githubusercontent.com/61782539/133931170-17a36d77-b4b2-49de-b3ae-16a5fc921260.png)

로그인 후 토큰 발행

![](https://user-images.githubusercontent.com/61782539/133931202-438c6ab5-2e57-487b-a5ba-f5769a89532c.png)

발행된 토큰으로 게시글 작성

request를 보낼 때 토큰을 body가 아닌 header에 담아서 보내주어야 한다. 

"Authorization: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6OX0.1Sj8HITAYbKoic2cL-YXgDUqKdwN3SVV_NFxdp-hfYo"

":" 형식으로 입력하면 header로 보낼 수 있다.

![](https://user-images.githubusercontent.com/61782539/133931330-77d8edf1-4c57-4f8f-a908-dc8d4628bf87.png)

작성된 게시물들 조회하기