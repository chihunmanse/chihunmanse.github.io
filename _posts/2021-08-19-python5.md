---
layout: single
tags: 
 - python

toc: true
toc_sticky: true

title: "[python] 코딩도장 05"
---

{% raw %}

## 람다 표현식 사용하기

람다 표현식은 식 형태로 되어 있다고 해서 람다 표현식(lambda expression)이라고 부릅니다. 특히 람다 표현식은 함수를 간편하게 작성할 수 있어서 다른 함수의 인수로 넣을 때 주로 사용합니다.

```python
>>> def plus_ten(x):
...     return x + 10
...
>>> plus_ten(1)
11
```

**lambda** **매개변수들: 식**

```python
>>> lambda x: x + 10
<function <lambda> at 0x02C27270>

>>> plus_ten = lambda x: x + 10
>>> plus_ten(1)
11
```

람다 표현식은 다음과 같이 lambda에 매개변수를 지정하고 :(콜론) 뒤에 반환값으로 사용할 식을 지정합니다. 실행을 해보면 함수 객체가 나오는데, 이 상태로는 함수를 호출할 수 없습니다. 왜냐하면 람다 표현식은 이름이 없는 함수를 만들기 때문입니다. 그래서 람다 표현식을 익명 함수(anonymous function)로 부르기도 합니다. lambda로 만든 익명 함수를 호출하려면 람다 표현식을 변수에 할당해주면 됩니다.

```python
>>> (lambda x: x + 10)(1)
11
```

람다 표현식은 변수에 할당하지 않고 람다 표현식 자체를 바로 호출할 수 있습니다. 다음과 같이 람다 표현식을 ( )(괄호)로 묶은 뒤에 다시 ( )를 붙이고 인수를 넣어서 호출하면 됩니다.

**(lambda** **매개변수들: 식)(인수들)**

람다 표현식에서 주의할 점은 람다 표현식 안에서는 새 변수를 만들 수 없다는 점입니다. 따라서 반환값 부분은 변수 없이 식 한 줄로 표현할 수 있어야 합니다. 변수가 필요한 코드일 경우에는 def로 함수를 작성하는 것이 좋습니다.

```python
>>> (lambda x: y = 10; x + y)(1)
SyntaxError: invalid syntax

>>> y = 10
>>> (lambda x: x + y)(1)
11 # 람다 표현식 바깥에 있는 변수는 사용할 수 있습니다. 
```

람다 표현식을 사용하는 이유는 함수의 인수 부분에서 간단하게 함수를 만들기 위해서 입니다. 이런 방식으로 사용하는 대표적인 예가 map입니다.

```python
>>> def plus_ten(x):
...     return x + 10
...
>>> list(map(plus_ten, [1, 2, 3]))
[11, 12, 13]

>>> list(map(lambda x: x + 10, [1, 2, 3]))
[11, 12, 13]
```

람다 표현식으로 매개변수가 없는 함수를 만들 때는 lambda 뒤에 아무것도 지정하지 않고 :(콜론)을 붙입니다. 단, 콜론 뒤에는 반드시 반환할 값이 있어야 합니다. 왜냐하면 표현식(expression)은 반드시 값으로 평가되어야 하기 때문입니다.

```python
>>> (lambda : 1)()
1
>>> x = 10
>>> (lambda : x)()
10
```

**lambda** **매개변수들: 식1 if 조건식 else 식2**

```python
>>> a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> list(map(lambda x: str(x) if x % 3 == 0 else x, a))
[1, 2, '3', 4, 5, '6', 7, 8, '9', 10]
```

map은 리스트의 요소를 각각 처리하므로 lambda의 반환값도 요소라야 합니다. 여기서는 요소가 3의 배수일 때는 str(x)로 요소를 문자열로 만들어서 반환했고, 3의 배수가 아닐 때는 x로 요소를 그대로 반환했습니다.

람다 표현식 안에서 조건부 표현식 if, else를 사용할 때는 :(콜론)을 붙이지 않습니다. 일반적인 if, else와 문법이 다르므로 주의해야 합니다. 조건부 표현식은 **식1 if 조건식 else 식2** 형식으로 사용하며 **식1**은 조건식이 참일 때, **식2**는 조건식이 거짓일 때 사용할 식입니다.

**특히 람다 표현식에서 if를 사용했다면 반드시 else를 사용해야 합니다.** 다음과 같이 if만 사용하면 문법 에러가 발생하므로 주의해야 합니다.

```python
>>> list(map(lambda x: str(x) if x % 3 == 0, a))
SyntaxError: invalid syntax
```

**람다 표현식 안에서는 elif를 사용할 수 없습니다.** 따라서 조건부 표현식은 **식1 if 조건식1 else 식2 if 조건식2 else 식3** 형식처럼 if를 연속으로 사용해야 합니다. 

```python
>>> a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> list(map(lambda x: str(x) if x == 1 else float(x) if x == 2 else x + 10, a))
['1', 2.0, 13, 14, 15, 16, 17, 18, 19, 20]
```

**lambda** **매개변수들: 식1 if 조건식1 else 식2 if 조건식2 else 식3**

```python
>>> def f(x):
...     if x == 1:
...         return str(x)
...     elif x == 2:
...         return float(x)
...     else:
...         return x + 10
...
>>> a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> list(map(f, a))
['1', 2.0, 13, 14, 15, 16, 17, 18, 19, 20]
```

```python
>>> a = [1, 2, 3, 4, 5]
>>> b = [2, 4, 6, 8, 10]
>>> list(map(lambda x, y: x * y, a, b))
[2, 8, 18, 32, 50]
```

filter는 반복 가능한 객체에서 특정 조건에 맞는 요소만 가져오는데, filter에 지정한 함수의 반환값이 True일 때만 해당 요소를 가져옵니다. 

**filter(함수, 반복가능한객체)**

```python
>>> def f(x):
...     return x > 5 and x < 10
...
>>> a = [8, 3, 2, 10, 15, 7, 1, 9, 0, 11]
>>> list(filter(f, a))
[8, 7, 9]

>>> a = [8, 3, 2, 10, 15, 7, 1, 9, 0, 11]
>>> list(filter(lambda x: x > 5 and x < 10, a))
[8, 7, 9]
```

**from functools import reduce**

**reduce(함수, 반복가능한객체)**

reduce는 반복 가능한 객체의 각 요소를 지정된 함수로 처리한 뒤 이전 결과와 누적해서 반환하는 함수입니다(reduce는 파이썬 3부터 내장 함수가 아닙니다. 따라서 functools 모듈에서 reduce 함수를 가져와야 합니다)

```python
>>> def f(x, y):
...     return x + y
...
>>> a = [1, 2, 3, 4, 5]
>>> from functools import reduce
>>> reduce(f, a)
15

>>> a = [1, 2, 3, 4, 5]
>>> from functools import reduce
>>> reduce(lambda x, y: x + y, a)
15
```

함수 f에서 x + y를 반환하도록 만들었으므로 reduce는 요소 두 개를 계속 더하면서 결과를 누적합니다.

리스트(딕셔너리, 세트) 표현식으로 처리할 수 있는 경우에는 map, filter와 람다 표현식 대신 리스트 표현식을 사용하는 것이 좋습니다. 

```python
>>> a = [8, 3, 2, 10, 15, 7, 1, 9, 0, 11]
>>> list(filter(lambda x: x > 5 and x < 10, a))

>>> [i for i in a if i > 5 and i < 10]
[8, 7, 9]
```

reduce(lambda x, y: x + y, a)는 다음과 같이 for 반복문으로 표현할 수 있습니다.

```python
>>> a = [1, 2, 3, 4, 5]
>>> x = a[0]
>>> for i in range(len(a) - 1):
...     x = x + a[i + 1]
...
>>> x
15
```

## 클로저 사용하기

```python
x = 10          # 전역 변수
def foo():
    print(x)    # 전역 변수 출력
 
foo()

print(x)        # 전역 변수 출력

# 10
# 10
```

foo 함수에서 함수 바깥에 있는 변수 x의 값을 출력했습니다. 물론 함수 바깥에서도 x의 값을 출력할 수 있습니다. 이처럼 함수를 포함하여 스크립트 전체에서 접근할 수 있는 변수를 전역 변수(global variable)라고 부릅니다. 특히 전역 변수에 접근할 수 있는 범위를 전역 범위(global scope)라고 합니다.

```python
def foo():
    x = 10      # foo의 지역 변수
    print(x)    # foo의 지역 변수 출력
 
foo()
print(x)        # 에러. foo의 지역 변수는 출력할 수 없음


10
Traceback (most recent call last):
  File "C:\project\local_variable.py", line 6, in <module>
    print(x)        # 에러. foo의 지역 변수는 출력할 수 없음
NameError: name 'x' is not defined
```

실행을 해보면 x가 정의되지 않았다는 에러가 발생합니다. 왜냐하면 변수 x는 함수 foo 안에서 만들었기 때문에 foo의 지역 변수(local variable)입니다. 따라서 지역 변수는 변수를 만든 함수 안에서만 접근할 수 있고, 함수 바깥에서는 접근할 수 없습니다. 특히 지역 변수를 접근할 수 있는 범위를 지역 범위(local scope)라고 합니다.

```python
x = 10          # 전역 변수
def foo():
    x = 20      # x는 foo의 지역 변수
    print(x)    # foo의 지역 변수 출력
 
foo()

print(x)        # 전역 변수 출력


# 20
# 10
```

함수 foo 안에서 x = 20처럼 x의 값을 20으로 변경했습니다. 하지만 함수 바깥에서 print로 x의 값을 출력해보면 10이 나옵니다. 겉으로 보기에는 foo 안의 x는 전역 변수인 것 같지만 실제로는 foo의 지역 변수입니다. 즉, 전역 변수 x가 있고, foo에서 지역 변수 x를 새로 만들게 됩니다. 이 둘은 이름만 같을 뿐 서로 다른 변수입니다.

함수 안에서 전역 변수의 값을 변경하려면 global 키워드를 사용해야 합니다. 다음과 같이 함수 안에서 global에 전역 변수의 이름을 지정해줍니다.

**global** **전역변수**

```python
x = 10          # 전역 변수
def foo():
    global x    # 전역 변수 x를 사용하겠다고 설정
    x = 20      # x는 전역 변수
    print(x)    # 전역 변수 출력
 
foo()
print(x)        # 전역 변수 출력


# 20
# 20
```

만약 전역 변수가 없을 때 함수 안에서 global을 사용하면 해당 변수는 전역 변수가 됩니다.

```python
# 전역 변수 x가 없는 상태
def foo():
    global x    # x를 전역 변수로 만듦
    x = 20      # x는 전역 변수
    print(x)    # 전역 변수 출력
 
foo()
print(x)        # 전역 변수 출력


# 20
# 20
```

```python
def 함수이름1():
    코드
    def 함수이름2():
        코드
        
def print_hello():
    hello = 'Hello, world!'
    def print_message():
        print(hello)
    print_message()
 
print_hello()

# Hello, world!
```

안쪽 함수 print_message에서는 바깥쪽 함수 print_hello의 지역 변수 hello를 사용할 수 있습니다.

```python
def print_hello():
    hello = 'Hello, world!'
    def print_message():
        print(hello)    # 바깥쪽 함수의 지역 변수를 사용
```

즉, 바깥쪽 함수의 지역 변수는 그 안에 속한 모든 함수에서 접근할 수 있습니다.

```python
def A():
    x = 10        # A의 지역 변수 x
    def B():
        x = 20    # x에 20 할당
 
    B()
    print(x)      # A의 지역 변수 x 출력
 
A()

# 10
```

겉으로 보기에는 바깥쪽 함수 A의 지역 변수 x를 변경하는 것 같지만, 실제로는 안쪽 함수 B에서 이름이 같은 지역 변수 x를 새로 만들게 됩니다. 즉, 파이썬에서는 함수에서 변수를 만들면 항상 현재 함수의 지역 변수가 됩니다.

```python
def A():
    x = 10        # A의 지역 변수 x
    def B():
        nonlocal x    # 현재 함수의 바깥쪽에 있는 지역 변수 사용
        x = 20        # A의 지역 변수 x에 20 할당
 
    B()
    print(x)      # A의 지역 변수 x 출력
 
A()

# 20
```

**nonlocal** **지역변수**

현재 함수의 바깥쪽에 있는 지역 변수의 값을 변경하려면 nonlocal 키워드를 사용해야 합니다. 즉, nonlocal은 현재 함수의 지역 변수가 아니라는 뜻이며 바깥쪽 함수의 지역 변수를 사용합니다.

```python
def A():
    x = 10
    y = 100
    def B():
        x = 20
        def C():
            nonlocal x
            nonlocal y
            x = x + 30
            y = y + 300
            print(x)
            print(y)
        C()
    B()
 
A()


# 50
# 400
```

함수 C에서 nonlocal x를 사용하면 바깥쪽에 있는 함수 B의 지역 변수 x = 20을 사용하게 됩니다. 따라서 x = x + 30은 50이 나옵니다. 그리고 함수 C에서 nonlocal y를 사용하면 바깥쪽에 있는 함수의 지역 변수 y를 사용해야 하는데 함수 B에는 y가 없습니다. 이때는 한 단계 더 바깥으로 나가서 함수 A의 지역 변수 y를 사용하게 됩니다. 즉, 가까운 함수부터 지역 변수를 찾고, 지역 변수가 없으면 계속 바깥쪽으로 나가서 찾습니다.

```python
x = 1
def A():
    x = 10
    def B():
        x = 20
        def C():
            global x
            x = x + 30
            print(x)
        C()
    B()
 
A()


# 31
```

함수가 몇 단계든 상관없이 global 키워드를 사용하면 무조건 전역 변수를 사용하게 됩니다. 함수 C에서 global x를 사용하면 전역 변수 x = 1을 사용하게 됩니다. 따라서 x = x + 30은 31이 나옵니다.

```python
def calc():
    a = 3
    b = 5
    def mul_add(x):
        return a * x + b    # 함수 바깥쪽에 있는 지역 변수 a, b를 사용하여 계산
    return mul_add          # mul_add 함수를 반환
 
c = calc()
print(c(1), c(2), c(3), c(4), c(5))

# 8 11 14 17 20
```

함수 mul_add를 만든 뒤에는 이 함수를 바로 호출하지 않고 return으로 함수 자체를 반환합니다(함수를 반환할 때는 함수 이름만 반환해야 하며 ( )(괄호)를 붙이면 안 됩니다).  함수 calc를 호출한 뒤 반환값을 c에 저장합니다. calc에서 mul_add를 반환했으므로 c에는 함수 mul_add가 들어갑니다. 그리고 c에 숫자를 넣어서 호출해보면 a * x + b 계산식에 따라 값이 출력됩니다.

함수 calc가 끝났는데도 c는 calc의 지역 변수 a, b를 사용해서 계산을 하고 있습니다. 이렇게 함수를 둘러싼 환경(지역 변수, 코드 등)을 계속 유지하다가, 함수를 호출할 때 다시 꺼내서 사용하는 함수를 클로저(closure)라고 합니다. 여기서는 c에 저장된 함수가 클로저입니다.

클로저를 사용하면 프로그램의 흐름을 변수에 저장할 수 있습니다. 즉, 클로저는 지역 변수와 코드를 묶어서 사용하고 싶을 때 활용합니다. 또한, 클로저에 속한 지역 변수는 바깥에서 직접 접근할 수 없으므로 데이터를 숨기고 싶을 때 활용합니다.

```python
def calc():
    a = 3
    b = 5
    return lambda x: a * x + b    # 람다 표현식을 반환
 
c = calc()
print(c(1), c(2), c(3), c(4), c(5))

# 8 11 14 17 20
```

보통 클로저는 람다 표현식과 함께 사용하는 경우가 많아 둘을 혼동하기 쉽습니다. 람다는 이름이 없는 익명 함수를 뜻하고, 클로저는 함수를 둘러싼 환경을 유지했다가 나중에 다시 사용하는 함수를 뜻합니다.

```python
def calc():
    a = 3
    b = 5
    total = 0
    def mul_add(x):
        nonlocal total
        total = total + a * x + b
        print(total)
    return mul_add
 
c = calc()
c(1)
c(2)
c(3)

# 8
# 19
# 33
```

클로저의 지역 변수를 변경하고 싶다면 nonlocal을 사용하면 됩니다. 다음은 a * x + b의 결과를 함수 calc의 지역 변수 total에 누적합니다.

## 클래스 사용하기

객체지향 프로그래밍은 복잡한 문제를 잘게 나누어 객체로 만들고, 객체를 조합해서 문제를 해결합니다. 따라서 현실 세계의 복잡한 문제를 처리하는데 유용하며 기능을 개선하고 발전시킬 때도 해당 클래스만 수정하면 되므로 유지 보수에도 효율적입니다

클래스는 class에 클래스 이름을 지정하고 :(콜론)을 붙인 뒤 다음 줄부터 def로 메서드를 작성하면 됩니다. 여기서 메서드는 클래스 안에 들어있는 함수를 뜻합니다. 메서드의 첫 번째 매개변수는 반드시 self를 지정해야 합니다.

```python
class 클래스이름:
    def 메서드(self):
        코드
        
>>> class Person:
...     def greeting(self):
...         print('Hello')
...
```

**인스턴스 = 클래스()**

```python
>>> james = Person()

>>> james.greeting()
Hello
```

Person으로 변수 james를 만들었는데 이 james가 Person의 인스턴스(instance)입니다. 클래스는 특정 개념을 표현만 할뿐 사용을 하려면 인스턴스를 생성해야 합니다. 메서드는 클래스가 아니라 인스턴스를 통해 호출합니다. 다음과 같이 인스턴스 뒤에 .(점)을 붙이고 메서드를 호출하면 됩니다.

**인스턴스.메서드()**

```python
>>> james.greeting()
Hello
```

 이렇게 인스턴스를 통해 호출하는 메서드를 **인스턴스 메서드**라고 부릅니다.

int, list, dict 등도 사실 클래스입니다. 우리는 이 클래스로 인스턴스를 만들고 메서드를 사용했습니다.

```python
>>> a = int(10)
>>> a
10
>>> b = list(range(10))
>>> b
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> c = dict(x=10, y=20)
>>> c
{'x': 10, 'y': 20}
```

int 클래스에 10을 넣어서 인스턴스 a를 만들었습니다. 마찬가지로 list 클래스에 range(10)을 넣어서 인스턴스 b를 만들고, dict 클래스에 x=10, y=20을 넣어서 인스턴스 c를 만들었습니다.

인스턴스 b에서 메서드 append를 호출해서 값을 추가합니다. 

```python
>>> b = list(range(10))
>>> b.append(20)
>>> b
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 20]
```

즉, 파이썬에서는 자료형도 클래스입니다. 다음과 같이 type을 사용하면 객체(인스턴스)가 어떤 클래스인지 확인할 수 있습니다.

```python
>>> a = 10
>>> type(a)
<class 'int'>
>>> b = [0, 1, 2]
>>> type(b)
<class 'list'>
>>> c = {'x':10, 'y':20}
>>> type(c)
<class 'dict'>
>>> maria = Person()
>>> type(maria)
<class '__main__.Person'>
```

사실 인스턴스와 객체는 같은 것을 뜻합니다. 보통 객체만 지칭할 때는 그냥 객체(object)라고 부릅니다. 하지만 클래스와 연관지어서 말할 때는 인스턴스(instance)라고 부릅니다. 그래서 다음과 같이 리스트 변수 a, b가 있으면 a, b는 객체입니다. 그리고 a와 b는 list 클래스의 인스턴스입니다.

```python
>>> a = list(range(10))
>>> b = list(range(20))
```

메서드 안에서 메서드를 호출할 때는 다음과 같이 **self.메서드()** 형식으로 호출해야 합니다. self 없이 메서드 이름만 사용하면 클래스 바깥쪽에 있는 함수를 호출한다는 뜻이 되므로 주의해야 합니다

```python
class Person:
    def greeting(self):
        print('Hello')
 
    def hello(self):
        self.greeting()    # self.메서드() 형식으로 클래스 안의 메서드를 호출
 
james = Person()
james.hello()    # Hello
```

현재 인스턴스가 특정 클래스의 인스턴스인지 확인할 때는 isinstance 함수를 사용합니다. 특정 클래스의 인스턴스가 맞으면 True, 아니면 False를 반환합니다.

**isinstance(인스턴스, 클래스)**

```python
>>> class Person:
...     pass
...
>>> james = Person()
>>> isinstance(james, Person)
True

def factorial(n):
    if not isinstance(n, int) or n < 0:    # n이 정수가 아니거나 음수이면 함수를 끝냄
        return None
    if n == 1:
        return 1
    return n * factorial(n - 1)
```

isinstance는 주로 객체의 자료형을 판단할 때 사용합니다.

속성(attribute)을 만들 때는 `__init__` 메서드 안에서 **self.속성**에 값을 할당합니다.

```python
class 클래스이름:
    def __init__(self):
        self.속성 = 값
        
class Person:
    def __init__(self):
        self.hello = '안녕하세요.'
 
    def greeting(self):
        print(self.hello)
 
james = Person()
james.greeting()    # 안녕하세요.
```

`__init__` 메서드는 james = Person()처럼 클래스에 ( )(괄호)를 붙여서 **인스턴스를 만들 때 호출되는 특별한 메서드**입니다. 즉, init(initialize)이라는 이름 그대로 인스턴스(객체)를 초기화합니다.

특히 이렇게 앞 뒤로 __(밑줄 두 개)가 붙은 메서드는 파이썬이 자동으로 호출해주는 메서드인데 스페셜 메서드(special method) 또는 매직 메서드(magic method)라고 부릅니다. 

속성은 init 메서드에서 만든다는 점과 self에 .(점)을 붙인 뒤 값을 할당한다는 점이 중요합니다. 클래스 안에서 속성을 사용할 때도 self.hello처럼 self에 점을 붙여서 사용하면 됩니다.

```python
class 클래스이름:
    def __init__(self, 매개변수1, 매개변수2):
        self.속성1 = 매개변수1
        self.속성2 = 매개변수2
        
class Person:
    def __init__(self, name, age, address):
        self.hello = '안녕하세요.'
        self.name = name
        self.age = age
        self.address = address
 
    def greeting(self):
        print('{0} 저는 {1}입니다.'.format(self.hello, self.name))
 
maria = Person('마리아', 20, '서울시 서초구 반포동')
maria.greeting()    # 안녕하세요. 저는 마리아입니다.
 
print('이름:', maria.name)       # 마리아
print('나이:', maria.age)        # 20
print('주소:', maria.address)    # 서울시 서초구 반포동

안녕하세요. 저는 마리아입니다.
이름: 마리아
나이: 20
주소: 서울시 서초구 반포동
```

클래스 바깥에서 속성에 접근할 때는 **인스턴스.속성** 형식으로 접근합니다.

```python
class Person:
    def __init__(self, *args):
        self.name = args[0]
        self.age = args[1]
        self.address = args[2]
 
maria = Person(*['마리아', 20, '서울시 서초구 반포동'])

class Person:
    def __init__(self, **kwargs):    # 키워드 인수
        self.name = kwargs['name']
        self.age = kwargs['age']
        self.address = kwargs['address']
 
maria1 = Person(name='마리아', age=20, address='서울시 서초구 반포동')
maria2 = Person(**{'name': '마리아', 'age': 20, 'address': '서울시 서초구 반포동'})
```

```python
>>> class Person:
...     pass
...
>>> maria = Person()         # 인스턴스 생성
>>> maria.name = '마리아'    # 인스턴스를 만든 뒤 속성 추가
>>> maria.name
'마리아'
```

클래스로 인스턴스를 만든 뒤에도 **인스턴스.속성 = 값** 형식으로 속성을 계속 추가할 수 있습니다. 다음 Person 클래스는 빈 클래스이지만 인스턴스를 만든 뒤 name 속성을 추가합니다. 이렇게 추가한 속성은 해당 인스턴스에만 생성됩니다. 따라서 클래스로 다른 인스턴스를 만들었을 때는 추가한 속성이 생성되지 않습니다.

```python
>>> james = Person()    # james 인스턴스 생성
>>> james.name    # maria 인스턴스에만 name 속성을 추가했으므로 james 인스턴스에는 name 속성이 없음
Traceback (most recent call last):
  File "<pyshell#11>", line 1, in <module>
    james.name
AttributeError: 'Person' object has no attribute 'name'
```

```python
>>> class Person:
...     def greeting(self):
...         self.hello = '안녕하세요'    # greeting 메서드에서 hello 속성 추가
...
>>> maria = Person()
>>> maria.hello    # 아직 hello 속성이 없음
Traceback (most recent call last):
  File "<pyshell#22>", line 1, in <module>
    maria.hello
AttributeError: 'Person' object has no attribute 'hello'
>>> maria.greeting()    # greeting 메서드를 호출해야
>>> maria.hello         # hello 속성이 생성됨
'안녕하세요'
```

`__init__` 메서드가 아닌 다른 메서드에서도 속성을 추가할 수 있습니다. 단, 이때는 메서드를 호출해야 속성이 생성됩니다.

인스턴스는 자유롭게 속성을 추가할 수 있지만 특정 속성만 허용하고 다른 속성은 제한하고 싶을 수도 있습니다. 이때는 클래스에서 `__slots__`에 허용할 속성 이름을 리스트로 넣어주면 됩니다. 특히 속성 이름은 반드시 문자열로 지정해줍니다.

`__slots__` = ['속성이름1', '속성이름2']**

```python
>>> class Person:
...     __slots__ = ['name', 'age']    # name, age만 허용(다른 속성은 생성 제한)
...
>>> maria = Person()
>>> maria.name = '마리아'                     # 허용된 속성
>>> maria.age = 20                            # 허용된 속성
>>> maria.address = '서울시 서초구 반포동'    # 허용되지 않은 속성은 추가할 때 에러가 발생함
Traceback (most recent call last):
  File "<pyshell#32>", line 1, in <module>
    maria.address = '서울시 서초구 반포동'
AttributeError: 'Person' object has no attribute 'address'
```

클래스 바깥에서는 접근할 수 없고 클래스 안에서만 사용할 수 있는 비공개 속성(private attribute)을 사용해보겠습니다.

비공개 속성은 **__****속성**과 같이 이름이 __(밑줄 두 개)로 시작해야 합니다. 단,`__속성__`처럼 밑줄 두 개가 양 옆에 왔을 때는 비공개 속성이 아니므로 주의해야 합니다.

```python
class 클래스이름:
    def __init__(self, 매개변수)
        self.__속성 = 값
        
class Person:
    def __init__(self, name, age, address, wallet):
        self.name = name
        self.age = age
        self.address = address
        self.__wallet = wallet    # 변수 앞에 __를 붙여서 비공개 속성으로 만듦
 
maria = Person('마리아', 20, '서울시 서초구 반포동', 10000)
maria.__wallet -= 10000    # 클래스 바깥에서 비공개 속성에 접근하면 에러가 발생함

Traceback (most recent call last):
  File "C:\project\class_private_attribute_error.py", line 9, in <module>
    maria.__wallet -= 10000    # 클래스 바깥에서 비공개 속성에 접근하면 에러가 발생함
AttributeError: 'Person' object has no attribute '__wallet' 
```

```python
class Person:
    def __init__(self, name, age, address, wallet):
        self.name = name
        self.age = age
        self.address = address
        self.__wallet = wallet    # 변수 앞에 __를 붙여서 비공개 속성으로 만듦
 
    def pay(self, amount):
        self.__wallet -= amount   # 비공개 속성은 클래스 안의 메서드에서만 접근할 수 있음
        print('이제 {0}원 남았네요.'.format(self.__wallet))
 
maria = Person('마리아', 20, '서울시 서초구 반포동', 10000)
maria.pay(3000)

# 이제 7000원 남았네요.
```

비공개 속성은 클래스 바깥으로 드러내고 싶지 않은 값에 사용합니다. 즉, 중요한 값인데 바깥에서 함부로 바꾸면 안될 때 비공개 속성을 주로 사용합니다. 비공개 속성을 바꾸는 경우는 클래스의 메서드로 한정합니다.

속성뿐만 아니라 메서드도 이름이 __(밑줄 두 개)로 시작하면 클래스 안에서만 호출할 수 있는 비공개 메서드가 됩니다.

```python
class Person:
    def __greeting(self):
        print('Hello')
 
    def hello(self):
        self.__greeting()    # 클래스 안에서는 비공개 메서드를 호출할 수 있음
 
james = Person()
james.__greeting()    # 에러: 클래스 바깥에서는 비공개 메서드를 호출할 수 없음
```

속성에는 클래스 속성과 인스턴스 속성 두 가지 종류가 있습니다. `__init__` 메서드에서 만들었던 속성은 인스턴스 속성입니다.

```python
class 클래스이름:
    속성 = 값
    
class Person:
    bag = []
 
    def put_bag(self, stuff):
        self.bag.append(stuff)
 
james = Person()
james.put_bag('책')
 
maria = Person()
maria.put_bag('열쇠')
 
print(james.bag)
print(maria.bag)

# ['책', '열쇠']
# ['책', '열쇠']
```

 james와 maria 인스턴스를 만들고 각자 put_bag 메서드로 물건을 넣었는데, james.bag과 maria.bag을 출력해보면 넣었던 물건이 합쳐져서 나옵니다. 즉, 클래스 속성은 클래스에 속해 있으며 모든 인스턴스에서 공유합니다.

put_bag 메서드에서 클래스 속성 bag에 접근할 때 self를 사용했습니다. 사실 self는 현재 인스턴스를 뜻하므로 클래스 속성을 지칭하기에는 조금 모호합니다.

```python
class Person:
    bag = []
 
    def put_bag(self, stuff):
        Person.bag.append(stuff)    # 클래스 이름으로 클래스 속성에 접근

print(Person.bag)
```

클래스 속성에 접근할 때는 클래스 이름으로 접근하면 좀 더 코드가 명확해집니다.

클래스 바깥에서도 클래스 이름으로 클래스 속성에 접근하면 됩니다.

```python
class Person:
    def __init__(self):
        self.bag = []
 
    def put_bag(self, stuff):
        self.bag.append(stuff)
 
james = Person()
james.put_bag('책')
 
maria = Person()
maria.put_bag('열쇠')
 
print(james.bag)
print(maria.bag)

# ['책']
# ['열쇠']
```

클래스 속성: 모든 인스턴스가 공유. 인스턴스 전체가 사용해야 하는 값을 저장할 때 사용

인스턴스 속성: 인스턴스별로 독립되어 있음. 각 인스턴스가 값을 따로 저장해야 할 때 사용

```python
class 클래스이름:
    __속성 = 값    # 비공개 클래스 속성
    
class Knight:
    __item_limit = 10    # 비공개 클래스 속성
 
    def print_item_limit(self):
        print(Knight.__item_limit)    # 클래스 안에서만 접근할 수 있음
 
 
x = Knight()
x.print_item_limit()    # 10
 
print(Knight.__item_limit)    # 클래스 바깥에서는 접근할 수 없음

10
Traceback (most recent call last):
  File "C:\project\class_private_class_attribute_error.py ", line 11, in <module>
    print(Knight.__item_limit)    # 클래스 바깥에서는 접근할 수 없음
AttributeError: type object 'Knight' has no attribute '__item_limit' 
```

클래스와 메서드도 독스트링을 사용할 수 있습니다. 다음과 같이 클래스와 메서드를 만들 때 :(콜론) 바로 다음 줄에 """ """(큰따옴표 세 개) 또는 ''' '''(작은따옴표 세 개)로 문자열을 입력하면 됩니다. 그리고 클래스의 독스트링은 `클래스.__doc__` 형식으로 사용하고, 메서드의 독스트링은 `클래스.메서드.__doc__` 또는 `인스턴스.메서드.__doc__` 형식으로 사용합니다.

```python
class Person:
    '''사람 클래스입니다.'''
    
    def greeting(self):
        '''인사 메서드입니다.'''
        print('Hello')
 
print(Person.__doc__)             # 사람 클래스입니다.
print(Person.greeting.__doc__)    # 인사 메서드입니다.
 
maria = Person()
print(maria.greeting.__doc__)     # 인사 메서드입니다.
```

**인스턴스를 통하지 않고 클래스에서 바로 호출할 수 있는 정적 메서드**는 다음과 같이 메서드 위에 @staticmethod를 붙입니다.

이때 정적 메서드는 매개변수에 self를 지정하지 않습니다.

```python
class 클래스이름:
    @staticmethod
    def 메서드(매개변수1, 매개변수2):
        코드
        
class Calc:
    @staticmethod
    def add(a, b):
        print(a + b)
 
    @staticmethod
    def mul(a, b):
        print(a * b)
 
Calc.add(10, 20)    # 클래스에서 바로 메서드 호출
Calc.mul(10, 20)    # 클래스에서 바로 메서드 호출

# 30
# 200
```

@staticmethod처럼 앞에 @이 붙은 것을 데코레이터라고 하며 메서드(함수)에 추가 기능을 구현할 때 사용합니다.

정적 메서드는 self를 받지 않으므로 인스턴스 속성에는 접근할 수 없습니다. 그래서 보통 정적 메서드는 인스턴스 속성, 인스턴스 메서드가 필요 없을 때 사용합니다. 여기서 만든 Calc 클래스에 들어있는 add, mul 메서드는 숫자 두개를 받아서 더하거나 곱할 뿐 인스턴스의 속성은 필요하지 않습니다.

정적 메서드는 메서드의 실행이 외부 상태에 영향을 끼치지 않는 순수 함수(pure function)를 만들 때 사용합니다. 순수 함수는 부수 효과(side effect)가 없고 입력 값이 같으면 언제나 같은 출력 값을 반환합니다. 즉, 정적 메서드는 인스턴스의 상태를 변화시키지 않는 메서드를 만들 때 사용합니다.

```python
>>> a = {1, 2, 3, 4}
>>> a.update({5})    # 인스턴스 메서드
>>> a
{1, 2, 3, 4, 5}
>>> set.union({1, 2, 3, 4}, {5})    # 정적(클래스) 메서드
{1, 2, 3, 4, 5}
```

파이썬의 자료형도 인스턴스 메서드와 정적, 클래스 메서드로 나뉘어져 있습니다. 예를 들어 세트에 요소를 더할 때는 인스턴스 메서드를 사용하고, 합집합을 구할 때는 정적 메서드를 사용하도록 만들어져 있습니다. 이처럼 인스턴스의 내용을 변경해야 할 때는 update와 같이 인스턴스 메서드로 작성하면 되고, 인스턴스 내용과는 상관없이 결과만 구하면 될 때는 set.union과 같이 정적 메서드로 작성하면 됩니다.

**클래스 메서드는 다음과 같이 메서드 위에 @classmethod를 붙입니다.** 이때 클래스 메서드는 첫 번째 매개변수에 cls를 지정해야 합니다(cls는 **cl**a**s**s에서 따왔습니다).

```python
class 클래스이름:
    @classmethod
    def 메서드(cls, 매개변수1, 매개변수2):
        코드
        
class Person:
    count = 0    # 클래스 속성
 
    def __init__(self):
        Person.count += 1    # 인스턴스가 만들어질 때
                             # 클래스 속성 count에 1을 더함
 
    @classmethod
    def print_count(cls):
        print('{0}명 생성되었습니다.'.format(cls.count))    # cls로 클래스 속성에 접근
 
james = Person()
maria = Person()
 
Person.print_count()    # 2명 생성되었습니다.
```

인스턴스가 만들어질 때마다 숫자를 세야 하므로 `__init__` 메서드에서 클래스 속성 count에 1을 더해줍니다. 물론 클래스 속성에 접근한다는 것을 명확하게 하기 위해 Person.count와 같이 만들어줍니다. 이제 @classmethod를 붙여서 클래스 메서드를 만듭니다. 클래스 메서드는 첫 번째 매개변수가 cls인데 여기에는 현재 클래스가 들어옵니다. 따라서 cls.count처럼 cls로 클래스 속성 count에 접근할 수 있습니다. Person으로 인스턴스를 두 개 만들었으므로 print_count를 호출해보면 '2명 생성되었습니다.'가 출력됩니다. 물론 print_count는 클래스 메서드이므로 Person.print_count()처럼 클래스로 호출해줍니다.

클래스 메서드는 정적 메서드처럼 인스턴스 없이 호출할 수 있다는 점은 같습니다. 하지만 클래스 메서드는 메서드 안에서 클래스 속성, 클래스 메서드에 접근해야 할 때 사용합니다.

특히 cls를 사용하면 메서드 안에서 현재 클래스의 인스턴스를 만들 수도 있습니다. 즉, cls는 클래스이므로 cls()는 Person()과 같습니다.

```python
    @classmethod
    def create(cls):
        p = cls()    # cls()로 인스턴스 생성
        return p
```

## 클래스 상속 사용하기

기능을 물려주는 클래스를 기반 클래스(base class), 상속을 받아 새롭게 만드는 클래스를 파생 클래스(derived class)라고 합니다. 새로운 기능이 필요할 때마다 계속 클래스를 만든다면 중복되는 부분을 반복해서 만들어야 합니다. 이럴 때 상속을 사용하면 중복되는 기능을 만들지 않아도 됩니다. 따라서 상속은 기존 기능을 재사용할 수 있어서 효율적입니다.

```python
class 기반클래스이름:
    코드
 
class 파생클래스이름(기반클래스이름):
    코드
    
class Person:
    def greeting(self):
        print('안녕하세요.')
 
class Student(Person):
    def study(self):
        print('공부하기')
 
james = Student()
james.greeting()    # 안녕하세요.: 기반 클래스 Person의 메서드 호출
james.study()       # 공부하기: 파생 클래스 Student에 추가한 study 메서드

# 안녕하세요.
# 공부하기
```

클래스의 상속 관계를 확인하고 싶을 때는 issubclass 함수를 사용합니다. 즉, 클래스가 기반 클래스의 파생 클래스인지 확인합니다. 기반 클래스의 파생 클래스가 맞으면 True, 아니면 False를 반환합니다.

**issubclass(파생클래스, 기반클래스)**

```python
>>> class Person:
...     pass
...
>>> class Student(Person):
...     pass
...
>>> issubclass(Student, Person)
True
```

상속은 명확하게 같은 종류이며 동등한 관계일 때 사용합니다. 즉, "학생은 사람이다."라고 했을 때 말이 되면 동등한 관계입니다. 그래서 상속 관계를 영어로 is-a 관계라고 부릅니다(Student is a Person).

```python
class Person:
    def greeting(self):
        print('안녕하세요.')
 
class PersonList:
    def __init__(self):
        self.person_list = []    # 리스트 속성에 Person 인스턴스를 넣어서 관리
 
    def append_person(self, person):    # 리스트 속성에 Person 인스턴스를 추가하는 함수
        self.person_list.append(person)
```

여기서는 상속을 사용하지 않고 속성에 인스턴스를 넣어서 관리하므로 PersonList가 Person을 포함하고 있습니다. 이러면 사람 목록 PersonList와 사람 Person은 동등한 관계가 아니라 포함 관계입니다. 즉, "사람 목록은 사람을 가지고 있다."라고 말할 수 있습니다. 그래서 포함 관계를 영어로 has-a 관계라고 부릅니다(PersonList has a Person).

```python
class Person:
    def __init__(self):
        print('Person __init__')
        self.hello = '안녕하세요.'
 
class Student(Person):
    def __init__(self):
        print('Student __init__')
        self.school = '파이썬 코딩 도장'
 
james = Student()
print(james.school)
print(james.hello)    # 기반 클래스의 속성을 출력하려고 하면 에러가 발생함


Student __init__
파이썬 코딩 도장
Traceback (most recent call last):
  File "C:\project\class_inheritance_attribute_error.py", line 14, in <module>
    print(james.hello)
AttributeError: 'Student' object has no attribute 'hello' 
```

실행을 해보면 에러가 발생합니다. 왜냐하면 기반 클래스 Person의 `__init__` 메서드가 호출되지 않았기 때문입니다. 실행 결과를 잘 보면 'Student `__init__`'만 출력되었습니다.

즉, Person의  `__init__`메서드가 호출되지 않으면 self.hello = '안녕하세요.'도 실행되지 않아서 속성이 만들어지지 않습니다.

이때는 **super()**를 사용해서 기반 클래스의 __init__ 메서드를 호출해줍니다. 다음과 같이 super() 뒤에 .(점)을 붙여서 메서드를 호출하는 방식입니다.

**super().메서드()**

```python
class Person:
    def __init__(self):
        print('Person __init__')
        self.hello = '안녕하세요.'
 
class Student(Person):
    def __init__(self):
        print('Student __init__')
        super().__init__()                # super()로 기반 클래스의 __init__ 메서드 호출
        self.school = '파이썬 코딩 도장'
 
james = Student()
print(james.school)
print(james.hello)


Student __init__
Person __init__
파이썬 코딩 도장
안녕하세요.
```

```python
class Person:
    def __init__(self):
        print('Person __init__')
        self.hello = '안녕하세요.'
 
class Student(Person):
    pass  # 파생 클래스에 __init__ 메서드가 없다면 기반 클래스의 __init__이 자동으로 호출되므로 기반 클래스의 속성을 사용할 수 있습니다.
 
james = Student()
print(james.hello) 


Person __init__
안녕하세요.
```

```python
class Student(Person):
    def __init__(self):
        print('Student __init__')
        super(Student, self).__init__()     # super(파생클래스, self)로 기반 클래스의 메서드 호출
        self.school = '파이썬 코딩 도장'
```

super는 다음과 같이 파생 클래스와 self를 넣어서 현재 클래스가 어떤 클래스인지 명확하게 표시하는 방법도 있습니다. 물론 super()와 기능은 같습니다.

```python
class Person:
    def greeting(self):
        print('안녕하세요.')
 
class Student(Person):
    def greeting(self):
        print('안녕하세요. 저는 파이썬 코딩 도장 학생입니다.')
 
james = Student()
james.greeting()

# 안녕하세요. 저는 파이썬 코딩 도장 학생입니다.
```

오버라이딩(overriding)은 무시하다, 우선하다라는 뜻을 가지고 있는데 말 그대로 기반 클래스의 메서드를 무시하고 새로운 메서드를 만든다는 뜻입니다. 여기서는 Person 클래스의 greeting 메서드를 무시하고 Student 클래스에서 새로운 greeting 메서드를 만들었습니다.

```python
class Person:
    def greeting(self):
        print('안녕하세요.')
 
class Student(Person):
    def greeting(self):
        super().greeting()    # 기반 클래스의 메서드 호출하여 중복을 줄임
        print('저는 파이썬 코딩 도장 학생입니다.')
 
james = Student()
james.greeting()

#안녕하세요.
#저는 파이썬 코딩 도장 학생입니다.
```

Student의 greeting에서 super().greeting()으로 Person의 greeting을 호출했습니다. 즉, 중복되는 기능은 파생 클래스에서 다시 만들지 않고, 기반 클래스의 기능을 사용하면 됩니다.

**다중 상속**은 여러 기반 클래스로부터 상속을 받아서 파생 클래스를 만드는 방법입니다. 다음과 같이 클래스를 만들 때 ( )(괄호) 안에 클래스 이름을 ,(콤마)로 구분해서 넣습니다.

```python
class 기반클래스이름1:
    코드
 
class 기반클래스이름2:
    코드
 
class 파생클래스이름(기반클래스이름1, 기반클래스이름2):
    코드
    
  
    
class Person:
    def greeting(self):
        print('안녕하세요.')
 
class University:
    def manage_credit(self):
        print('학점 관리')
 
class Undergraduate(Person, University):
    def study(self):
        print('공부하기')
 
james = Undergraduate()
james.greeting()         # 안녕하세요.: 기반 클래스 Person의 메서드 호출
james.manage_credit()    # 학점 관리: 기반 클래스 University의 메서드 호출
james.study()            # 공부하기: 파생 클래스 Undergraduate에 추가한 study 메서드


# 안녕하세요.
# 학점 관리
# 공부하기
```

```python
class A:
    def greeting(self):
        print('안녕하세요. A입니다.')
 
class B(A):
    def greeting(self):
        print('안녕하세요. B입니다.')
 
class C(A):
    def greeting(self):
        print('안녕하세요. C입니다.')
 
class D(B, C):
    pass
 
x = D()
x.greeting()    # 안녕하세요. B입니다.
```

객체지향 프로그래밍에서는 이런 상속 관계를 다이아몬드 상속이라 부릅니다.

기반 클래스 A가 있고, B, C는 A를 상속받습니다. 그리고 다시 D는 B, C를 상속받습니다. 클래스 A를 상속받아서 B, C를 만들고, 클래스 B와 C를 상속받아서 D를 만들었습니다. 그리고 A, B, C 모두 greeting이라는 같은 메서드를 가지고 있다면 D는 어떤 클래스의 메서드를 호출해야 할지 애매해집니다. 그래서 다이아몬드 상속은 문제가 많다고 해서 죽음의 다이아몬드라고도 부릅니다.

많은 프로그래밍 언어들이 다이아몬드 상속에 대한 해결책을 제시하고 있는데 파이썬에서는 메서드 탐색 순서(Method Resolution Order, MRO)를 따릅니다.

- **클래스.mro()**

```python
>>> D.mro()
[<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
```

MRO에 따르면 D의 메서드 호출 순서는 자기 자신 D, 그 다음이 B입니다. 따라서 D로 인스턴스를 만들고 greeting을 호출하면 B의 greeting이 호출됩니다( D는 greeting 메서드가 없으므로). 파이썬은 다중 상속을 한다면 class D(B, C):의 클래스 목록 중 왼쪽에서 오른쪽 순서로 메서드를 찾습니다. 그러므로 같은 메서드가 있다면 B가 우선합니다. 

파이썬에서 object는 모든 클래스의 조상입니다. 그래서 int의 MRO를 출력해보면 int 자기 자신과 object가 출력됩니다.

```python
>>> int.mro()
[<class 'int'>, <class 'object'>]

class X:
    pass
    
class X(object):
    pass
  
# 파이썬 3에서 모든 클래스는 object 클래스를 상속받으므로 기본적으로 object를 생략합니다. 괄호 안에 object를 넣은 것과 같습니다.
```

추상 클래스는 메서드의 목록만 가진 클래스이며 상속받는 클래스에서 메서드 구현을 강제하기 위해 사용합니다.

먼저 추상 클래스를 만들려면 import로 abc 모듈을 가져와야 합니다( abc는 **a**bstract **b**ase **c**lass의 약자입니다). 그리고 클래스의 ( )(괄호) 안에 metaclass=ABCMeta를 지정하고, 메서드를 만들 때 위에 @abstractmethod를 붙여서 추상 메서드로 지정합니다.

```python
from abc import *
 
class 추상클래스이름(metaclass=ABCMeta):
    @abstractmethod
    def 메서드이름(self):
        코드
```

```python
from abc import *
 
class StudentBase(metaclass=ABCMeta):
    @abstractmethod
    def study(self):
        pass
 
    @abstractmethod
    def go_to_school(self):
        pass
 
class Student(StudentBase):
    def study(self):
        print('공부하기')
 
james = Student()
james.study()


Traceback (most recent call last):
  File "C:\project\class_abc_error.py", line 16, in <module>
    james = Student()
TypeError: Can't instantiate abstract class Student with abstract methods go_to_school 
```

StudentBase에서는 추상 메서드로 study와 go_to_school을 정의했습니다. 하지만 StudentBase를 상속받은 Student에서는 study 메서드만 구현하고, go_to_school 메서드는 구현하지 않았으므로 에러가 발생합니다.

따라서 추상 클래스를 상속받았다면 @abstractmethod가 붙은 추상 메서드를 모두 구현해야 합니다. 

```python
from abc import *
 
class StudentBase(metaclass=ABCMeta):
    @abstractmethod
    def study(self):
        pass
 
    @abstractmethod
    def go_to_school(self):
        pass
 
class Student(StudentBase):
    def study(self):
        print('공부하기')
 
    def go_to_school(self):
        print('학교가기')
 
james = Student()
james.study()
james.go_to_school()


# 공부하기
# 학교가기
```

StudentBase는 학생이 반드시 해야 하는 일들을 추상 메서드로 만들었습니다. 그리고 Student에는 추상 클래스 StudentBase의 모든 추상 메서드를 구현하여 학생 클래스를 작성했습니다. 이처럼 추상 클래스는 파생 클래스가 반드시 구현해야 하는 메서드를 정해줄 수 있습니다.

참고로 추상 클래스의 추상 메서드를 모두 구현했는지 확인하는 시점은 파생 클래스가 인스턴스를 만들 때입니다. 따라서 james = Student()에서 확인합니다(구현하지 않았다면 TypeError 발생).

```python
>>> james = StudentBase()
Traceback (most recent call last):
  File "<pyshell#3>", line 1, in <module>
    james = StudentBase()
TypeError: Can't instantiate abstract class StudentBase with abstract methods go_to_school, study
```

추상 클래스 StudentBase로 인스턴스를 만들면 에러가 발생합니다. 추상 클래스는 인스턴스로 만들 수가 없습니다.

```python
@abstractmethod
    def study(self):
        pass    # 추상 메서드는 호출할 일이 없으므로 빈 메서드로 만듦
 
    @abstractmethod
    def go_to_school(self):
        pass    # 추상 메서드는 호출할 일이 없으므로 빈 메서드로 만듦
```

추상 클래스는 인스턴스로 만들 때는 사용하지 않으며 오로지 상속에만 사용합니다. 그리고 파생 클래스에서 반드시 구현해야 할 메서드를 정해 줄 때 사용합니다.

## 예외 처리 사용하기

예외(exception)란 코드를 실행하는 중에 발생한 에러를 뜻합니다.

```python
>>> def ten_div(x):
...     return 10 / x
...

>>> ten_div(2)
5.0

>>> ten_div(0)
Traceback (most recent call last):
  File "<pyshell#121>", line 1, in <module>
    ten_div(0)
  File "<pyshell#119>", line 2, in ten_div
    return 10 / x
ZeroDivisionError: division by zero 
```

여기서는 어떤 숫자를 0으로 나누어서 ZeroDivisionError 예외가 발생했습니다.

```python
try:
    실행할 코드
except:
    예외가 발생했을 때 처리하는 코드
    
try:
    x = int(input('나눌 숫자를 입력하세요: '))
    y = 10 / x
    print(y)
except:    # 예외가 발생했을 때 실행됨
    print('예외가 발생했습니다.')
    

나눌 숫자를 입력하세요: 0 (입력)
예외가 발생했습니다.    
```

숫자를 0으로 나누면 ZeroDivisionError 예외가 발생합니다. 여기서는 except에서 예외 처리를 하도록 만들었으므로 '예외가 발생했습니다.'가 출력됩니다.  예외가 발생하면 해당 줄에서 코드 실행을 중단하고 바로 except로 가서 코드를 실행합니다. 즉, try의 y = 10 / x를 비롯하여 그 아래줄에 있는 print(y)도 실행되지 않습니다.

```python
y = [10, 20, 30]
 
try:
    index, x = map(int, input('인덱스와 나눌 숫자를 입력하세요: ').split())
    print(y[index] / x)
except ZeroDivisionError:    # 숫자를 0으로 나눠서 에러가 발생했을 때 실행됨
    print('숫자를 0으로 나눌 수 없습니다.')
except IndexError:           # 범위를 벗어난 인덱스에 접근하여 에러가 발생했을 때 실행됨
    print('잘못된 인덱스입니다.')
    
    
인덱스와 나눌 숫자를 입력하세요: 2 0 (입력)
숫자를 0으로 나눌 수 없습니다.

인덱스와 나눌 숫자를 입력하세요: 3 5 (입력)
잘못된 인덱스입니다.
```

except에서 as 뒤에 변수를 지정하면 발생한 예외의 에러 메시지를 받아올 수 있습니다. 보통 예외( **e**xception)의 e를 따서 변수 이름을 e로 짓습니다.

```python
y = [10, 20, 30]
 
try:
    index, x = map(int, input('인덱스와 나눌 숫자를 입력하세요: ').split())
    print(y[index] / x)
except ZeroDivisionError as e:                    # as 뒤에 변수를 지정하면 에러를 받아옴
    print('숫자를 0으로 나눌 수 없습니다.', e)    # e에 저장된 에러 메시지 출력
except IndexError as e:
    print('잘못된 인덱스입니다.', e)
    

인덱스와 나눌 숫자를 입력하세요: 2 0 (입력)
숫자를 0으로 나눌 수 없습니다. division by zero


인덱스와 나눌 숫자를 입력하세요: 3 5 (입력)
잘못된 인덱스입니다. list index out of range
```

예외가 여러 개 발생하더라도 먼저 발생한 예외의 처리 코드만 실행됩니다(또는, 예외 중에서 높은 계층의 예외부터 처리됩니다. 기반 클래스 > 파생 클래스 순).

모든 예외의 에러 메시지를 출력하고 싶다면 다음과 같이 except에 Exception을 지정하고 as 뒤에 변수를 넣으면 됩니다.

```python
xcept Exception as e:    # 모든 예외의 에러 메시지를 출력할 때는 Exception을 사용
    print('예외가 발생했습니다.', e)
```

```python
try:
    실행할 코드
except:
    예외가 발생했을 때 처리하는 코드
else:
    예외가 발생하지 않았을 때 실행할 코드
    
try:
    x = int(input('나눌 숫자를 입력하세요: '))
    y = 10 / x
except ZeroDivisionError:    # 숫자를 0으로 나눠서 에러가 발생했을 때 실행됨
    print('숫자를 0으로 나눌 수 없습니다.')
else:                        # try의 코드에서 예외가 발생하지 않았을 때 실행됨
    print(y)
    

나눌 숫자를 입력하세요: 2 (입력)
5.0
```

else는 except 바로 다음에 와야 하며 except를 생략할 수 없습니다.

예외 발생 여부와 상관없이 항상 코드를 실행하는 finally를 사용해보겠습니다. 특히 finally는 except와 else를 생략할 수 있습니다.

```python
try:
    실행할 코드
except:
    예외가 발생했을 때 처리하는 코드
else:
    예외가 발생하지 않았을 때 실행할 코드
finally:
    예외 발생 여부와 상관없이 항상 실행할 코드
    

try:
    x = int(input('나눌 숫자를 입력하세요: '))
    y = 10 / x
except ZeroDivisionError:    # 숫자를 0으로 나눠서 에러가 발생했을 때 실행됨
    print('숫자를 0으로 나눌 수 없습니다.')
else:                        # try의 코드에서 예외가 발생하지 않았을 때 실행됨
    print(y)
finally:                     # 예외 발생 여부와 상관없이 항상 실행됨
    print('코드 실행이 끝났습니다.')
    
    
나눌 숫자를 입력하세요: 2 (입력)
5.0
코드 실행이 끝났습니다.


나눌 숫자를 입력하세요: 0 (입력)
숫자를 0으로 나눌 수 없습니다.
코드 실행이 끝났습니다.
```

try는 함수가 아니므로 스택 프레임을 만들지 않습니다 따라서 try 안에서 변수를 만들더라도 try 바깥에서 사용할 수 있습니다. 물론 except, else, finally에서도 사용할 수 있습니다.

예외를 발생시킬 때는 raise에 예외를 지정하고 에러 메시지를 넣습니다(에러 메시지는 생략 할 수 있음).

**raise** **예외('에러메시지')**

```python
try:
    x = int(input('3의 배수를 입력하세요: '))
    if x % 3 != 0:                                 # x가 3의 배수가 아니면
        raise Exception('3의 배수가 아닙니다.')    # 예외를 발생시킴
    print(x)
except Exception as e:                             # 예외가 발생했을 때 실행됨
    print('예외가 발생했습니다.', e)
    
3의 배수를 입력하세요: 5 (입력)
예외가 발생했습니다. 3의 배수가 아닙니다.
```

5는 3의 배수가 아니므로 raise Exception('3의 배수가 아닙니다.')로 예외를 발생시켰습니다. 이때 Exception에 넣은 에러 메시지는 except Exception as e:의 e에 들어갑니다.

```python
def three_multiple():
    x = int(input('3의 배수를 입력하세요: '))
    if x % 3 != 0:                                 # x가 3의 배수가 아니면
        raise Exception('3의 배수가 아닙니다.')    # 예외를 발생시킴
    print(x)                                       # 현재 함수 안에는 except가 없으므로
                                                   # 예외를 상위 코드 블록으로 넘김
 
try:
    three_multiple()
except Exception as e:                             # 하위 코드 블록에서 예외가 발생해도 실행됨
    print('예외가 발생했습니다.', e)
    

3의 배수를 입력하세요: 5 (입력)
예외가 발생했습니다. 3의 배수가 아닙니다.
```

three_multiple 함수는 안에 try except가 없는 상태에서 raise로 예외를 발생시켰습니다. 이렇게 되면 함수 바깥에 있는 except에서 예외가 처리됩니다. 즉, 예외가 발생하더라도 현재 코드 블록에서 처리해줄 except가 없다면 except가 나올 때까지 계속 상위 코드 블록으로 올라갑니다.

만약 함수 바깥에도 처리해줄 except가 없다면 코드 실행은 중지되고 에러가 표시됩니다.

```python
>>> three_multiple()
3의 배수를 입력하세요: 5 (입력)
Traceback (most recent call last):
  File "<pyshell#5>", line 1, in <module>
    three_multiple()
  File "C:\project\try_except_function_raise.py", line 4, in three_multiple
    raise Exception('3의 배수가 아닙니다.')    # 예외를 발생시킴
Exception: 3의 배수가 아닙니다.
```

except 안에서 raise를 사용하면 현재 예외를 다시 발생시킵니다(re-raise).

```python
def three_multiple():
    try:
        x = int(input('3의 배수를 입력하세요: '))
        if x % 3 != 0:                                 # x가 3의 배수가 아니면
            raise Exception('3의 배수가 아닙니다.')    # 예외를 발생시킴
        print(x)
    except Exception as e:                             # 함수 안에서 예외를 처리함
        print('three_multiple 함수에서 예외가 발생했습니다.', e)
        raise    # raise로 현재 예외를 다시 발생시켜서 상위 코드 블록으로 넘김
 
try:
    three_multiple()
except Exception as e:                                 # 하위 코드 블록에서 예외가 발생해도 실행됨
    print('스크립트 파일에서 예외가 발생했습니다.', e)
    

3의 배수를 입력하세요: 5 (입력)
three_multiple 함수에서 예외가 발생했습니다. 3의 배수가 아닙니다.
스크립트 파일에서 예외가 발생했습니다. 3의 배수가 아닙니다.
```

three_multiple 함수 안에서 발생한 예외를 함수 안의 except에서 한 번 처리하고, raise로 예외를 다시 발생시켜서 상위 코드 블록으로 넘겼습니다. 그다음에 함수 바깥의 except에서 예외를 처리했습니다. 이런 방식으로 같은 예외를 계속 처리해줄 수 있습니다.

예외를 발생시키는 방법 중에는 assert를 사용하는 방법도 있습니다. assert는 지정된 조건식이 거짓일 때 AssertionError 예외를 발생시키며 조건식이 참이면 그냥 넘어갑니다. 보통 assert는 나와서는 안 되는 조건을 검사할 때 사용합니다.

다음은 3의 배수가 아니면 예외 발생, 3의 배수이면 그냥 넘어갑니다.

**assert** **조건식**

**assert** **조건식, 에러메시지**

```python
x = int(input('3의 배수를 입력하세요: '))
assert x % 3 == 0, '3의 배수가 아닙니다.'    # 3의 배수가 아니면 예외 발생, 3의 배수이면 그냥 넘어감
print(x)

3의 배수를 입력하세요: 5 (입력)
Traceback (most recent call last):
  File "C:\project\assertion.py", line 2, in <module>
    assert x % 3 == 0, '3의 배수가 아닙니다.'
AssertionError: 3의 배수가 아닙니다.
```

프로그래머가 직접 만든 예외를 사용자 정의 예외라고 합니다.

예외를 만드는 방법은 간단합니다. Exception을 상속받아서 새로운 클래스를 만들면 됩니다. 그리고 `__init__` 메서드에서 기반 클래스의 `__init__` 메서드를 호출하면서 에러 메시지를 넣어주면 됩니다.

```python
class 예외이름(Exception):
    def __init__(self):
        super().__init__('에러메시지')
        
        
class NotThreeMultipleError(Exception):    # Exception을 상속받아서 새로운 예외를 만듦
    def __init__(self):
        super().__init__('3의 배수가 아닙니다.')
 
def three_multiple():
    try:
        x = int(input('3의 배수를 입력하세요: '))
        if x % 3 != 0:                     # x가 3의 배수가 아니면
            raise NotThreeMultipleError    # NotThreeMultipleError 예외를 발생시킴
        print(x)
    except Exception as e:
        print('예외가 발생했습니다.', e)
 
three_multiple()


3의 배수를 입력하세요: 5 (입력)
예외가 발생했습니다. 3의 배수가 아닙니다.
```

```python
class NotThreeMultipleError(Exception):    # Exception만 상속받고
    pass                                   # 아무것도 구현하지 않음
```

참고로 다음과 같이 Exception만 상속받고 pass를 넣어서 아무것도 구현하지 않아도 됩니다.

이때는 예외를 발생시킬 때 에러 메시지를 넣어주면 됩니다.

```python
raise NotThreeMultipleError('3의 배수가 아닙니다.')    # 예외를 발생시킬 때 에러 메시지를 넣음
```
출처 : https://dojang.io

{% endraw %}
