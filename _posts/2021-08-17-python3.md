---
layout: single
tags: 
 - python

toc: true
toc_sticky: true

title: "[python] 코딩도장 03"
---

{% raw %}

## if 조건문 사용하기

조건문은 특정 조건일 때 코드를 실행하는 문법입니다. 

```python
if 비가 온다면:
    우산을 가지고 나간다.
 
if 날씨가 춥다면:
    코트를 입고 나간다.
 
if 날씨가 덥다면:
    반소매에 얇은 옷을 입고 나간다.
```

즉, 조건문을 사용하면 조건에 따라 다른 코드를 실행할 수 있습니다.

if 조건문은 if에 조건식을 지정하고 :(콜론)을 붙이며 다음 줄에 실행할 코드가 옵니다. 이때 실행할 코드는 반드시 들여쓰기를 해야 합니다.

```python
if 조건식:
     코드
```

파이썬에서 if 조건문은 **if** **조건식:** 형식으로 사용하며 그다음 줄에는 들여쓰기를 한 뒤 조건식이 만족할 때 실행할 코드를 넣습니다. 특히 이 조건식이 만족할 때 실행할 코드를 if 본문(if body)이라고 부릅니다.

```python
>>> x = 10
>>> if x == 10:
...     pass
...
>>> 

if x == 10:
    pass    # TODO: x가 10일 때 처리가 필요함
```

if 다음 줄에 pass라는 특별한 키워드를 넣었습니다. 여기서 pass는 아무 일도 하지 않고 그냥 넘어간다는 뜻입니다. 파이썬에서는 if 다음 줄에 아무 코드도 넣지 않으면 에러가 발생하므로 if 조건문의 형태를 유지하기 위해 pass를 사용합니다.

```python
x = 10
 
if x == 10:
     print('x에 들어있는 숫자는')
         print('10입니다.')     # unexpected indent 에러 발생
         
         
x = 10
 
if x == 10:
     print('x에 들어있는 숫자는')
     print('10입니다.')
```

if 다음에 오는 코드들은 반드시 들여쓰기 깊이가 같아야 합니다.

```python
x = 5          # x에 5를 할당
 
if x == 10:    # x가 5라서 조건식을 만족하지 않음
     print('x에 들어있는 숫자는')
print ('10입니다.')

#실행결과 
10입니다.
```

x가 5라서 if의 조건식을 만족하지 않으므로 다음에 오는 print('x에 들어있는 숫자는')는 실행이 되지 않습니다. 그런데 print('10입니다.')는 실행이 되었습니다. 왜냐하면 들여쓰기가 없어서 if와는 상관없는 코드가 되었기 때문입니다.

```python
x = 15
 
if x >= 10:
     print('10 이상입니다.')
 
     if x == 15:
         print('15입니다.')
 
     if x == 20:
         print('20입니다.')
      
      
# 실행결과
10 이상입니다.
15입니다.
```

들여쓰기가 된 if x == 15:와 if x == 20:은 처음에 나온 if x >= 10:에 속한 코드입니다. 즉, if x >= 10:의 조건식이 만족해야만 실행되는 코드입니다. 다시 안쪽의 if에 속한 print는 들여쓰기를 한 번 더 해줍니다.

## else 사용하기

if 조건문은 분기(branch)를 위한 문법입니다. 즉, 분기는 "둘 이상으로 갈라지다"라는 뜻으로 프로그램의 흐름을 둘 이상으로 나누는 것을 말합니다. 지금까지 if 조건문으로 조건식에 맞는 코드만 실행했습니다. if에 else를 사용하면 조건식이 만족할 때와 만족하지 않을 때 각각 다른 코드를 실행할 수 있습니다.

```python
if 광고 전화인가?:
    전화를 끊고, 차단 목록에 등록한다.
else:
    계속 통화한다.
```

else는 if 조건문 뒤에 오며 단독으로 사용할 수 없습니다. 그리고 if와 마찬가지로 else도 :(콜론)을 붙이며 다음 줄에 실행할 코드가 옵니다.

```python
>>> x = 5
>>> if x == 10:
...      print('10입니다.')
... else:
...      print('10이 아닙니다.')
... 
10이 아닙니다.
```

else는 if의 조건식이 만족하지 않을 때 코드를 실행합니다. 여기서는 x에 5가 들어있어서 x == 10을 만족하지 않으므로 else의 print가 실행되어 '10이 아닙니다.'가 출력됩니다. 즉, 조건식이 참(True)이면 if의 코드(if 본문)가 실행되고, 거짓(False)이면 else의 코드(else 본문)가 실행됩니다. 

```python
>>> x = 5
>>> if x == 10:
...     y = x
... else:
...     y = 0
...
>>> y
0
```

if, else에서 변수에 값을 할당할 때는 **변수 = 값 if 조건문 else 값** 형식으로 축약할 수 있으며 이런 문법을 조건부 표현식(conditional expression)이라고 부릅니다.

```python
>>> x = 5
>>> y = x if x == 10 else 0
>>> y
0
```

```python
if True:
    print('참')    # True는 참
else:
    print('거짓')
 
if False:
    print('참')
else:
    print('거짓')    # False는 거짓
 
if None:
    print('참')
else:
    print('거짓')    # None은 거짓
```

불값 True와 True로 취급하는 10진수, 16진수, 2진수, 실수, 문자열로 if를 동작시켰을 때 값 자체가 있으면 if는 동작합니다. 반대로 0, None, ''은 False로 취급하므로 else가 동작합니다.

```python
if not 0:
    print('참')    # not 0은 참
 
if not None:
    print('참')    # None은 참
 
if not '':
    print('참')    # not 빈 문자열은 참
```

다음은 파이썬 문법 중에서 False로 취급하는 것들입니다.

None

False

0인 숫자들: 0, 0.0, 0j

비어 있는 문자열, 리스트, 튜플, 딕셔너리, 세트: '', "", [], (), {}, set()

클래스 인스턴스의 bool(), len() 메서드가 0 또는 False를 반환할 때

앞에서 나열한 것들을 제외한 모든 요소들은 True로 취급합니다.

```python
x = 10
y = 20
 
if x == 10 and y == 20:     # x가 10이면서 y가 20일 때
    print('참')
else:
    print('거짓')
    
# 실행결과 참
```

if 조건문에는 논리 연산자를 사용하여 조건식을 여러 개 지정할 수 있습니다.

```python
if x > 0:
    if x < 20:
        print('20보다 작은 양수입니다.')
        
if x > 0 and x < 20:
    print('20보다 작은 양수입니다.')
    
if 0 < x < 20:
    print('20보다 작은 양수입니다.')
```

## elif 사용하기

프로그램을 만들다 보면 참, 거짓으로만 분기하는 것은 한계가 있습니다. 실제로는 두 가지 이상의 다양한 상황이 발생합니다.

```python
if 콜라 버튼을 눌렀다면:
    콜라를 내보냄
elif 사이다 버튼을 눌렀다면:
    사이다를 내보냄
elif 환타 버튼을 눌렀다면:
    환타를 내보냄:
else:
    제공하지 않는 메뉴
```

elif는 조건식을 여러 개 지정하여 각 조건 마다 다른 코드를 실행할 수 있습니다.

elif는 else인 상태에서 조건식을 지정할 때 사용하며 else if라는 뜻입니다. 물론 if, else와 마찬가지로 조건식 끝에 :(콜론)을 붙여야 하고, elif 단독으로 사용할 수 없습니다.

```python
x = 20
if x == 10:
   print('10입니다.')
elif x == 20:
   print('20입니다.')

# 20입니다.
```

elif와 else는 단독으로 사용할 수 없으며 if, else 형태로 사용하거나, if, elif, else 형태로 사용합니다. 

```python
x = 30
 
if x == 10:             # x가 10일 때
    print('10입니다.')
elif x == 20:           # x가 20일 때
    print('20입니다.')
else:                   # 앞의 조건식에 모두 만족하지 않을 때
    print('10도 20도 아닙니다.')
    
# 10도 20도 아닙니다.
```

참고로 if와 else는 한 번만 사용할 수 있지만, elif는 여러 번 사용할 수 있습니다. 만약 elif 앞에 else가 오면 잘못된 문법이므로 주의해야 합니다.

```python
a, b, c = 10, 20, 30
 
if a == 10:        # 조건식이 참
    print('10')    # 출력
if b == 20:        # 조건식이 참
    print('20')    # 출력
if c == 30:        # 조건식이 참
    print('30')    # 출력
    
# 실행결과
10
20
30
```

if 조건문만 사용하면 모든 if 조건문의 조건식을 검사한 뒤 코드를 실행합니다. 세 if 조건문의 조건식이 모두 만족하므로 10, 20, 30이 출력됩니다. 만약 두 번째, 세 번째 if가 elif라면 실행 결과가 달라집니다.

```python
a, b, c = 10, 20, 30
 
if a == 10:        # 조건식이 참
    print('10')    # 출력
elif b == 20:      # 조건식을 검사하지 않고 건너뜀
    print('20')
elif c == 30:      # 조건식을 검사하지 않고 건너뜀
    print('30')
    
# 실행결과
10
```

if 조건문 뒤에 elif가 연결되어 있을 때는 첫 번째 if의 조건식이 만족하면 뒤에 오는 elif의 조건식은 검사하지 않고 그냥 건너뜁니다. 예제에서는 실제로 세 조건식이 모두 만족하지만 처음에 오는 if의 코드만 실행하고, 나머지 조건식은 검사하지 않고 건너뛰었으므로 10만 출력됩니다. 첫 번째 if의 조건식이 만족하지 않았다면 두 번째 elif의 코드만 실행하고, 세 번째 elif는 건너뜁니다. 즉, 가장 처음 만족하는 if 또는 elif의 코드만 실행합니다.

```python
a, b, c = 5, 20, 30
 
if a == 10:        # 조건식이 거짓
    print('10')
elif b == 20:      # 조건식이 참
    print('20')    # 출력
elif c == 30:      # 조건식을 검사하지 않고 건너뜀
    print('30')
    
# 실행결과
20
```

## for 반복문 사용하기

대부분의 프로그래밍 언어에서는 반복되는 작업을 간단하게 처리하기 위해 반복문이라는 기능을 제공해줍니다. 반복문은 반복 횟수, 반복 및 정지 조건을 자유자재로 제어할 수 있습니다.

```python
for 변수 in range(횟수):
     반복할 코드


>>> for i in range(100):
...      print('Hello, world!')
... 
Hello, world!
... (생략)
Hello, world!
Hello, world!
Hello, world!
```

for 다음 줄에 오는 코드는 반드시 들여쓰기를 해줍니다(들여쓰기 규칙은 if, elif, else와 같습니다).

range는 연속된 숫자를 생성하고 파이썬의 for 반복문은 range에서 in으로 숫자를 하나하나 꺼내서 반복하는 방식입니다. 그리고 for는 숫자를 꺼낼 때마다 코드를 실행합니다.

range(100)과 같이 지정하면 0부터 99까지 숫자 100개를 생성합니다. 그리고 for는 in으로 숫자를 하나씩 꺼내서 변수 i에 저장하고, print를 실행합니다. 즉, range(100)에서 숫자를 100번 꺼내면서 print를 실행하므로 'Hello, world!'가 100번 출력됩니다.

이처럼 **for** **반복문은 반복 횟수가 정해져 있을 때 주로 사용합니다.**

for 변수 in range(횟수) → 반복할 코드로 순환하는 것을 루프(loop)라고 부릅니다.

```python
>>> for i in range(100):
...     print('Hello, world!', i)
...
Hello, world! 0
Hello, world! 1
Hello, world! 2
... (생략)
Hello, world! 98
Hello, world! 99
```

변수 i를 루프 인덱스라고도 부르며 index의 첫 머리글자를 따서 i를 주로 사용합니다.

```python
# 파이썬 2.7
>>> range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# 파이썬 3
>>> range(10)
range(0, 10)
>>> list(range(10))    # range 객체를 리스트로 만듦
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

파이썬 2.7과 파이썬 3에서 range는 결과가 조금 다릅니다. 파이썬 2.7에서는 range를 사용하면 실제로 연속된 숫자가 들어있는 리스트를 만들어내지만 파이썬 3에서는 range 객체(반복 가능한 객체)를 만들어냅니다.

```python
>>> for i in range(5, 12):    # 5부터 11까지 반복
...     print('Hello, world!', i)
...
Hello, world! 5
Hello, world! 6
Hello, world! 7
Hello, world! 8
Hello, world! 9
Hello, world! 10
Hello, world! 11


>>> for i in range(0, 10, 2):    # 0부터 8까지 2씩 증가
...     print('Hello, world!', i)
...
Hello, world! 0
Hello, world! 2
Hello, world! 4
Hello, world! 6
Hello, world! 8

>>> for i in range(10, 0, -1):    # 10에서 1까지 1씩 감소
...     print('Hello, world!', i)
...
Hello, world! 10
Hello, world! 9
Hello, world! 8
... (생략)
Hello, world! 2
Hello, world! 1

>>> for i in reversed(range(10)):    # range에 reversed를 사용하여 숫자의 순서를 반대로 뒤집음
...     print('Hello, world!', i)    # 9부터 0까지 10번 반복
...
Hello, world! 9
Hello, world! 8
Hello, world! 7
... (생략)
Hello, world! 1
Hello, world! 0
```

 for는 range 대신 리스트, 튜플, 문자열 등 시퀀스 객체로 반복할 수 있습니다.

```python
>>> a = [10, 20, 30, 40, 50]
>>> for i in a:
...     print(i)
...
10
20
30
40
50

>>> fruits = ('apple', 'orange', 'grape')
>>> for fruit in fruits:
...     print(fruit)
...
apple
orange
grape

>>> for letter in 'Python':
...     print(letter, end=' ')
...
P y t h o n

>>> for letter in reversed('Python'):
...     print(letter, end=' ')
...
n o h t y P # reversed는 시퀀스 객체를 넣으면 시퀀스 객체를 뒤집어 줍니다(원본 객체 자체는 바뀌지 않으며 뒤집어서 꺼내줌).
```

## while 반복문 사용하기

while 반복문은 조건식으로만 동작하며 반복할 코드 안에 조건식에 영향을 주는 변화식이 들어갑니다.

```python
i = 0                     # 초기식
while i < 100:            # while 조건식
     print('Hello, world!')    # 반복할 코드
     i += 1                    # 변화식
```

초기식부터 시작하여 조건식을 판별합니다. 이때 조건식이 참(True)이면 반복할 코드와 변화식을 함께 수행합니다. 그리고 다시 조건식을 판별하여 참(True)이면 코드를 계속 반복하고, 거짓(False)이면 반복문을 끝낸 뒤 다음 코드를 실행합니다. 여기서는 조건식 → 반복할 코드 및 변화식 → 조건식으로 순환하는 부분이 루프(loop)입니다.

i < 100과 같이 조건식을 지정하여 i가 100 미만일 때만 반복하고, i가 100이 되면 반복을 끝내도록 만들었습니다. 그리고 반복할 코드의 변화식에는 i += 1로 i를 1씩 증가시켰으므로 i가 0부터 99까지 증가하면서 100번 반복하게 됩니다. 물론 변화식 i += 1을 풀어서 i = i + 1로 만들어도 동작은 같습니다.

```python
>>> i = 1
>>> while i <= 100:
...     print('Hello, world!', i)
...     i += 1
...
Hello, world! 1
Hello, world! 2
Hello, world! 3
...  (생략)
Hello, world! 99
Hello, world! 100
```

i에 1을 넣었으므로 while의 조건식은 i <= 100과 같이 지정합니다. 따라서 i가 1부터 100까지 증가하므로 100번 반복하게 됩니다. 만약 i가 101이 되면 i <= 100은 거짓( False)이므로 반복문을 끝냅니다.

```python
>>> i = 100
>>> while i > 0:
...     print('Hello, world!', i)
...     i -= 1
...
Hello, world! 100
Hello, world! 99
Hello, world! 98
... (생략)
Hello, world! 2
Hello, world! 1
```

**while 반복문은 반복 횟수가 정해지지 않았을 때 주로 사용합니다.**

```python
import random    # random 모듈을 가져옴
 
i = 0
while i != 3:    # 3이 아닐 때 계속 반복
    i = random.randint(1, 6)    # randint를 사용하여 1과 6 사이의 난수를 생성
    print(i)
    
# 실행결과
5
1
4
1
1
3 
```

다음은 1과 6 사이의 난수를 생성한 뒤 3이 나오면 반복을 끝냅니다. 그냥 3이 나올 때까지 주사위를 계속 던지는 행동과 같습니다. while 반복문에서 i != 3과 같이 조건식을 지정하여 3이 아닐 때 계속 반복하도록 만듭니다. 그리고 반복할 코드에서 i = random.randint(1, 6)과 같이 1과 6 사이의 난수를 생성하여 변수 i에 저장합니다.

이제 이 코드를 여러 번 실행해봅니다. 실행 결과를 보면 정수가 무작위로 생성되어 실행할 때마다 반복 횟수가 달라지는 것을 볼 수 있습니다. 이처럼 **while** **반복문은 반복 횟수가 정해져 있지 않을 때 유용합니다.**

```python
>>> dice = [1, 2, 3, 4, 5, 6]
>>> random.choice(dice)
1
>>> random.choice(dice)
4
>>> random.choice(dice)
3
```

random.choice 함수를 사용하면 시퀀스 객체에서 요소를 무작위로 선택할 수 있습니다. 다음은 1, 2, 3, 4, 5, 6이 들어있는 리스트에서 무작위로 숫자를 선택합니다.

```python
while True:    # while에 True를 지정하면 무한 루프
    print('Hello, world!')
    
while 1:    # 0이 아닌 숫자는 True로 취급하여 무한 루프로 동작
    print('Hello, world!')

while 'Hello':    # 내용이 있는 문자열은 True로 취급하여 무한 루프로 동작
    print('Hello, world!')
```

## break, continue로 반복문 제어하기

break: 제어흐름 중단

continue: 제어흐름 유지, 코드 실행만 건너뜀

```python
i = 0
while True:    # 무한 루프
    print(i)
    i += 1          # i를 1씩 증가시킴
    if i == 100:    # i가 100일 때
        break       # 반복문을 끝냄. while의 제어흐름을 벗어남
        
# 실행결과
0
1
2
... (생략)
97
98
99
```

먼저 while에 True를 지정하여 무한 루프를 만들고, 그 안에서 i를 1씩 증가시킵니다. 그리고 if를 사용하여 i가 100이 될 때 break를 실행합니다. 이렇게 하면 무한 루프라도 0부터 99까지만 화면에 출력합니다. 즉, 반복문 안에서 break를 실행하면 반복문은 바로 끝납니다.

```python
for i in range(10000):    # 0부터 9999까지 반복
    print(i)
    if i == 100:    # i가 100일 때
        break       # 반복문을 끝냄. for의 제어흐름을 벗어남
```

for에 range(10000)을 지정했으므로 0부터 9999까지 반복합니다. 하지만 i가 100일 때 break를 실행하므로 0부터 100까지만 출력하고 반복문을 끝냅니다.

```python
for i in range(100):       # 0부터 99까지 증가하면서 100번 반복
    if i % 2 == 0:         # i를 2로 나누었을 때 나머지가 0면 짝수
        continue           # 아래 코드를 실행하지 않고 건너뜀
    print(i)
    
# 실행결과
1
3
5
... (생략)
95
97
99
```

먼저 for를 사용하여 0부터 99까지 반복합니다. 그리고 if를 사용하여 i가 짝수이면 continue를 실행합니다( i를 2로 나누었을 때 나머지가 0이면 짝수, 0이 아니면 홀수입니다). 마지막으로 print를 사용하여 i의 값을 출력합니다.

이제 i가 짝수이면 continue를 실행하여 print를 건너뛰고, 홀수이면 print로 숫자를 출력합니다. 즉, 반복문 안에서 continue를 실행하면 continue 아래의 코드는 실행하지 않고 건너뛴 뒤 다음 반복을 시작합니다.

```python
i = 0
while i < 100:        # i가 100보다 작을 때 반복. 0부터 99까지 증가하면서 100번 반복
    i += 1            # i를 1씩 증가시킴
    if i % 2 == 0:    # i를 2로 나누었을 때 나머지가 0이면 짝수
        continue      # 아래 코드를 실행하지 않고 건너뜀
    print(i)
```

```python
count = int(input('반복할 횟수를 입력하세요: '))
 
i = 0
while True:    # 무한 루프
    print(i)
    i += 1
    if i == count:    # i가 입력받은 값과 같을 때
        break         # 반복문을 끝냄
```

## 중첩 반복문 사용하기

반복문 안에 반복문이 들어가는 형태를 중첩 루프(다중 루프)라고 합니다. 그리고 반복문의 루프 인덱스 변수는 index의 첫 글자를 따서 i를 사용하는데, 반복문 안에 반복문이 들어갈 때는 변수 이름을 i, j, k처럼 i부터 알파벳 순서대로 짓습니다. 여기서는 반복문이 두 개이므로 i와 j를 사용합니다.

```python
for i in range(5):            # 5번 반복. 바깥쪽 루프는 세로 방향
    for j in range(5):        # 5번 반복. 안쪽 루프는 가로 방향
        print('*', end='')    # 별 출력. end에 ''를 지정하여 줄바꿈을 하지 않음
    print()    # 가로 방향으로 별을 다 그린 뒤 다음 줄로 넘어감
               # (print는 출력 후 기본적으로 다음 줄로 넘어감)
      
# 실행결과
*****
*****
*****
*****
*****
```

이 방식은 print에 end=''를 지정했을 때 줄바꿈이 되지 않고 오른쪽 방향으로 문자가 계속 붙는 특성을 이용한 것입니다. 바깥쪽의 for i in range(5): 반복문은 안쪽 for j in range(5): 반복문을 실행하면서 별을 5개씩 그립니다. 그리고 print()를 사용하여 줄바꿈을 한 뒤 다시 별 5개씩 그립니다(print는 기본적으로 end='\n' 상태이므로 아무것도 지정하지 않아도 \n은 출력됨). 이렇게 반복하면서 별을 5개씩 5줄 쌓아 나갑니다.

```python
for i in range(3):            # 3번 반복. 세로 방향
    for j in range(7):        # 7번 반복. 가로 방향
        print('*', end='')    # 별 출력. end에 ''를 지정하여 줄바꿈을 하지 않음
    print()    # 가로 방향으로 별을 다 그린 뒤 다음 줄로 넘어감
               # (print는 출력 후 기본적으로 다음 줄로 넘어감)
      
# 실행결과
*******
*******
*******

for i in range(5):        # 0부터 4까지 5번 반복. 세로 방향
    for j in range(5):    # 0부터 4까지 5번 반복. 가로 방향
        if j <= i:                # 세로 방향 변수 i만큼
            print('*', end='')    # 별 출력. end에 ''를 지정하여 줄바꿈을 하지 않음
    print()    # 가로 방향으로 별을 다 그린 뒤 다음 줄로 넘어감
               # (print는 출력 후 기본적으로 다음 줄로 넘어감)

# 실행결과
*
**
***
****
*****
```

i가 0일 때 j는 0부터 4까지 반복하지만, j <= i를 만족하는 경우는 j가 0일 때 뿐이므로 별이 1 번만 출력됩니다. 다시 i가 1일 때는 j <= i를 만족하는 경우는 j가 0, 1일 때이므로 별이 2번 출력됩니다. 이런 식으로 반복하면서 마지막 5번째에서 별이 5번 출력됩니다.

```python
for i in range(5):        # 0부터 4까지 5번 반복. 세로 방향
    for j in range(5):    # 0부터 4까지 5번 반복. 가로 방향
        if j == i:                # 세로 방향 변수와 같을 때
            print('*', end='')    # 별 출력. end에 ''를 지정하여 줄바꿈을 하지 않음
        else:                     # 세로 방향 변수와 다를 때
            print(' ', end='')    # 공백 출력. end에 ''를 지정하여 줄바꿈을 하지 않음
    print()    # 가로 방향으로 별을 다 그린 뒤 다음 줄로 넘어감
               # (print는 출력 후 기본적으로 다음 줄로 넘어감)
# 실행 결과
*
 *
  *
   *
    *
```

## FizzBuzz 문제

```python
for i in range(1, 101):              # 1부터 100까지 100번 반복
    if i % 3 == 0 and i % 5 == 0:    # 3과 5의 공배수일 때
        print('FizzBuzz')            # FizzBuzz 출력
    elif i % 3 == 0:                 # 3의 배수일 때
        print('Fizz')                # Fizz 출력
    elif i % 5 == 0:                 # 5의 배수일 때
        print('Buzz')                # Buzz 출력
    else:
        print(i)                     # 아무것도 해당되지 않을 때 숫자 출력

# 실행결과
1
2
Fizz
... (생략)
FizzBuzz
91
92
Fizz
94
Buzz
Fizz
97
98
Fizz
Buzz
```

i % 3 == 0 and i % 5 == 0처럼 i를 3으로 나눴을 때 나머지가 0이면서 5로 나눴을 때도 나머지가 0이면 3과 5의 공배수입니다. 그러므로 이때는 print로 'FizzBuzz'를 출력해줍니다.

만약 i가 30인데 if에서 3의 배수를 먼저 검사하면 3과 5의 공배수는 검사를 하지 않고 그냥 넘어가버리므로 주의해야 합니다. 따라서 3과 5의 공배수를 먼저 검사한 뒤 elif로 3의 배수, 5의 배수를 검사해야 합니다.

```python
for i in range(1, 101):      # 1부터 100까지 100번 반복
    if i % 15 == 0:          # 15의 배수(3과 5의 공배수)일 때
        print('FizzBuzz')    # FizzBuzz 출력
    elif i % 3 == 0:         # 3의 배수일 때
        print('Fizz')        # Fizz 출력
    elif i % 5 == 0:         # 5의 배수일 때
        print('Buzz')        # Buzz 출력
    else:
        print(i)             # 아무것도 해당되지 않을 때 숫자 출력
```

i를 15로 나눴을 때 나머지를 구하여 3과 5의 공배수를 구했습니다. 이때는 15라는 숫자 안에 3과 5의 최소공배수라는 뜻이 숨어 있습니다. 따라서 주석에 적절한 설명이 없다면 코드를 읽는 사람이 15의 속 뜻을 알아내야 합니다.

FizzBuzz는 문제가 간단해서 15가 3과 5의 최소공배수라는 것을 쉽게 알 수 있습니다. 하지만 실무에서는 i % 3 == 0 and i % 5 == 0처럼 의미를 명확하게 드러내는 것이 좋습니다.

```python
for i in range(1, 101):
    print('Fizz' * (i % 3 == 0) + 'Buzz' * (i % 5 == 0) or i)
    # 문자열 곱셈과 덧셈을 이용하여 print 안에서 처리
```

문자열에 True를 곱하면 문자열이 그대로 나오고, False를 곱하면 문자열이 출력되지 않습니다(True는 1, False는 0으로 연산).

```python
>>> 'Fizz' + 'Buzz'
'FizzBuzz'
>>> 'Fizz' * True
'Fizz'
>>> 'Fizz' * False
''
```

3과 5의 공배수이면 'Fizz' * True + 'Buzz' * True가 되므로 'Fizz' + 'Buzz'로 'FizzBuzz'를 출력합니다. 만약 한 쪽이 만족하지 않으면 덧셈할 문자열이 없으므로 'Fizz'나 'Buzz'만 출력됩니다.

3 또는 5의 배수가 아닐 때는 'Fizz' * False + 'Buzz' * False가 되고 결과는 빈 문자열 ''이 되는데, 이때는 or 연산자를 사용합니다. 빈 문자열은 False로 취급하고, i는 항상 1 이상의 숫자이므로 or로 연산하면 i만 남게 되어 숫자가 그대로 출력됩니다.

## 리스트와 튜플 응용하기

append: 요소 하나를 추가

extend: 리스트를 연결하여 확장

insert: 특정 인덱스에 요소 추가

**append(요소)는 리스트 끝에 요소 하나**를 추가합니다.

```python
>>> a = [10, 20, 30]
>>> a.append(500)
>>> a
[10, 20, 30, 500]
>>> len(a)
4
```

메서드를 호출한 리스트가 변경되며 새 리스트는 생성되지 않음

append는 append(리스트)처럼 리스트를 넣으면 리스트 안에 리스트가 들어갑니다.

```python
>>> a = [10, 20, 30]
>>> a.append([500, 600])
>>> a
[10, 20, 30, [500, 600]]
>>> len(a)
4
```

다음은 리스트 a 안에 [500, 600]이 들어가서 중첩 리스트가 됩니다. a.append([500, 600])은 [500, 600]이라는 **요소 하나**를 리스트 a 끝에 추가합니다. 따라서 리스트 a를 len으로 길이를 구해보면 5가 아닌 4가 나옵니다. 즉, append는 항상 리스트의 길이가 1씩 증가합니다.

```python
>>> a = [10, 20, 30]
>>> a.extend([500, 600])
>>> a
[10, 20, 30, 500, 600]
>>> len(a)
5
```

**extend(리스트)**는 리스트 끝에 다른 리스트를 연결하여 리스트를 확장합니다. 다음은 리스트 [10, 20, 30]에 다른 리스트 [500, 600]을 연결하여 [10, 20, 30, 500, 600]이 됩니다(메서드를 호출한 리스트가 변경되며 새 리스트는 생성되지 않음).

extend에 전달된 [500, 600]의 요소를 반복하면서 각 요소를 리스트 a에 추가하는 것입니다

**insert(인덱스, 요소)**는 리스트의 특정 인덱스에 요소 하나를 추가합니다. 

```python
>>> a = [10, 20, 30]
>>> a.insert(2, 500)
>>> a
[10, 20, 500, 30]
>>> len(a)
4
```

insert(0,요소): 리스트의 맨 처음에 요소를 추가

insert(len(리스트), 요소): 리스트 끝에 요소를 추가

insert는 요소 하나를 추가하므로 insert에 리스트를 넣으면 append처럼 리스트 안에 리스트가 들어갑니다. 다음은 리스트 [10, 20, 30]의 인덱스 1에 리스트 [500, 600]을 추가하여 중첩 리스트가 됩니다.

```python
>>> a = [10, 20, 30]
>>> a.insert(1, [500, 600])
>>> a
[10, [500, 600], 20, 30]
```

리스트 중간에 요소 여러 개를 추가하고 싶다면 슬라이스에 요소 할당하기를 활용하면 됩니다. 

```python
>>> a = [10, 20, 30]
>>> a[1:1] = [500, 600]
>>> a
[10, 500, 600, 20, 30]
```

a[1:1] = [500, 600]과 같이 시작 인덱스와 끝 인덱스를 같게 지정하면 해당 인덱스의 요소를 덮어쓰지 않으면서 요소 여러 개를 중간에 추가할 수 있습니다.

pop: 마지막 요소 또는 특정 인덱스의 요소를 삭제

remove: 특정 값을 찾아서 삭제

**pop()**은 리스트의 마지막 요소를 삭제한 뒤 삭제한 요소를 반환합니다.

```python
>>> a = [10, 20, 30]
>>> a.pop()
30
>>> a
[10, 20]
```

**pop(인덱스)**는 해당 인덱스의 요소를 삭제한 뒤 삭제한 요소를 반환합니다. 

```python
>>> a = [10, 20, 30]
>>> a.pop(1)
20
>>> a
[10, 30]
```

pop 대신 del을 사용해도 상관없습니다.

```python
>>> a = [10, 20, 30]
>>> del a[1]
>>> a
[10, 30]
```

**remove(값)**은 리스트에서 특정 값을 찾아서 삭제합니다.

```python
>>> a = [10, 20, 30]
>>> a.remove(20)
>>> a
[10, 30]
```

만약 리스트에 같은 값이 여러 개 있을 경우 처음 찾은 값을 삭제합니다.

```python
>>> a = [10, 20, 30, 20]
>>> a.remove(20)
>>> a
[10, 30, 20]
```

**index(값)**은 리스트에서 특정 값의 인덱스를 구합니다. 이때 같은 값이 여러 개일 경우 처음 찾은 인덱스를 구합니다(가장 작은 인덱스). 

```python
>>> a = [10, 20, 30, 15, 20, 40]
>>> a.index(20)
1
```

**count(값)**은 리스트에서 특정 값의 개수를 구합니다. 

```python
>>> a = [10, 20, 30, 15, 20, 40]
>>> a.count(20)
2
```

**reverse()**는 리스트에서 요소의 순서를 반대로 뒤집습니다. 

```
>>> a = [10, 20, 30, 15, 20, 40]
>>> a.reverse()
>>> a
[40, 20, 15, 30, 20, 10]
```

**sort()**는 리스트의 요소을 작은 순서대로 정렬합니다(오름차순). 

```python
>>> a = [10, 20, 30, 15, 20, 40]
>>> a.sort()
>>> a
[10, 15, 20, 20, 30, 40]
```

**sort(reverse=True)**: 리스트의 값을 큰 순서대로 정렬(내림차순)

```python
>>> a = [10, 20, 30, 15, 20, 40]
>>> a.sort()    # a의 내용을 변경하여 정렬
>>> a
[10, 15, 20, 20, 30, 40]
>>> b = [10, 20, 30, 15, 20, 40]
>>> sorted(b)    # 정렬된 새 리스트를 생성
[10, 15, 20, 20, 30, 40]
```

**clear()**는 리스트의 모든 요소를 삭제합니다.

```python
>>> a = [10, 20, 30]
>>> a.clear()
>>> a
[]
```

clear 대신 del a[:]와 같이 시작, 끝 인덱스를 생략하여 리스트의 모든 요소를 삭제할 수도 있습니다.

```python
>>> a = [10, 20, 30]
>>> del a[:]
>>> a
[]
```

리스트는 메서드를 사용하지 않고, 슬라이스로 조작할 수도 있습니다.

```python
>>> a = [10, 20, 30]
>>> a[len(a):] = [500]
>>> a
[10, 20, 30, 500]
```

a[len(a):]는 시작 인덱스를 len(a)로 지정해서 리스트의 마지막 인덱스보다 1이 더 큰 상태입니다. (이때는 리스트의 범위를 벗어난 인덱스를 사용할 수 있습니다.)

a[len(a):] = [500]과 같이 값이 한 개 들어있는 리스트를 할당하면 리스트 a 끝에 값을 한 개 추가하며 a.append(500)과 같습니다.

그리고 a[len(a):] = [500, 600]과 같이 요소가 여러 개 들어있는 리스트를 할당하면 리스트 a 끝에 다른 리스트를 연결하며 a.extend([500, 600])과 같습니다.

```python
>>> a = [10, 20, 30]
>>> a[len(a):] = [500, 600]
>>> a
[10, 20, 30, 500, 600]
```

```python
if not seq:    # 리스트가 비어 있으면 True
if seq:        # 리스트에 내용이 있으면 True
```

```python
>>> a = []
>>> a[-1]
Traceback (most recent call last):
  File "<pyshell#3>", line 1, in <module>
    a[-1]
IndexError: list index out of range # 리스트가 비어 있을 경우에는 인덱스를 -1로 지정하면 에러가 발생
  
seq = []
if seq:               # 리스트에 요소가 있는지 확인
    print(seq[-1])    # 요소가 있을 때만 마지막 요소를 가져옴
```

```python
>>> a = [0, 0, 0, 0, 0]
>>> b = a
```

b = a와 같이 리스트를 다른 변수에 할당하면 리스트는 두 개가 될 것 같지만 실제로는 리스트가 한 개입니다.

a와 b를 is 연산자로 비교해보면 True가 나옵니다. 즉, 변수 이름만 다를 뿐 리스트 a와 b는 같은 객체입니다.

```python
>>> a is b
True
```

a와 b는 같으므로 b[2] = 99와 같이 리스트 b의 요소를 변경하면 리스트 a와 b에 모두 반영됩니다.

```python
>>> b[2] = 99
>>> a
[0, 0, 99, 0, 0]
>>> b
[0, 0, 99, 0, 0]
```

리스트 a와 b를 완전히 두 개로 만들려면 copy 메서드로 모든 요소를 복사해야 합니다.

```python
>>> a = [0, 0, 0, 0, 0]
>>> b = a.copy()

>>> a is b
False
>>> a == b
True
```

a와 b를 is 연산자로 비교해보면 False가 나옵니다. 즉, 두 리스트는 다른 객체입니다. 그러나 복사된 요소는 모두 같으므로 ==로 비교하면 True가 나옵니다.

이제 리스트 a와 b는 별개이므로 한쪽의 값을 변경해도 다른 리스트에 영향을 미치지 않습니다. 다음과 같이 리스트 b의 요소를 변경하면 리스트 a는 그대로이고 리스트 b만 바뀝니다.

```python
>>> b[2] = 99
>>> a
[0, 0, 0, 0, 0]
>>> b
[0, 0, 99, 0, 0]
```

```python
>>> a = [38, 21, 53, 62, 19]
>>> for i in a:
...     print(i)
...
38
21
53
62
19
```

for i in a:는 리스트 a에서 요소를 꺼내서 i에 저장하고, 꺼낼 때마다 코드를 반복합니다. 따라서 print로 i를 출력하면 모든 요소를 순서대로 출력할 수 있습니다.

```python
>>> a = [38, 21, 53, 62, 19]
>>> for index, value in enumerate(a):
...     print(index, value)
...
0 38
1 21
2 53
3 62
4 19
```

for index, value in enumerate(a):와 같이 enumerate에 리스트를 넣으면 for 반복문에서 인덱스와 요소를 동시에 꺼내 올 수 있습니다.

```python
>>> for index, value in enumerate(a, start=1):
...     print(index, value)
...
1 38
2 21
3 53
4 62
5 19
```

enumerate(a, start=1)처럼 start에 1을 지정하여 인덱스가 1부터 시작하도록 만들었습니다. 이 코드는 enumerate(a, 1)과 같이 줄여 쓸 수도 있습니다.

```python
>>> a = [38, 21, 53, 62, 19]
>>> for i in range(len(a)):
...     print(a[i])
...
38
21
53
62
19
```

range에 len으로 리스트의 길이(요소 개수)를 구해서 넣어주면 인덱스를 순서대로 만들어줍니다. 따라서 a[i]와 같이 리스트에 인덱스를 지정하여 값을 가져올 수 있습니다. 즉, for i in range(len(a))를 실행하면 i에는 요소가 아닌 0부터 마지막 인덱스까지 인덱스가 들어갑니다.

```python
>>> a = [38, 21, 53, 62, 19]
>>> i = 0
>>> while i < len(a):
...     print(a[i])
...     i += 1
...
38
21
53
62
19
```

while 반복문으로 리스트의 요소를 출력할 때는 변수 i를 인덱스로 활용합니다. 먼저 변수 i를 0으로 만들어주고, i < len(a)처럼 i가 리스트의 길이(요소 개수) 직전까지만 반복하도록 만듭니다.

즉, 리스트의 인덱스는 0부터 시작하고 마지막 인덱스는 리스트의 길이보다 1이 작으므로 <를 사용합니다. 만약 i <= len(a)처럼 <=을 사용하면 리스트의 범위를 벗어나게 되므로 주의해야 합니다.

```python
>>> a = [38, 21, 53, 62, 19]
>>> smallest = a[0]
>>> for i in a:
...     if i < smallest:
...         smallest = i
...
>>> smallest
19

>>> a = [38, 21, 53, 62, 19]
>>> largest = a[0]
>>> for i in a:
...     if i > largest:
...         largest = i
...
>>> largest
62

>>> a = [38, 21, 53, 62, 19]
>>> a.sort()
>>> a[0]
19
>>> a.sort(reverse=True)
>>> a[0]
62
```

```python
>>> a = [38, 21, 53, 62, 19]
>>> min(a)
19
>>> max(a)
62
```

min은 리스트에서 가장 작은 값을 구하고, max는 가장 큰 값을 구합니다.

```python
>>> a = [10, 10, 10, 10, 10]
>>> sum(a)
50
```

min, max, sum에는 리스트뿐만 아니라 모든 반복 가능한 객체(iterable)를 넣을 수 있습니다. 반복 가능한 객체는 리스트, 튜플, 딕셔너리, 세트, range 등 여러 가지가 있습니다.

```python
>>> a = [i for i in range(10)]        # 0부터 9까지 숫자를 생성하여 리스트 생성
>>> a
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> b = list(i for i in range(10))    # 0부터 9까지 숫자를 생성하여 리스트 생성
>>> b
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

>>> c = [i + 5 for i in range(10)]    # 0부터 9까지 숫자를 생성하면서 값에 5를 더하여 리스트 생성
>>> c
[5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
>>> d = [i * 2 for i in range(10)]    # 0부터 9까지 숫자를 생성하면서 값에 2를 곱하여 리스트 생성
>>> d
[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
```

파이썬의 리스트가 특이한 점은 리스트 안에 for 반복문과 if 조건문을 사용할 수 있다는 점입니다. 이렇게 리스트 안에 식, for 반복문, if 조건문 등을 지정하여 리스트를 생성하는 것을 리스트 컴프리헨션(list comprehension)이라고 합니다.

```python
>>> a = [i for i in range(10) if i % 2 == 0]    # 0~9 숫자 중 2의 배수인 숫자(짝수)로 리스트 생성
>>> a
[0, 2, 4, 6, 8]
```

[i for i in range(10) if i % 2 == 0]는 0부터 9까지 숫자를 생성하여 2의 배수인 숫자(짝수)로만 리스트를 생성합니다. 즉, 다음과 같이 for 반복문 뒤에 if 조건문을 지정하면 숫자를 생성한 뒤 if 조건문에서 특정 숫자만 뽑아내서 리스트를 생성합니다.

```python
>>> a = [i * j for j in range(2, 10) for i in range(1, 10)]
>>> a
[2, 4, 6, 8, 10, 12, 14, 16, 18, 3, 6, 9, 12, 15, 18, 21, 24, 27, 4, 8, 12, 16, 20, 24, 28, 32, 36, 5, 10, 15, 20, 25, 30, 35, 40, 45, 6, 12, 18, 24, 30, 36, 42, 48, 54, 7, 14, 21, 28, 35, 42, 49, 56, 63, 8, 16, 24, 32, 40, 48, 56, 64, 72, 9, 18, 27, 36, 45, 54, 63, 72, 81]

a = [i * j for j in range(2, 10)
           for i in range(1, 10)]
```

리스트 표현식에 for가 여러 개일 때 처리 순서는 뒤에서 앞으로 순입니다.

**map**은 리스트의 요소를 지정된 함수로 처리해주는 함수입니다(map은 원본 리스트를 변경하지 않고 새 리스트를 생성합니다).

**list(map(함수, 리스트))**

**tuple(map(함수, 튜플))**

```python
>>> a = [1.2, 2.5, 3.7, 4.6]
>>> for i in range(len(a)):
...     a[i] = int(a[i])
...
>>> a
[1, 2, 3, 4]

>>> a = [1.2, 2.5, 3.7, 4.6]
>>> a = list(map(int, a))
>>> a
[1, 2, 3, 4]
```

map에 int와 리스트를 넣으면 리스트의 모든 요소를 int를 사용해서 변환합니다. 그다음에 list를 사용해서 map의 결과를 다시 리스트로 만들어줍니다.

map에는 리스트뿐만 아니라 모든 반복 가능한 객체를 넣을 수 있습니다.

```python
>>> a = list(map(str, range(10)))
>>> a
['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
```

```python
>>> a = input().split()
10 20 (입력)
>>> a
['10', '20']

>>> a = map(int, input().split())
10 20 (입력)
>>> a
<map object at 0x03DFB0D0>
>>> list(a)
[10, 20]

>>> a, b = [10, 20]
>>> a
10
>>> b
20
```

map이 반환하는 맵 객체는 이터레이터라서 변수 여러 개에 저장하는 언패킹(unpacking)이 가능합니다. 그래서 a, b = map(int, input().split())처럼 list를 생략한 것입니다.

```python
x = input().split()    # input().split()의 결과는 문자열 리스트
m = map(int, x)        # 리스트의 요소를 int로 변환, 결과는 맵 객체
a, b = m               # 맵 객체는 변수 여러 개에 저장할 수 있음
```

튜플은 리스트와는 달리 내용을 변경할 수 없습니다(불변, immutable). 따라서 내용을 변경하는 append 같은 메서드는 사용할 수 없고, 요소의 정보를 구하는 메서드만 사용할 수 있습니다.

```python
>>> a = (38, 21, 53, 62, 19, 53)
>>> a.index(53)
2

>>> a = (10, 20, 30, 15, 20, 40)
>>> a.count(20)
2

>>> a = (38, 21, 53, 62, 19)
>>> for i in a:
...     print(i, end=' ')
...
38 21 53 62 19

>>> a = tuple(i for i in range(10) if i % 2 == 0)
>>> a
(0, 2, 4, 6, 8)

>>> (i for i in range(10) if i % 2 == 0)
<generator object <genexpr> at 0x050FE420> # 참고로 ( )(괄호) 안에 표현식을 넣으면 튜플이 아니라 제너레이터 표현식이 됩니다.

>>> a = (1.2, 2.5, 3.7, 4.6)
>>> a = tuple(map(int, a))
>>> a
(1, 2, 3, 4)

>>> a = (38, 21, 53, 62, 19)
>>> min(a)
19
>>> max(a)
62
>>> sum(a)
193
```

## 2차원 리스트 사용하기

2차원 리스트는 리스트 안에 리스트를 넣어서 만들 수 있으며 안쪽의 각 리스트는 ,(콤마)로 구분합니다.

```python
>>> a = [[10, 20], [30, 40], [50, 60]]
>>> a
[[10, 20], [30, 40], [50, 60]]
```

2차원 리스트의 요소에 접근하거나 값을 할당할 때는 리스트 뒤에 [ ](대괄호)를 두 번 사용하며 [ ] 안에 세로(row) 인덱스와 가로(column) 인덱스를 지정해주면 됩니다.

```python
>>> a = [[10, 20], [30, 40], [50, 60]]
>>> a[0] [0]            # 세로 인덱스 0, 가로 인덱스 0인 요소 출력
10
>>> a[1][1]           # 세로 인덱스 1, 가로 인덱스 1인 요소 출력
40
>>> a[2][1]           # 세로 인덱스 2, 가로 인덱스 0인 요소 출력
60
>>> a[0][1] = 1000    # 세로 인덱스 0, 가로 인덱스 1인 요소에 값 할당
>>> a[0][1]
1000
```

```python
a = ((10, 20), (30, 40), (50, 60))    # 튜플 안에 튜플을 넣은 2차원 튜플
b = ([10, 20], [30, 40], [50, 60])    # 튜플 안에 리스트를 넣음
c = [(10, 20), (30, 40), (50, 60)]    # 리스트 안에 튜플을 넣음
```

튜플은 내용을 변경할 수 없으므로 a는 안쪽과 바깥쪽 모두 요소를 변경할 수 없습니다. b는 안쪽 리스트만 요소를 변경할 수 있고, c는 바깥쪽 리스트만 요소를 변경할 수 있습니다.

```python
a[0][0] = 500        # 안쪽 튜플은 변경할 수 없음. TypeError 발생
a[0] = (500, 600)    # 바깥쪽 튜플은 변경할 수 없음. TypeError 발생
b[0][0] = 500        # 안쪽 리스트는 변경할 수 있음
b[0] = (500, 600)    # 바깥쪽 튜플은 변경할 수 없음. TypeError 발생
c[0][0] = 500        # 안쪽 튜플은 변경할 수 없음. TypeError 발생
c[0] = (500, 600)    # 바깥쪽 리스트는 변경할 수 있음
```

```python
>>> a = [[10, 20], [30, 40], [50, 60]]
>>> for x, y in a:    # 리스트의 가로 한 줄(안쪽 리스트)에서 요소 두 개를 꺼냄
...     print(x, y)
...
10 20
30 40
50 60
```

2차원 리스트에 for를 사용하면 가로 한 줄씩 반복하게 됩니다. 전체 리스트를 기준으로 보면 안쪽 리스트가 통째로 반복됩니다. 이때 for x, y in a:와 같이 in 앞에 변수를 두 개 지정해주면 가로 한 줄(안쪽 리스트)에서 요소 두 개를 꺼내 옵니다. 당연히 in 앞에 변수의 개수는 2차원 리스트에서 가로 크기(안쪽 리스트의 요소 개수)와 일치해야 합니다. 특히 for 반복문을 한 번만 사용하는 방식은 2차원 리스트의 가로 크기가 크지 않을 때 유용합니다.

```python
a = [[10, 20], [30, 40], [50, 60]]
 
for i in a:        # a에서 안쪽 리스트를 꺼냄
    for j in i:    # 안쪽 리스트에서 요소를 하나씩 꺼냄
        print(j, end=' ')
    print()
    
a = [[10, 20], [30, 40], [50, 60]]
 
for i in range(len(a)):            # 세로 크기
    for j in range(len(a[i])):     # 가로 크기
        print(a[i][j], end=' ')
    print()
```

for range에 세로 크기와 가로 크기를 넣으면 인덱스로 사용할 수 있습니다. 여기서 주의할 점은 len으로 2차원 리스트 a의 크기를 구하면 리스트 안에 들어있는 모든 요소의 개수가 아니라 안쪽 리스트의 개수(세로 크기)가 나온다는 점입니다. 즉, len(a)는 6이 아니라 3입니다. 그리고 len으로 안쪽 리스트 a[i]의 크기를 구해야 안쪽 리스트에 들어있는 요소의 개수(가로 크기)가 나옵니다. 즉, len(a[i])는 2입니다.

```python
a = [[10, 20], [30, 40], [50, 60]]
 
i = 0
while i < len(a):    # 반복할 때 리스트의 크기 활용(세로 크기)
    x, y = a[i]      # 요소 두 개를 한꺼번에 가져오기
    print(x, y)
    i += 1           # 인덱스를 1 증가시킴
    

a = [[10, 20], [30, 40], [50, 60]]
 
i = 0
while i < len(a):           # 세로 크기
    j = 0
    while j < len(a[i]):    # 가로 크기
        print(a[i][j], end=' ')
        j += 1              # 가로 인덱스를 1 증가시킴
    print()
    i += 1                  # 세로 인덱스를 1 증가시킴
```

```python
a = []    # 빈 리스트 생성
 
for i in range(10):
    a.append(0)    # append로 요소 추가
 
print(a)

# [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]


a = []    # 빈 리스트 생성
 
for i in range(3):
    line = []              # 안쪽 리스트로 사용할 빈 리스트 생성
    for j in range(2):
        line.append(0)     # 안쪽 리스트에 0 추가
    a.append(line)         # 전체 리스트에 안쪽 리스트를 추가
 
print(a)

# [[0, 0], [0, 0], [0, 0]]

>>> a = [[0 for j in range(2)] for i in range(3)]
>>> a
[[0, 0], [0, 0], [0, 0]]

>>> a = [[0] * 2 for i in range(3)]
>>> a
[[0, 0], [0, 0], [0, 0]]
```

```python
a = [3, 1, 3, 2, 5]    # 가로 크기를 저장한 리스트
b = []    # 빈 리스트 생성
 
for i in a:      # 가로 크기를 저장한 리스트로 반복
    line = []    # 안쪽 리스트로 사용할 빈 리스트 생성
    for j in range(i):    # 리스트 a에 저장된 가로 크기만큼 반복
        line.append(0)
    b.append(line)        # 리스트 b에 안쪽 리스트를 추가
 
print(b)

# [[0, 0, 0], [0], [0, 0, 0], [0, 0], [0, 0, 0, 0, 0]]


>>> a = [[0] * i for i in [3, 1, 3, 2, 5]]
>>> a
[[0, 0, 0], [0], [0, 0, 0], [0, 0], [0, 0, 0, 0, 0]]
```

2차원 리스트를 정렬할 때는 sorted 함수를 사용합니다.

**sorted(반복가능한객체, key=정렬함수, reverse=True 또는 False)**

```python
students = [
    ['john', 'C', 19],
    ['maria', 'A', 25],
    ['andrew', 'B', 7]
]
 
print(sorted(students, key=lambda student: student[1]))  # 안쪽 리스트의 인덱스 1을 기준으로 정렬
print(sorted(students, key=lambda student: student[2]))  # 안쪽 리스트의 인덱스 2를 기준으로 정렬

# [['maria', 'A', 25], ['andrew', 'B', 7], ['john', 'C', 19]]
# [['andrew', 'B', 7], ['john', 'C', 19], ['maria', 'A', 25]]
```

```python
>>> a = [[10, 20], [30, 40]]
>>> b = a
>>> b[0][0] = 500
>>> a
[[500, 20], [30, 40]]
>>> b
[[500, 20], [30, 40]]

>>> a = [[10, 20], [30, 40]]
>>> b = a.copy()
>>> b[0][0] = 500
>>> a
[[500, 20], [30, 40]]
>>> b
[[500, 20], [30, 40]]
```

2차원 이상의 다차원 리스트는 리스트를 완전히 복사하려면 copy 메서드 대신 copy 모듈의 deepcopy 함수를 사용해야 합니다.

```python
>>> a = [[10, 20], [30, 40]]
>>> import copy             # copy 모듈을 가져옴
>>> b = copy.deepcopy(a)    # copy.deepcopy 함수를 사용하여 깊은 복사
>>> b[0][0] = 500
>>> a
[[10, 20], [30, 40]]
>>> b
[[500, 20], [30, 40]]
```

이제 리스트 b의 요소를 변경해도 리스트 a에는 영향을 미치지 않습니다. copy.deepcopy 함수는 중첩된 리스트(튜플)에 들어있는 모든 리스트(튜플)를 복사하는 깊은 복사(deep copy)를 해줍니다.

```python
a = [[[0 for col in range(3)] for row in range(4)] for depth in range(2)]

# [[[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]]
```

## 문자열 응용하기

**replace('바꿀문자열', '새문자열')**은 문자열 안의 문자열을 다른 문자열로 바꿉니다(문자열 자체는 변경하지 않으며 바뀐 결과를 반환합니다). 

```python
>>> 'Hello, world!'.replace('world', 'Python')
'Hello, Python!'
```

만약 바뀐 결과를 유지하고 싶다면 문자열이 저장된 변수에 replace를 사용한 뒤 다시 변수에 할당해주면 됩니다.

```python
>>> s = 'Hello, world!'
>>> s = s.replace('world!', 'Python')
>>> s
'Hello, Python'
```

translate는 문자열 안의 문자를 다른 문자로 바꿉니다. 먼저 **str.maketrans('바꿀문자', '새문자')**로 변환 테이블을 만듭니다. 그다음에 **translate(테이블)**을 사용하면 문자를 바꾼 뒤 결과를 반환합니다. 다음은 문자열 'apple'에서 a를 1, e를 2, i를 3, o를 4, u를 5로 바꿉니다.

```python
>>> table = str.maketrans('aeiou', '12345')
>>> 'apple'.translate(table)
'1ppl2'
```

**split()**은 공백을 기준으로 문자열을 분리하여 리스트로 만듭니다. 

```python
>>> 'apple pear grape pineapple orange'.split()
['apple', 'pear', 'grape', 'pineapple', 'orange']
```

**split('기준문자열')**과 같이 기준 문자열을 지정하면 기준 문자열로 문자열을 분리합니다. 즉, 문자열에서 각 단어가 ,(콤마)와 공백으로 구분되어 있을 때 ', '으로 문자열을 분리하면 단어만 리스트로 만듭니다.

```python
>>> 'apple, pear, grape, pineapple, orange'.split(', ')
['apple', 'pear', 'grape', 'pineapple', 'orange']
```

**join(리스트)**는 구분자 문자열과 문자열 리스트의 요소를 연결하여 문자열로 만듭니다. 다음은 공백 ' '에 join을 사용하여 각 문자열 사이에 공백이 들어가도록 만듭니다.

```python
>>> ' '.join(['apple', 'pear', 'grape', 'pineapple', 'orange'])
'apple pear grape pineapple orange'

>>> '-'.join(['apple', 'pear', 'grape', 'pineapple', 'orange'])
'apple-pear-grape-pineapple-orange'
```

**upper()**는 문자열의 문자를 모두 대문자로 바꿉니다. 만약 문자열 안에 대문자가 있다면 그대로 유지됩니다.

```python
>>> 'python'.upper()
'PYTHON'
```

**lower()**는 문자열의 문자를 모두 소문자로 바꿉니다. 만약 문자열 안에 소문자가 있다면 그대로 유지됩니다.

```python
>>> 'PYTHON'.lower()
'python'
```

```python
>>> '   Python   '.lstrip()
'Python   '

>>> '   Python   '.rstrip()
'   Python'

>>> '   Python   '.strip()
'Python'

>>> ', python.'.lstrip(',.')
' python.'

>>> ', python.'.rstrip(',.')
', python'

>>> ', python.'.strip(',.')
' python'

>>> import string
>>> ', python.'.strip(string.punctuation)
' python'
>>> string.punctuation
'!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~'

>>> ', python.'.strip(string.punctuation + ' ')
'python'

>>> ', python.'.strip(string.punctuation).strip()
'python'

>>> 'python'.ljust(10)
'python    '

>>> 'python'.rjust(10)
'    python'

>>> 'python'.center(10)
'  python  '

>>> 'python'.center(11)
'   python  ' # 만약 가운데로 정렬했을 때 전체 길이와 남는 공간이 모두 홀수가 된다면 왼쪽에 공백이 한 칸 더 들어갑니다. 예를 들어 길이가 6인 'python'을 11로 가운데 정렬하면 5가 남아서 왼쪽에 공백 3칸, 오른쪽에 공백 2칸이 들어갑니다.
```

문자열 메서드는 처리한 결과를 반환하도록 만들어져 있습니다. 따라서 메서드를 계속 연결해서 호출하는 메서드 체이닝이 가능합니다. 메서드 체이닝은 메서드를 줄줄이 연결한다고 해서 메서드 체이닝(method chaining)이라 부릅니다.

```python
>>> 'python'.rjust(10).upper()
'    PYTHON'
```

```python
>>> '35'.zfill(4)        # 숫자 앞에 0을 채움
'0035'
>>> '3.5'.zfill(6)       # 숫자 앞에 0을 채움
'0003.5'
>>> 'hello'.zfill(10)    # 문자열 앞에 0을 채울 수도 있음
'00000hello'

>>> 'apple pineapple'.find('pl')
2
>>> 'apple pineapple'.find('xy')
-1 # 문자열이 없으면 -1을 반환합니다.

>>> 'apple pineapple'.rfind('pl')
12
>>> 'apple pineapple'.rfind('xy')
-1

>>> 'apple pineapple'.index('pl')
2 # 문자열이 없으면 에러를 발생시킵니다. 

>>> 'apple pineapple'.rindex('pl')
12 # 문자열이 없으면 에러를 발생시킵니다. 

>>> 'apple pineapple'.count('pl')
2
```

```python
>>> 'I am %s.' % 'james'
'I am james.'

>>> name = 'maria'
>>> 'I am %s.' % name
'I am maria.'
```

서식 지정자는 %로 시작하고 자료형을 뜻하는 문자가 붙습니다. %s는 문자열이라는 뜻이며 **s**tring의 s입니다. 이처럼 문자열 안에 %s를 넣고 그 뒤에 %를 붙인 뒤 'james'를 지정해주면 %s 부분이 'james'로 바뀝니다('I am %s.'과 'james' 사이의 %는 따옴표로 묶지 않고 그대로 입력해야 합니다).

```python
>>> 'I am %d years old.' % 20
'I am 20 years old.' # 숫자는 %d를 넣고 % 뒤에 숫자를 지정하면 됩니다. %d는 10진 정수 decimal integer의 d입니다.

>>> '%f' % 2.3
'2.300000' # 실수를 넣을 때는 %f를 사용하며 고정 소수점 fixed point의 f입니다. %f는 기본적으로 소수점 이하 6자리까지 표시하므로 2.3은 2.300000으로 표시됩니다.

>>> '%.2f' % 2.3
'2.30'
>>> '%.3f' % 2.3
'2.300'

>>> '%10s' % 'python'
'    python'

>>> '%10d' % 150
'       150'
>>> '%10d' % 15000
'     15000'

>>> '%10.2f' % 2.3
'      2.30'
>>> '%10.2f' % 2000.3
'   2000.30'

>>> '%-10s' % 'python'
'python    '

```

```python
>>> 'Today is %d %s.' % (3, 'April')
'Today is 3 April.'

>>> 'Today is %d%s.' % (3, 'April')
'Today is 3April.'
```

문자열 안에 값을 두 개 이상 넣으려면 %를 붙이고, 괄호 안에 값(변수)을 콤마로 구분해서 넣어주면 됩니다. 특히 값을 괄호로 묶지 않으면 에러가 발생하므로 주의해야 합니다. 서식 지정자가 두 개이므로 값도 두 개 넣었습니다. 이처럼 서식 지정자가 여러 개면 괄호 안의 값(변수) 개수도 서식 지정자 개수와 똑같이 맞춰주어야 합니다.

```python
>>> 'Hello, {0}'.format('world!')
'Hello, world!'
>>> 'Hello, {0}'.format(100)
'Hello, 100'

>>> 'Hello, {0} {2} {1}'.format('Python', 'Script', 3.6)
'Hello, Python 3.6 Script'

>>> '{0} {0} {1} {1}'.format('Python', 'Script')
'Python Python Script Script'

>>> 'Hello, {} {} {}'.format('Python', 'Script', 3.6)
'Hello, Python Script 3.6' # { }에서 인덱스를 생략하면 format에 지정한 순서대로 값이 들어갑니다.

>>> 'Hello, {language} {version}'.format(language='Python', version=3.6)
'Hello, Python 3.6'

>>> language = 'Python'
>>> version = 3.6
>>> f'Hello, {language} {version}'
'Hello, Python 3.6'

>>> '{{ {0} }}'.format('Python')
'{ Python }' # { } 중괄호 자체를 출력할 때는 {{, }}처럼 중괄호를 두 번 사용하면 됩니다.

>>> '{0:<10}'.format('python')
'python    '

>>> '{0:>10}'.format('python')
'    python'

>>> '{:>10}'.format('python')
'    python'

>>> '%03d' % 1
'001'
>>> '{0:03d}'.format(35)
'035'

>>> '%08.2f' % 3.6
'00003.60'
>>> '{0:08.2f}'.format(150.37)
'00150.37'

>>> '{0:0<10}'.format(15)    # 길이 10, 왼쪽으로 정렬하고 남는 공간은 0으로 채움
'1500000000'
>>> '{0:0>10}'.format(15)    # 길이 10, 오른쪽으로 정렬하고 남는 공간은 0으로 채움
'0000000015'

>>> '{0:0>10.2f}'.format(15)    # 길이 10, 오른쪽으로 정렬하고 소수점 자릿수는 2자리
'0000015.00'

>>> '{0: >10}'.format(15)    # 남는 공간을 공백으로 채움
'        15'
>>> '{0:>10}'.format(15)     # 채우기 부분을 생략하면 공백이 들어감
'        15'
>>> '{0:x>10}'.format(15)    # 남는 공간을 문자 x로 채움
'xxxxxxxx15'
```

문자열 포매팅은 { }(중괄호) 안에 포매팅을 지정하고 format 메서드로 값을 넣습니다.

**'{인덱스}'.format(값)**

```python
format(숫자, ',')

>>> format(1493500, ',')
'1,493,500'

>>> '%20s' % format(1493500, ',')    # 길이 20, 오른쪽으로 정렬
'           1,493,500'

>>> '{0:,}'.format(1493500)
'1,493,500' # 포매팅에서 콤마를 넣으려면 다음과 같이 :(콜론)뒤에 ,(콤마)를 지정하면 됩니다.

>>> '{0:>20,}'.format(1493500)     # 길이 20, 오른쪽으로 정렬
'           1,493,500'
>>> '{0:0>20,}'.format(1493500)    # 길이 20, 오른쪽으로 정렬하고 남는 공간은 0으로 채움
'000000000001,493,500' # 만약 정렬을 하고 싶다면 정렬 방향과 길이 뒤에 콤마를 지정해줍니다.
```

**리스트 메서드**

| 메서드                   | 설명                                                         |
| ------------------------ | ------------------------------------------------------------ |
| append(값)append(리스트) | 리스트 끝에 값을 추가, 리스트[len(리스트):] = [값]과 같음리스트를 넣으면 리스트 안에 리스트가 들어감 |
| extend(리스트)           | 리스트 끝에 다른 리스트 연결, 리스트[len(리스트):] = [값, 값]과 같음 |
| insert(인덱스, 값)       | 리스트의 특정 인덱스에 값을 추가                             |
| pop()pop(인덱스)         | 리스트의 마지막 값을 삭제한 뒤 삭제한 값을 반환인덱스를 지정하면 해당 인덱스의 값을 삭제한 뒤 삭제한 값을 반환, del 리스트[인덱스]와 같음 |
| remove(값)               | 리스트에서 특정 값을 삭제                                    |
| index(값)                | 리스트에서 특정 값의 인덱스를 구함                           |
| count(값)                | 리스트에서 특정 값의 개수를 구함                             |
| reverse()                | 리스트에서 값의 순서를 반대로 뒤집음                         |
| sort()sort(reverse=True) | 리스트의 값을 작은 순서대로 정렬(오름차순)reverse=True는 큰 순서대로 정렬(내림차순) |
| clear()                  | 리스트의 모든 값을 삭제, del a[:]와 같음                     |
| copy()                   | 리스트를 복사하여 새 리스트 생성                             |

튜플은 값의 정보를 구하는 index, count 메서드만 사용할 수 있습니다.

**문자열 메서드**

| 메서드                                                       | 설명                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| replace('바꿀문자열', '새문자열')                            | 문자열 안의 문자열을 다른 문자열로 바꿈                      |
| translate(테이블)                                            | 문자열 안의 문자를 다른 문자로 바꿈, str.maketrans('바꿀문자', '새문자')로 변환 테이블을 만들어야 함 |
| split()split('기준문자열')                                   | 공백을 기준으로 문자열을 분리하여 리스트로 만듦기준 문자열을 지정하면 기준 문자열로 문자열을 분리 |
| join(리스트)                                                 | 구분자 문자열과 문자열 리스트(튜플)의 요소를 연결하여 문자열로 만듦 |
| upper()lower()                                               | upper는 문자열의 문자를 대문자로 바꾸고, lower는 소문자로 바꿈 |
| lstrip(), rstrip(), strip()lstrip('삭제할문자들')rstrip('삭제할문자들')strip('삭제할문자들') | lstrip은 문자열에서 왼쪽 공백을 삭제, rstrip은 오른쪽 공백을 삭제, strip은 양쪽 공백을 삭제, 삭제할 문자들을 지정하면 해당 문자들을 삭제 |
| ljust(길이), rjust(길이), center(길이)                       | 문자열을 지정된 길이로 만든 뒤 왼쪽(ljust), 오른쪽(rjust), 가운데(center)로 정렬하며 남는 공간은 공백으로 채움 |
| zfill()                                                      | 지정된 길이에 맞춰서 문자열의 왼쪽에 0을 채움                |
| find('찾을문자열')rfind('찾을문자열')                        | find는 왼쪽에서부터, rfind는 오른쪽에서부터 특정 문자열을 찾아서 인덱스 반환, 문자열이 없으면 -1을 반환 |
| index('찾을문자열')rindex('찾을문자열')                      | index는 왼쪽에서부터, rindex는 오른쪽에서부터 특정 문자열을 찾아서 인덱스를 반환, 문자열이 없으면 에러 발생 |
| count('문자열')                                              | 현재 문자열에서 특정 문자열이 몇 번 나오는지 알아냄          |

출처 : https://dojang.io

{% endraw %}
