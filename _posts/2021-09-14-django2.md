---
layout: single
tags: 
 - django

toc: true
toc_sticky: true

title: "[django] 회원가입, 로그인"
---

{% raw %}

### 회원가입

**models.py**

```python
from django.db import models

# Create your models here.
class User(models.Model) :
    name = models.CharField(max_length=45)
    email = models.EmailField(max_length= 200, unique=True)
    password = models.CharField(max_length=400)
    phone_number = models.CharField(max_length= 100)
    
    def __str__(self):
        return self.name
    
    class Meta():
        db_table = 'users'
```

email은 같은 값으로 중복생성이 불가하므로 unique=True 를 넣어줬다.

**validation.py**

```python
import re

def validate_email(value) :
    email_regex = re.compile('^[a-zA-Z0-9+-_.]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$')
    if not email_regex.match(value):
        return False
        

def validate_password(value) :
    password_regex = re.compile("^(?=.*[A-Za-z])(?=.*\d)(?=.*[$@$!%*#?&])[A-Za-z\d$@$!%*#?&]{8,}$")

    if not password_regex.match(value):
        return False
```

정규표현식을 사용할 때 내장모듈인 re를 import 해주어야 한다.

re.compile을 사용하여 정규표현식을 컴파일한다. 컴파일된 패턴 객체를 통해 새로 생성하려는 이메일, 비밀번호와 매치시켜보고 매치되지 않을 때 False를 반환해주었다.

**views.py**

```python
import json

from django.http            import JsonResponse
from django.views           import View

from users.validation       import validate_email, validate_password
from users.models           import User

# Create your views here.
class SignUp(View):
    def post(self, request):
        data = json.loads(request.body)
        try :
            name = data['name']
            email = data['email']
            password = data['password']
            phone_number = data['phone_number']

            if validate_email(email) == False :
                return JsonResponse({'MESSAGE':'INVALID_EMAIL_ADDRESS'}, status=400)
            
            if validate_password(password) == False :
                return JsonResponse({'MESSAGE':'INVALID_PASSWORD'}, status=400)
            
            if User.objects.filter(email = email).exists():
                return JsonResponse({'MESSAGE':'ALREADY_EXISTS_EMAIL'}, status=400)
            
            User.objects.create(
                name = name,
                email = email,
                password = password,
                phone_number = phone_number,
            )

            return JsonResponse({'MESSAGE':'SUCCESS'} , status = 201)

        except KeyError :
            return JsonResponse({'MESSAGE':"KEY_ERROR"}, status = 400)
```

따로 작성한 유효성검사 파일인 users.validation 에서 validate_email, validate_password를 가져온다.

```python
if validate_email(email) == False :
     return JsonResponse({'MESSAGE':'INVALID_EMAIL_ADDRESS'}, status=400)
            
if validate_password(password) == False :
     return JsonResponse({'MESSAGE':'INVALID_PASSWORD'}, status=400)
```

validate_email, validate_password 함수에서 정규표현식과 매치되지 않았을 때 False를 반환시켰으므로 입력된 이메일과 비밀번호를 해당 함수들에 넣었을 때 False가 나오면 Response로 statuscode 400을 반환해준다. 

```python
if User.objects.filter(email = email).exists():
     return JsonResponse({'MESSAGE':'ALREADY_EXISTS_EMAIL'}, status=400)
            
User.objects.create(
     name = name,
     email = email,
     password = password,
     phone_number = phone_number,
     )

return JsonResponse({'MESSAGE':'SUCCESS'} , status = 201)
```

생성하려는 이메일 값이 기존 유저의 이메일값으로 이미 존재하면 마찬가지로 statuscode 400을 반환해준다.

세 가지를 다 통과하면 유저가 생성되고 statuscode 201을 반환한다.

```python
except KeyError :
            return JsonResponse({'MESSAGE':"KEY_ERROR"}, status = 400)
```

KeyError가 발생했을 때를 대비해서 except문을 작성한다.

**ValidationError를 사용하기**

django에서 제공하는 ValidationError를 사용해서 유효성 검사기를 만들 수도 있다.

**validation.py**

```python
import re
from django.core.exceptions import ValidationError

def validate_email(value) :
    email_regex = re.compile('^[a-zA-Z0-9+-_.]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$')
    if not email_regex.match(value):
        raise ValidationError('INVALID_EMAIL_ADDRESS')
        

def validate_password(value) :
    password_regex = re.compile("^(?=.*[A-Za-z])(?=.*\d)(?=.*[$@$!%*#?&])[A-Za-z\d$@$!%*#?&]{8,}$")
    if not password_regex.match(value):
        raise ValidationError('INVALID_PASSWORD')
```

ValidationError를 import 해준다.

이메일과 비밀번호가 매치되지 않으면 raise를 통해 ValidationError를 발생시키고 메시지를 입력한다.

**views.py**

```python
class SignUp(View):
    def post(self, request):
        data = json.loads(request.body)
        try :
            name = data['name']
            email = data['email']
            password = data['password']
            phone_number = data['phone_number']

            validate_email(email)
            validate_password(password)
            
            if User.objects.filter(email = email).exists():
                return JsonResponse({'MESSAGE':'ALREADY_EXISTS_EMAIL'}, status=400)
            
            User.objects.create(
                name = name,
                email = email,
                password = password,
                phone_number = phone_number,
            )

            return JsonResponse({'MESSAGE':'SUCCESS'} , status = 201)

        except KeyError :
            return JsonResponse({'MESSAGE':"KEY_ERROR"}, status = 400)
        
        except ValidationError as e:
            return JsonResponse({'MESSAGE':(e.message)}, status=400)
```

아까의 if문을 없애고 validate 함수에 생성하려는 이메일과 비밀번호 값을 넣어준다. 매치되지 않으면 ValidationError를 발생시킬 것이므로 except로 해당 에러가 발생했을 때 statuscode 400을 반환해준다. as e로 에러메시지를 가져와서 이메일 에러와 비밀번호 에러를 구분할 수 있게 해준다.


### 로그인

```python
class SignIn(View):
    def post(self, request):
        data = json.loads(request.body)
        try :
            email = data['email']
            password = data['password']

            if not User.objects.filter(email = email).exists() :
                return JsonResponse({'MASSAGE':'INVALID_USER'}, status = 401)
            
            if not User.objects.get(email = email).password == password :
                return JsonResponse({'MASSAGE':'INVALID_USER'}, status = 401)
            
            return JsonResponse({'MASSAGE':'SUCCESS'}, status = 200)

        except KeyError :
            return JsonResponse({'MESSAGE':"KEY_ERROR"}, status = 400)
```

이미 만들어진 유저 이메일중에 입력된 이메일이 존재하지 않는다면 401 코드를 반환한다.

해당 이메일 유저가 있다면 그 유저의 비밀번호를 가져와서 입력된 비밀번호와 비교해주고 다르다면 401 코드를 반환한다.

해당 이메일 유저가 있고 비밀번호도 같다면 200 코드를 반환한다.


{% endraw %}
